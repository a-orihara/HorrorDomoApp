# 1

# 2 name:ワークフローの名前
name: Run Rspec and Rubocop
# 3 on:イベント。ワークフローを実行するイベントを指定

on:
  push:
    # 3.5
    branches-ignore:
      - "main"
    # 3.6
  workflow_call:
    secrets:
      EMAIL_ADDRESS:
        required: true

# 3.4 envセクションはGitHub Actionsワークフロー内で使用される環境変数を設定するためのセクション
env:
  EMAIL_ADDRESS: ${{ secrets.EMAIL_ADDRESS }}

# 3.1 ジョブ。一つのjob内の全てのstepは同じVM内で実行される。
jobs:
  # jobsのマップのキー（<job_id>）。jobs.<job_id>:rspec。<job_id>:名は重複不可。
  rspec:
    # jobの名前（ = jobs<job_id>.name ）
    name: Rspec
    # runs-on:jobが実行されるマシン。必須の設定。ジョブはruns-onで指定した環境で実行される。
    runs-on: ubuntu-latest
    # jobs.<job_id>.timeout-minutes:ジョブのタイムアウト時間を定義。単位は分。
    timeout-minutes: 5
    # 3.2
    defaults:
      run:
        # 3.3
        working-directory: ./backend/api
    # 4 jobs.<job_id>.services:サービスコンテナを定義。コンテナは、ジョブと同じVM上で実行されます。
    services:
      # 4.1 jobs.<job_id>.services.<service_name>:この名前はホスト名として他コンテナから参照できる。
      mysql:
        # jobs.<job_id>.services.<service_name>.image:サービスコンテナのイメージを定義。
        image: mysql:8.0
        # 4.4 jobs.<job_id>.services.<service_name>.ports:
        ports:
          - 3306:3306
        # jobs.<job_id>.services.<service_name>.env:コンテナ内の環境変数を定義。
        env:
          # 4.3
          MYSQL_ROOT_USER: root
          # MYSQL_ROOT_PASSWORDに空を設定できる用にするフラグ."yes"を設定することで空を設定することが可能。
          # MYSQL_ALLOW_EMPTY_PASSWORD: yes
          MYSQL_ROOT_PASSWORD: rootroot
        # 4.2 jobs.<job_id>.services.<service_name>.options
        options: --health-cmd "mysqladmin ping" --health-interval 10s --health-timeout 5s --health-retries 10
    # 5 ステップ。jobs.<job_id>.services.steps:jobが実行するステップの定義
    steps:
      # jobs.<job_id>.steps.name:ステップの名前。GitHubリポジトリをgit cloneするアクションの名前を定義。
      - name: Checkout code
        # 6 アクション。jobs.<job_id>.steps.uses:アクションの実行を定義
        uses: actions/checkout@v3
      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        # 7 jobs.<job_id>.steps.with:アクションのパラメータをキー、バリューで定義
        with:
          # ruby-versionの指定が必要
          ruby-version: "3.1.2"
          # 8 bundle installを実行し、インストールされたgemsを自動的にキャッシュする。
          bundler-cache: true

      # 9 jobs.<job_id>.steps.name
      - name: Cache node modules
        # 10 actions/cache(GitHub公式のアクション)を使う事でキャッシュの機能が利用可能。
        uses: actions/cache@v3
        with:
          # 11
          path: node_modules
          # おまじない
          key: ${{ runner.os }}-node-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Bundler and gem install
        # 12 jobs.<job_id>.steps.run:コマンドラインの実行を定義
        run: |
          gem install bundler
          bundle install --jobs 4 --retry 3 --path vendor/bundle

      - name: Install Rails
        run: gem install rails

      # - name: Yarn install
      #   # 13
      #   run: yarn install --check-files

      - name: Database create and migrate
        # 14.1
        run: |
          cp config/database.yml.ci config/database.yml
          rails db:create RAILS_ENV=test
          rails db:migrate RAILS_ENV=test

      - name: Run rspec
        run: bundle exec rspec
        # 15.1
        env:
          TMDB_API: ${{ secrets.TMDB_API }}

  # 16.1
  rubocop:
    name: Rubocop
    runs-on: ubuntu-latest
    timeout-minutes: 5
    defaults:
      run:
        working-directory: ./backend/api
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.1.2"
          bundler-cache: true

      - name: Bundler and gem install
        run: |
          gem install bundler
          bundle install --jobs 4 --retry 3 --path vendor/bundle

      - name: Run rubocop
        run: bundle exec rubocop
# @          @@          @@          @@          @@          @@          @@          @@          @
# 1
# 一般的にCI/CDでやることはビルドとテストとデプロイの3点です。
# ------------------------------------------------------------------------------------------------
# - CI/CDとは「Continuous Integration（継続的インテグレーション「統合」）」と、
# 「Continuous Deployment/Continuous Delivery（継続的デプロイメント/継続的デリバリー）」の略です。
# ------------------------------------------------------------------------------------------------
### Continuous Integration（継続的インテグレーション）
# - 開発者が頻繁にコードを一元的なリポジトリに統合するプラクティス。
# - コードがリポジトリにマージされるたびに、自動的にビルドとテストが行われる。
# - 例: GitHub Actionsでプルリクエストが作成された際に、テストを自動実行。
# ------------------------------------------------------------------------------------------------
### Continuous Deployment/Delivery（継続的デプロイメント/継続的デリバリー）
# - 成功したビルドとテストを自動的に本番環境にデプロイする（Continuous Deployment）。
# - 成功したビルドを本番環境に手動でデプロイできる状態に保つ（Continuous Delivery）。
# - 例: テストが成功した後、AWS EC2への自動デプロイ。
# ------------------------------------------------------------------------------------------------
# GitHub actionsがワークフローを実行する環境について。
# ワークフローの実行環境には、GitHubが提供するVM （仮想マシン）環境と、ユーザーが構築した独自の環境（ランナーのセル
# フホスティング）。
# GitHubが提供するVM環境は、ジョブの実行ごとに毎回クリーンな環境が提供されます。ひとつのジョブ内のすべてのステップは
# 同じVM内で実行されるため、ステップ間ではファイルシステム経由で情報のやりとりができます。しかし、異なるジョブ間では別
# のVMが使われるため、ジョブ間で情報をやりとりするためには、アーティファクトなど別の方法が必要になります。
# ------------------------------------------------------------------------------------------------
# . なぜ`rails new`でアプリは作成してないけど、テストできるのか？
# - このGitHub Actionsの設定ファイルは、すでに作成されたRailsアプリがリモートリポジトリにプッシュされている前提で
# 動作します。
# - ワークフローが始まると、`Checkout code`ステップで`actions/checkout@v3`が呼び出されます。このアクションによ
# り、GitHubリポジトリのコードがGitHub Actionsのランナー（`ubuntu-latest`）にチェックアウトされます。
# - その後、`Set up Ruby`、`Bundler and gem install`で必要なRubyとGemsがインストールされます。
# - 最後に`Database create and migrate`でデータベースを作成し、テストを実行します。
# - このフローでは、`rails new`で新しいアプリケーションを作成する必要はありません。なぜなら、リモートリポジトリに既
# にRailsアプリケーションが存在し、それがこのCIプロセスでテストされるからです。

# ================================================================================================
# 2
# name
# nameは、ワークフローの名前を表します。ブラウザー上でリポジトリーのActionsタブを開いたときに表示されます。nameを省
# したときは、ワークフローファイルへの相対パス（今回だと.github/workflows/ci.yml）が代わりにワークフロー名となる。

# ================================================================================================
# 3
# on
# onは、ワークフローを実行するイベント名を表します。必須です。pushを指定しているので、リモートリポジトリーにコミット
# がpushされるたびにワークフローが実行されます。文字列でひとつのイベントのみ指定することもできますし、リストで複数のイ
# ベントを指定することもできます。例えば、pushとpull_requestの両方のイベントでワークフローが実行されるようになる。
# on:[push,pull_request]

# ================================================================================================
# 3.1
# ジョブは同じ仮想環境上で実行されるステップの集合であり、ジョブごとに仮想環境の新しいインスタンスで実行されます。
# ステップ間ではファイルシステム経由で情報のやり取りが出来る。

# ================================================================================================
# 3.2
# defaults
# ワークフローのトップレベルでdefaultsを指定すると、ワークフロー内のすべてのジョブにデフォルトで適用される設定を定義
# できます。
# * 結局defaultsの設定がうまく反映されず、それぞれの`jobsにjobs.<job_id>.defaults.run`を設定。
# ------------------------------------------------------------------------------------------------
# defaults.run
# defaultsでrunを設定することで、ワークフロー内のすべてのrunステップにデフォルトで適用される設定を定義できます。
# ------------------------------------------------------------------------------------------------
# job内でjobに個別に設定する事も可能
# jobs.<job_id>.defaults.run
# ジョブに対してdefaultsでrunを設定することで、特定のジョブ内のすべてのrunステップにデフォルトで適用される設定を定
# 義できます。

# ===============================================================================================
# 3.3
# - `working-directory`はGitHub Actionsの各ステップが実行される作業ディレクトリを指定するものです。
# - デフォルトではリポジトリのルートが作業ディレクトリとなりますが、特定のサブディレクトリでコマンドを実行したい場合
# にこのオプションを使用します。
# ------------------------------------------------------------------------------------------------
# - GitHub Actionsはステップ間で状態を共有するために作業ディレクトリを使用します。特定のステップで必要なデータ（例：
# Gemのキャッシュ）が存在するディレクトリを指定しないと、次のステップでそのデータが利用できない可能性があります。
# - Bundler(bundle install等)やRailsのコマンドはカレントディレクトリに依存する場合が多いです。そのため、作業ディ
# レクトリを明示的に指定することで、予期せぬ問題を避けることができます。
# ------------------------------------------------------------------------------------------------
# working-directory: は各ステップで必要
# GitHub Actions では working-directory は各ステップに適用される設定です。各ステップで個別に
# working-directory を指定しないと、デフォルトのディレクトリ（リポジトリのルートディレクトリ）でコマンドが実行され
# ます。そのため、複数のステップで同じディレクトリで作業をする場合、各ステップに working-directory を指定する必要
# があります。

# ===============================================================================================
# 3.4
# . **GitHub Actionsでメール送信のテストが必要な理由**
# - GitHub Actionsは、ローカル環境とは異なる環境で実行されます。これは、CI/CDパイプラインの一環として実行される
# ため、環境変数や設定がローカル環境とは異なる可能性があります。したがって、メール送信などの機能をテストする際は、そ
# の環境に適した設定を行う必要があります。
# ------------------------------------------------------------------------------------------------
# 2. **SMTP Fromアドレスが空でエラーが発生する理由**
# - `config.action_mailer.default_options = { from: ENV['EMAIL_ADDRESS'] }` この設定により、メール送信
# 時の「From」アドレスは環境変数 `EMAIL_ADDRESS` から取得されます。GitHub Actionsの環境では、この環境変数が設定
# されていない場合、メール送信時に「From」アドレスが空になり、`ArgumentError` が発生します。
# ------------------------------------------------------------------------------------------------
# . **GitHub Actionsの環境で `config/environments/test.rb` の設定が使用されない理由**
# - GitHub Actionsでは、`config/environments/test.rb` の設定は使用されます。ただし、GitHub Actionsの実行
# 環境では、ローカル環境で設定されている環境変数が自動的には引き継がれません。そのため、環境変数（例えば
# `EMAIL_ADDRESS`）はGitHub ActionsのSecretsを介して明示的に設定する必要があります。この環境変数が正しく設定さ
# れていないと、`config/environments/test.rb` で指定されたメール設定（`delivery_method = :test`）にもかかわ
# らず、メール送信時の「From」アドレスが空となり、テストが失敗することがあります。
# * Action Mailerの配送方法を （`delivery_method = :test`） に設定します。これにより、実際にメールサーバーに
# メールを送信する代わりに、送信されたメールが ActionMailer::Base.deliveries 配列に蓄積されます。この配列にメー
# ルが追加されることにより、実際にメールが送信されたかどうかのテストが可能になります。実際のSMTPサーバーへの接続は発
# 生せず、メール送信のプロセスがシミュレートされるのみです。

# ================================================================================================
# 3.5
# branches-ignore
# - これは「push によってワークフローを動作させる条件を設定している際、一部のブランチについてのみはワークフロー動作の
# 対象外にする」という設定。今回は、mainブランチへの push 時のみは、CIワークフローが動作しないように設定を追加。理由
# は、mainブランチへの push 時に動作するCDワークフロー.github/workflows/cd.ymlの中でCIワークフローを動作させる
# 記述がなされているので、こちらの方で除外設定を行わないとCIワークフローが二重で回ってしまうからです。
# mainブランチ以外へのpush: ci-backend.ymlによって、CIチェックのみが走る
# mainブランチへのpush: cd.ymlによって、CIチェック&自動デプロイが走る

# ================================================================================================
# 3.6
# workflow_call
# - これは「他のワークフローから呼び出された時に動作させる」という設定で、これによってCDワークフロー
# .github/workflows/cd.ymlの方からこちらのワークフローを呼び出すことができるようになります。

# ================================================================================================
# 4
# このセクションは、ジョブ内で使用するコンテナベースのサービスを定義します。
# git hub action内で、Dockerが使える。イメージを指定してコンテナを作成出来、それをjob内で使用出来る。
# ubuntu-latest VM（Virtual Machine）の上でコンテナが作成されます。
# ------------------------------------------------------------------------------------------------
# jobs.<job_id> .services
# servicesで、サービスで使う、サービスコンテナを定義します。servicesは、マップで指定でき、複数のコンテナを立ち上げ可
# 能です。
# サービスコンテナは、ワークフロー中でアプリケーションをテストもしくは運用するのに必要になるかもしれないサービスをホス
# トするための、シンプルでポータブルな方法を提供するDockerコンテナです。
# ジョブをコンテナ内で実行したり、コンテナアクションを実行する場合は、それぞれ同じネットワークを共有した別コンテナとし
# て実行されます。また、servicesのキ一名（リスト2.54だとpostgres)をホスト名として参照できます。
# container とは異なり、こちらはホストマシンのホームやワークスペースはデフォ。
# ------------------------------------------------------------------------------------------------
# ワークフロー中のジョブは、直接ランナーマシン上(VM上)で実行するようにも、作成したDockerコンテナ中で実行するようにも
# 設定できます。 [ジョブ]と、[ジョブのサービスコンテナ]との通信は、ジョブがランナーマシン上(VM上)で直接実行されている
# か、作成したDockerコンテナ内で実行されているかによって異なります。
# ------------------------------------------------------------------------------------------------
# ランナーマシン上でジョブを直接実行する場合、localhost:<port> か 127.0.0.1:<port> を使ってサービスコンテナにア
# クセスできます。
# 作成したDockerコンテナ内でジョブを実行する場合、GitHubはDockerのユーザー定義ブリッジネットワークを使ってサービス
# コンテナをジョブに接続します。
# ------------------------------------------------------------------------------------------------
# - GitHub Actions はランナー環境と並行してサービスコンテナを実行する機能を提供しており、ワークフローでデータベ
# ースやキャッシュ、テストやデプロイに必要なその他のサービスを利用することができます。これらのサービスコンテナは
# `localhost` またはホスト名としてサービス名を使用することでランナーからネットワークアクセス可能です。例えば、MySQL
#  サービスコンテナを定義した場合、ジョブステップはデフォルトポートと localhost、またはワークフローで定義したサービ
# ス名を使用してアクセスすることができます。この設定は、統合テストやワークフロー実行に外部サービスが必要なその他のシナ
# リオに便利です。
# ------------------------------------------------------------------------------------------------
# . `jobs.<job_id>.container` と `jobs.<job_id>.services` の違い
# - `jobs.<job_id>.container` はジョブ自体が実行されるコンテナを指定します。
# - `jobs.<job_id>.services` はジョブが依存するサービス（例えば、データベース）をコンテナとして起動する設定です。

# ================================================================================================
# 4.1
# service_nameは、mysqlではなくてdbにする。ここはdocker-compose.dev.ymlの、services: dbに合わせないと、サー
# ビス名が見つからないとエラーになる。
# ------------------------------------------------------------------------------------------------
# ubuntu-latest VM（Virtual Machine）の上でMySQLコンテナが作成されます。
# git hub actionの仮想環境で使うDB

# ================================================================================================
# 4.2
# jobs.<job_id>.services.<service_name>.options:
# サービスコンテナ作成時に、docker createコマンドに渡るオプションを定義。サービスコンテナのヘルスチェックをしている。
# --health-cmd:
# ヘルスチェックで使用するコマンドを指定する。指定したコマンドの実行結果を監視し、正常な場合と異常な場合を判断します。
# ------------------------------------------------------------------------------------------------
# - "mysqladmin ping":
# mysqladminコマンドを使用してMySQLサーバが起動しているかを確認する
# ------------------------------------------------------------------------------------------------
# --health-interval:
# ヘルスチェックを実行する間隔。10秒ごとにヘルスチェックが実行。
# ------------------------------------------------------------------------------------------------
# --health-timeout:
# ヘルスチェックがタイムアウトするまでの時間を指定。5秒以内にヘルスチェックの結果を取得できない場合、タイムアウト。
# ------------------------------------------------------------------------------------------------
# --health-retries:
# ヘルスチェックの再試行回数を指定。指定された回数だけ再試行を行う。
# ------------------------------------------------------------------------------------------------
# このコマンドの意図
# サービスが正常に起動しているかを確認するために健全性確認が必要。
# 設定がないと、サービスが起動していない状態でテストが始まる可能性がある。

# ================================================================================================
# 4.3
# - MYSQL_ROOT_PASSWORD: rootroot` は、仮想環境、特に GitHub Actions ワークフローで定義されている CI/CD パ
# イプラインで使用します。
# - この値は、リポジトリにアクセスできる人なら誰でも見ることができるので、本当のパスワードであってはいけません。
# - いいえ。`.github/workflows/backend.yml` は、たとえ `MYSQL_ROOT_PASSWORD: rootroot` のような直接的な
# 値が含まれていても、`.gitignore` に含めるべきではありません。
# - ワークフローファイルはリポジトリの一部にしておく必要があります。そうすれば、GitHub Actions で CI/CD パイプラ
# インを自動化できるようになります。
# - しかし、**ワークフローファイルには機密情報を書かないようにしましょう**。データベースのパスワードのような機密情報
# は、GitHub Secrets を使ってワークフローファイルで参照するようにしましょう。こうすることで、機密データを安全に保
# つことができます。
# - 非稼働環境やテスト環境では、`rootroot` のような単純なパスワードを使うのが比較的一般的です。その代わりに、
# GitHub Secrets を使ったよりセキュアな方法を選びましょう。特にリポジトリが公開されている場合はなおさらです。

# ================================================================================================
# 4.4
# jobs.<job_id>.services.<service_name>.ports:
# ホストマシンからサービスコンテナにアクセスするポート番号を定義。

# ================================================================================================
# 5
# このstepsの作業はVM(ubuntu-latest)上で行われる。
# ------------------------------------------------------------------------------------------------
# job内で行われる実際の作業を定義。必須項目。
# それぞれのステップは、異なるプロセスで実行される。この為、ステップ内で環境変数を変更しても、後のステップには変更が反
# 映されません。反映させるには:set-envを設定する。
# 1つのジョブには、steps (ステップ) と呼ばれる一連のタスクがあります。
# すべてのステップでアクションを実行するとは限りませんが、すべてのアクションはステップとして実行されます。
# ------------------------------------------------------------------------------------------------
# ステップは、後述するアクションやコマンドなどを実行できる個別のタスクです。ステップはジョブ内に1つ以上必要です。
# ジョブ中の各ステップは同じ仮想環境で実行されるため、ジョブ内のアクションはファイルシステムを利用して情報共有可能。た
# だし、各ステップは別プロセスとして動くので注意が必要です。

# ================================================================================================
# 6
# uses（ = jobs<job_id>.steps.uses
# アクションの実行に必要なリポジトリーを指定する。アクションはGitHubが提供するもの等。@以降のバージョン指定は必須。
# 外部のリポジトリーだけでなく、ワークフロー実行中のリポジトリー内にあるアクションを相対パスで指定することもできます。
# Docker レジストリにあるイメージをアクションとして実行することもできます。
# この場合は、@ ではなく：でイメージのタグを指定します。
# ------------------------------------------------------------------------------------------------
# actions/checkout@v3:
# GitHub公式の「アクション」。GitHubが提供しているアクションは、actions/で始まるリポジトリーに格納されている。
# （GitHub Actionsでは、よく使う便利な処理のまとまりがモジュール化されており、必要に応じて呼び出して使うことができ
# ます。こうしたモジュールのことを「アクション」と呼びます。アクションはGitHubが公式でリリースしているものもあれば、そ
# れ以外の組織や個人が作成して公開しているものもあります。）
# ------------------------------------------------------------------------------------------------
# - `actions/checkout@v3`は、GitHub Actionsでリポジトリのコードをチェックアウトするためのアクションです。
# - このアクションが実行されると、ワークフローが走る仮想マシンに対象のpushしたローカルのコードのGitHubリポジトリが、
# `git clone`される。
# - コードベースに対して何らかの操作（テスト、ビルドなど）を行う前に、まずそのコードを仮想環境に持ってくる必要がある。
# それを簡単に行うために`actions/checkout`が用いられる。

# ================================================================================================
# 7
# jobs.<job_id>.steps.with
# with はアクションに渡すパラメータを定義します。マップのキーがパラメータ名、バリューが値です。

# ===============================================================================================
# 8
# bundler-cache: true
# setup-ruby アクションにより、rubyのBundlerが自動的にインストールされているので、Bundlerのコマンド、
# [bundle install]が使える。
# ------------------------------------------------------------------------------------------------
# with:
#       bundler-cache: trueで、
# run: bundle installも一緒に行われている
# ------------------------------------------------------------------------------------------------
# - `ruby/setup-ruby@v1`アクションに対してBundlerのキャッシュを使用するよう指示しています。
# - bundle installを実行し、インストールされたgemsを自動的にキャッシュする設定をするパラメーター。
# - マップのキーがbundler-cacheで、バリューがtrueなので、bundler-cacheパラメータにtrueが設定されます。
# - キャッシュとは、データやリソースを一時的に保存して高速なアクセスを可能にする仕組みを指します。この文脈では、
# 「bundle install を実行し、Gemをキャッシュする」というのは、プロジェクトの依存Gem（ライブラリやツール）のインス
# トールを一度行い、そのインストールされたGemを特定の場所に保存しておくことを意味します。二回目以降の実行でキャッシ
# ュを読み込むことで、ビルド時間が短縮される。

# ===============================================================================================
# 9
# . rspecのテストに`node_modules`が出てくる理由
# - node_modules とは package.json を元にしてインストールされる各種npmパッケージがインストールされているディレ
# クトリ先。
# - rspecのテストにおいて、そのテストでJavaScriptのの動作に依存するフィーチャーテストが含まれたり、Railsアプリで
# は、WebpackerやJavaScriptライブラリを使用している場合が多い為。

# ===============================================================================================
# 10
# . actions/cache@v3
# - GitHub Actionsのキャッシュ機能を提供する公式アクションです。
# - `node_modules` ディレクトリをキャッシュして、GitHub Actionsのビルド時間を短縮します。

# ===============================================================================================
# 11
# . path: node_modules
# - `path: node_modules`は、キャッシュするディレクトリ（`node_modules`）を指定しています。
# - この設定の意図は、Node.jsの依存関係を次回のビルドで再利用することで、ビルド時間を短縮することです。
# - GitHub Actionsは仮想環境で毎回環境をセットアップしますが、依存関係のインストールは時間がかかる作業です。
# - そのため、依存関係をキャッシュすることで、時間を節約し、ビルドを高速化することが目的です。

# ===============================================================================================
# 12
# . `gem install bundler`
# - `gem install bundler` コマンドは、Bundlerと呼ばれるGemをインストール。
# - Bundlerは、Rubyプロジェクトで使用される依存関係を管理し、`Gemfile` と `Gemfile.lock` ファイルを使用して必
# 要なGemのバージョンや依存関係を追跡します。
# ------------------------------------------------------------------------------------------------
# . `bundle install --jobs 4 --retry 3 --path vendor/bundle`
# - `bundle install` コマンドは、`Gemfile` 内に指定されたGemの依存関係を解決し、Gemをインストールします。
# - `--jobs 4` オプションは、同時に実行するジョブの数を指定。この場合、最大で4つのジョブが同時に実行されます。
# これにより、Gemのインストールが並列化され、効率的に行われます。
# - `--retry 3` オプションは、インストールが失敗した場合に再試行する回数を指定。この場合、最大で3回再試行されます。
# - `--path vendor/bundle` オプションは、インストールされたGemをプロジェクト内の `vendor/bundle` ディレクト
# リに配置することを指定します。これにより、プロジェクトごとにGemを管理し、システム全体のGemとの競合を避けることがで
# きます。
# ------------------------------------------------------------------------------------------------
# --path vendor/bundle オプションをつける意味
# オプションをつけると、RubyプロジェクトのGem（ライブラリや依存関係）をプロジェクトのディレクトリ内の、
# `vendor/bundle`ディレクトリにインストールすることができます。これにより、プロジェクトごとに独立したGemセットを持
# つことができます。一方、オプションをつけない場合、通常はシステム全体のGemセットにインストールされます。
# システム全体のGemセットに保存されると、同じGemの異なるバージョンを異なるプロジェクトで共有する場合、競合が発生する
# 可能性があります。

# ===============================================================================================
# 13
# . `yarn install`:
# - YarnというNode.jsのパッケージマネージャを使用して、プロジェクトに記述された依存パッケージをインストール。
# . `--check-files`:
# - このオプションは、既にインストールされているパッケージとプロジェクトに記述されている依存関係を比較し、必要なファ
# イルが欠けているかどうかをチェックします。これにより、不整合がある場合に警告やエラーを表示することで問題を特定する。

# ================================================================================================
# 14.1
# - actions/checkout@v3によってチェックアウトされたVMコード内のdatabase.yml.ci（テスト環境のDB設定）を
# database.ymlにコピーします。
# ------------------------------------------------------------------------------------------------
# - これは、継続的インテグレーション (CI) やテスト環境用に特別に用意されたデータベース設定ファイル (`database.yml.ci`)
# を、Rails が使用するデフォルトのデータベース設定ファイル (`database.yml`) にコピーするために使用します。これは、
# 開発環境や本番環境とは別に、テスト環境が正しいデータベース設定を使用するようにするためです。通常、`database.yml.ci`
# には、よりシンプルなパスワードや異なるデータベース名、CIプラットフォームが提供するサービス（GitHub Actionsなど）と
# 互換性のある設定など、CI環境に適した設定が含まれています。

# ================================================================================================
# 15.1
# - `TMDB_API: ${{ secrets.TMDB_API }}` は GitHub シークレットに保存されている値を指します。GitHub シークレ
# ットは、API キーなどの機密情報をコードや設定ファイルにハードコーディングすることなく安全に保存・利用するためのもの。

# ================================================================================================
# 16.1
# - Rubocop ジョブにデータベースが作成されないのは、Rubocop テストにデータベースが必要ないからです。Rubocop は
# Ruby コードの静的コードアナライザであり、リンタです。コードを実行することなく、スタイル上の問題やコード臭、潜在的
# なエラーをチェックします。そのため、アプリケーションのロジックやデータの取り扱いをテストするためにデータベースへの
# アクセスは不要です。
# ------------------------------------------------------------------------------------------------
# - GitHub Actions の各ジョブは独自の環境で実行され、あるジョブ(Rspec)で作成されたデータベースなどのリソースは、
# 成果物やキャッシュを通じて明示的に共有されない限り、別のジョブでは利用できません。

# rails db:create RAILS_ENV=test
#           bundle exec rails db:migrate RAILS_ENV=test
