# 1
name: "infra test"

on:
  push:
    branches:
      - main
    # paths:
    #   - 10_infra/**
    #   - .github/workflows/**
  workflow_dispatch:

# 2 git hubとawsを連携させるのに必要。git hub実行に際して二つ許可する。
permissions:
  # 2.1 トークンの書き換えに必要な許可
  id-token: write
  # 2.2
  contents: read

# envセクションはGitHub Actionsワークフロー内で使用される環境変数を設定するためのセクション
env:
  TF_VERSION: 1.3.10
  AWS_REGION: ap-northeast-1
  # アプリのドメイン名
  DOMAIN: "horror-domo-app.com"
  RDS_INSTANCE_NAME: "portfolio-mysql-rds-instance"

# 全てのjobに対するデフォルト動作を設定
defaults:
  run:
    shell: bash
    working-directory: ./terraform

jobs:
  # jobsのマップのキー（<job_id>）。すなわちid。jobs.<job_id>:rspec。<job_id>:名は重複不可。
  preview:
    # jobの名前（ = jobs<job_id>.name ）
    name: Preview
    # runs-on:jobが実行されるマシン。必須の設定。
    runs-on: ubuntu-latest
    # 2.3 jobの実行結果を参照可能にする
    outputs:
      TF_PLAN_EXITCODE: ${{ steps.plan.outputs.exitcode }}
    steps:
      # jobs.<job_id>.steps.name:ステップの名前。
      - name: Cehckout repository
        # リポジトリのコードやファイルをワークフローの実行環境にチェックアウト（ダウンロード）するためのアクション
        uses: actions/checkout@v3

      - name: Setup terraform
        # terraformのセットアップをするアクション
        uses: hashicorp/setup-terraform@v2
        # アクションの引数
        with:
          # ${{}}:git hub actionの式。env.でgithubactionで設定した環境変数を利用可能
          terraform_version: ${{ env.TF_VERSION }}

      # initの前にfmtを実行
      - name: Terraform format
        # 3
        run: |
          terraform fmt -check

      # 4 initにawsのキーが必要
      - name: Configure AWS Credential
        uses: aws-actions/configure-aws-credentials@v1
        with:
          # このアクションに必須の引数 env.:git hub actionで設定した環境変数
          aws-region: ${{ env.AWS_REGION }}
          # githubaction上でawsリソースを操作する為のroleのarnを使用。secrets.:gitのsecretで作成した環境変数
          role-to-assume: ${{ secrets.AWS_IAM_ROLE_ARN }}

      - name: Terraform init
        # git hub actionのログは色がない為、no colorを設定
        run: |
          terraform init -no-color

      - name: Terraform validate
        run: |
          terraform validate -no-color

      - name: Terraform plan
        # 4.1 terraform planが失敗してもSlack Notifyを実行支えるため
        continue-on-error: true
        # 4.2 この[Terraform plan]の結果をアウトプットする為にIDを指定
        id: plan
        # 4.3 Terraformでは、変数名にアンダースコア（_）を使用することは一般的
        run: |
          terraform plan \
            -var 'domain=${{ env.DOMAIN }}' \
            -var 'rails_master_key=${{ secrets.RAILS_MASTER_KEY }}' \
            -var 'mysql_db_username=${{ secrets.MYSQL_DB_USERNAME }}' \
            -var 'mysql_db_password=${{ secrets.MYSQL_DB_PASSWORD }}' \
            -var 'rds_instance_name=${{ env.RDS_INSTANCE_NAME }}' \
            -input=false \
            -no-color \
            -detailed-exitcode

      - name: Slack Notify terraform plan
        # 5
        if: steps.plan.outputs.exitcode == 2
        # Slackへの通知の為、指定されたSlackチャンネルにメッセージを送信する機能を提供。
        uses: slackapi/slack-github-action@v1.22.0
        # jobs.<job_id>.steps.with:アクションのパラメータをキー、バリューで定義
        with:
          # slackのチャンネルIDを指定
          channel-id: "C06574M0PK8"
          # 5.1 YAMLファイル内で|は、複数行にわたる文字列を表すために使用されます。
          payload: |
            {
              "attachments": [
                {
                  "color": "#0068B7",
                  "blocks": [
                    {
                      "type": "header",
                      "text": {
                        "type": "plain_text",
                        "text": "Request for approve - portfolioのdeployの承認依頼 -",
                        "emoji": true
                      }
                    },
                    {
                      "type": "section",
                      "text": {
                        "type": "mrkdwn",
                        "text": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                      }
                    }
                  ]
                }
              ]
            }
        env:
          # slacアプリ作成の際に一緒に作成したbot_token
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

  # jobが変わればrunnerも変わるので、環境を改めて構築する
  deploy:
    name: Deploy
    # 6.1
    needs: preview
    # 6.2 2の場合にこのdeployジョブが実行される
    if: needs.preview.outputs.TF_PLAN_EXITCODE == 2
    # 6.3
    environment: production
    # 環境を改めて構築する
    runs-on: ubuntu-latest
    steps:
      - name: Cehckout repository
        uses: actions/checkout@v3

      - name: Setup terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform format
        run: |
          terraform fmt -check

      # ポリリーの"Condition"をStringLikeへ変更必要
      - name: Configure AWS Credential
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_IAM_ROLE_ARN }}

      - name: Terraform init
        run: |
          terraform init -no-color

      - name: Terraform apply
        # 6.4 apply結果が知りたいので、このstepの結果をidを使って参照出来るようにする
        id: apply
        # 6.5
        run: |
          terraform apply \
            -var 'domain=${{ env.DOMAIN }}' \
            -var 'rails_master_key=${{ secrets.RAILS_MASTER_KEY }}' \
            -var 'mysql_db_username=${{ secrets.MYSQL_DB_USERNAME }}' \
            -var 'mysql_db_password=${{ secrets.MYSQL_DB_PASSWORD }}' \
            -var 'rds_instance_name=${{ env.RDS_INSTANCE_NAME }}' \
            -input=false \
            -no-color \
            -auto-approve

      - name: Slack Notify terraform apply
        # 7.1 成功、失敗でも必ずstepを実行したい場合に付ける
        if: always()
        # Slackへの通知の為、指定されたSlackチャンネルにメッセージを送信する機能を提供。
        uses: slackapi/slack-github-action@v1.22.0
        # jobs.<job_id>.steps.with:アクションのパラメータをキー、バリューで定義
        with:
          # slackのチャンネルIDを指定
          channel-id: "C06574M0PK8"
          # YAMLファイル内で|は、複数行にわたる文字列を表すために使用されます。
          payload: |
            {
              "attachments": [
                {
                  "color": "#0068B7",
                  "blocks": [
                    {
                      "type": "header",
                      "text": {
                        "type": "plain_text",
                        "text": "Runner Finished - ${{ steps.apply.outcome }} -",
                        "emoji": true
                      }
                    },
                    {
                      "type": "section",
                      "text": {
                        "type": "mrkdwn",
                        "text": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                      }
                    }
                  ]
                }
              ]
            }
        env:
          # slacアプリ作成の際に一緒に作成したbot_token
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}




# @          @@          @@          @@          @@          @@          @@          @@          @
# 1.1
# この作業の前提
# ------------------------------------------------------------------------------------------------
# . **GitHub Actionsワークフロー内でのTerraformの実行**:
#  - はい、GitHub Actionsのワークフローファイル内でTerraformは仮想環境（例えば、`ubuntu-latest`など）内で実行
# されています。
# - GitHub Actionsは、指定されたランナー環境（Linux, macOSなど）の仮想マシン上でワークフローを実行します。
# - ワークフローファイル内で定義されたステップに従って、Terraformの各コマンド（`init`、`plan`、`apply`など）は
# この仮想環境内で実行されます。
# ------------------------------------------------------------------------------------------------
# . **GitHub Actionsワークフロー内でのTerraformのAWS認証プロセス**:
# - Terraformは、AWSリソースにアクセスするためにAWSの認証情報が必要です。通常、これはAWSのアクセスキーとシークレッ
# トキーで行われますが、GitHub Actionsの環境ではOIDC（OpenID Connect）プロトコルを介した方法で認証が行われる。
# - OIDCは下記1.2参照
# - GitHub Actionsワークフローでは、GitHub Actionsがクライアントとして動作し、OIDCを利用してAWSの一時的なクレ
# デンシャル（IDトークン）を取得します。これは`aws-actions/configure-aws-credentials`アクションによって設定さ
# れます。
# - このアクションは、GitHub ActionsがAWSのIDプロバイダー(IDトークン発行者=IDプロバイダー)に対して認証情報の要
# 求を行い、成功するとAWSが一時的なセキュリティトークンと一時的なAWSアクセスキーとシークレットアクセスキーを提供しま
# す。
# - 前提として、まずAWSにIDプロバイダーとそれ用のIAMロールを作成。IAMロールには信頼する相手（git hub action）と
# 権限、つまりGitHub Actionsのワークフローからのアクセスを許可する設定を事前に設定する。そうすると、terraforは
# git hub actionからのアクセスであれば、そのIDプロバイダーとそのIAMロールを使用してAWSリソースを作成する。
# ------------------------------------------------------------------------------------------------
# - 一時的なセキュリティトークンは、AWSによって提供され、セキュリティのために使用される追加のクレデンシャル。通常、
# AWSとのやり取りには、アクセスキーとシークレットアクセスキーが必要。しかし、一時的なセキュリティトークンは、AWSリソ
# ースへの一時的かつ限定的なアクセスを提供し、自動化されたプロセスを引き受けるような特定のシナリオで使用される。
# - Terraformは、これらの一時的なクレデンシャルを使用してAWS APIにアクセスし、リソースの作成、変更、削除などを行い
# ます。
# - つまり、GitHub Actionsが最初にAWSに認証し、その後、取得した一時的なクレデンシャルをTerraformに渡してAWSリソ
# ースを操作します。
# 要約すると、GitHub Actionsワークフロー内でTerraformは仮想環境上で実行され、AWSへの認証にはGitHub Actionsが
# OIDCを利用して取得した一時的なクレデンシャルを使用します。これにより、TerraformはAWSリソースに安全にアクセスでき
# るようになります。
# ------------------------------------------------------------------------------------------------
# . **一時的なクレデンシャル（トークン）を発行するサービスと仕組み**:
# - 一時的なクレデンシャル（トークン）の発行は、AWSが行います。このプロセスはOpenID Connect（OIDC）を利用します。
# - OIDCを通じて、GitHub ActionsはAWSに対し、一時的な認証情報の要求を行います。
# - AWSはこの認証情報の要求を受け入れ、GitHub Actionsの特定のワークフロー実行に対して一時的なAWSクレデンシャル（
# アクセスキー、シークレットキー、セッショントークン）を生成します。
# - これにより、TerraformはAWSリソースに安全にアクセスするための一時的なクレデンシャルを使用できます。
# ------------------------------------------------------------------------------------------------
# . **aws-actions/configure-aws-credentialsによって設定されること**:
# - `aws-actions/configure-aws-credentials` GitHub Actionは、GitHub Actionsワークフローで使用されるAWS
# の認証情報を実行環境に設定します。
# - 結果として、ワークフロー内のTerraformなどのツールは、これらの認証情報を使用してAWSリソースにアクセスできます。
# ------------------------------------------------------------------------------------------------
# . **role-to-assumeの役割**:
# - `role-to-assume: ${{ secrets.AWS_IAM_ROLE_ARN }}`は、GitHub ActionsがAWSのリソースにアクセスするため
# に仮想的に「引き受ける（assume）」IAMロールを指定します。
# - このIAMロールはAWS内で定義、作成されたもので、特定の権限（例えば、EC2インスタンスを作成する権限など）が付与され
# ています。
# - GitHub ActionsはこのIAMロールを引き受けることで、ロールに設定された権限に基づいてAWSリソースを操作できます。

# ================================================================================================
# 1.2
# - OIDCは、OAuth 2.0 の拡張仕様のプロトコル。
# 詳細は（https://qiita.com/TakahikoKawasaki/items/498ca08bbfcc341691fe）
# - GitHub Actions では OpenID Connect (OIDC) がサポートされています。
# OIDC を使用することにより長期間有効なアクセスキーなどを用意することなく AWS 認証を行うことができます。
# - IDトークンの発行者（今回のケースだとAWS）のことを『OpenID プロバイダー』と呼びます。

# ================================================================================================
# 2
# git hub actionのapiを動作させる際の許可設定
# permissions:
  # id-token: write
  # contents: read
# ------------------------------------------------------------------------------------------------
# . **`permissions:` の解説**
# - `permissions:` キーはGitHub Actions ワークフロー内で、ジョブが GitHub のリソースにアクセスする際に必要な
# 権限レベルを設定するために使用されます。
# - `permissions:` キーで指定された権限以外のアクションについては、そのワークフローは実行できません。
# - `permissions:` キーを全く指定しない場合、ワークフローはリポジトリに設定されているデフォルトの権限レベルを継承
# します。2021年4月以降に作成されたリポジトリでは、デフォルトの権限レベルは「読み取りと書き込みの権限」です。
# - 各権限は、GitHub APIへのアクセスレベルを明示的に制限または許可するために詳細に設定することができます。セキュリ
# ティのベストプラクティスとして、最小限の権限原則（Principle of Least Privilege）に従って、必要な操作に対して
# のみ必要な権限を付与するべきです。

# ================================================================================================
# 2.1
# - `id-token: write` は、id-tokenの書き換え許可。
# - GitHub ActionsがOIDC（OpenID Connect）トークンを生成し、書き込む権限を持つことを示しています。OIDCトークン
# はAWSの認証に使用され、AWSリソースへのアクセスを認証するために必要です。GitHub Actionsはこのトークンを生成し、
# AWSに対して認証情報として提供します。
# - OIDCトークンを生成するのはAWSではなくGitHub Actionsです。これは GitHub Actions の機能の一部です。
# ------------------------------------------------------------------------------------------------
# - GitHub Actions のワークフローで `id-token: write` 権限を設定すると、GitHub Actions で OIDC トークン
# の生成と書き込みができるようになります。これらのトークンは AWS との認証に使われ、GitHub Actions が AWS リソ
# ースとやりとりできるようにします。

# ================================================================================================
# 2.2
# - `contents: この設定は、GitHub Actionsがリポジトリ（ワークフローを実行しているこのGitHub上のリポジトリ）内の
# ファイルやディレクトリのコンテンツを読み取る権限を持つことを示しています。
# - 具体的には、Terraform設定ファイルやその他のリソースを読み取ってAWSの認証情報やデプロイに必要な情報を取得します。

# ================================================================================================
# 2.3
# . `outputs: TF_PLAN_EXITCODE: ${{ steps.plan.outputs.exitcode }}`:
# - `outputs`は、ジョブの実行結果を外部に公開するために使用されます。
# - この行では、`Terraform plan`ステップ（`id: plan`によって識別）の出力（`exitcode`）を`TF_PLAN_EXITCODE`
# という名前でジョブの出力として設定しています。
# - 終了コードをジョブの出力として保存し、後のステップで使用できるようにします。
# ------------------------------------------------------------------------------------------------
# - `steps.plan`: これはGitHub Actionsのワークフロー内で定義されたステップを指します。`Terraform plan`のステ
# ップが`plan`というIDで識別されています。
# - `.outputs`: ステップの出力を指します。GitHub Actionsでは、各ステップの実行結果として出力を生成します。
# - `.exitcode`: これは`Terraform plan`ステップの実行終了時に得られる終了コード（exit code）を表します。終了コ
# ードはステップの成功または失敗を示す数値です。
# - 具体的には、steps.plan.outputs.exitcode`に終了コードが保存されます。この終了コードを使用して、後続のステッ
# プ（例えば、特定の条件下でSlackに通知を送るなど）で条件分岐を行うことができます。例えば、変更が必要な場合（終了コー
# ドが2の場合）に特定のアクション（例えばSlackへの通知）を実行することができます。

# ================================================================================================
# 3
# フォーマットの修正が入るファイルがあるかどうかをチェックできます。なお、修正の実行はしません。あくまでもチェック。
# 実際にファイルの内容を変更するのではなく、フォーマットが正しくない場合にはそれを報告します。
# ファイルがすでに正しいフォーマットであれば、0を返し、何も出力せずに終了します。
# ファイルがフォーマットの規約に従っていなければ、それを標準出力に表示し、0以外の終了コードを返します。
# ------------------------------------------------------------------------------------------------
# . **終了コード0と0以外の意味と仕組み**:
# - UNIX系システム（Linux, macOSなど）およびその他の多くのオペレーティングシステムでは、プログラムやコマンドの終了
# コード（exit code）が成功または失敗を示します。
# - 終了コード0は、一般的に「成功」または「エラーなし」と解釈されます。
# - 0以外の終了コードは、何らかのエラーまたは異常終了を示します。これはシステムによって異なる意味を持つことがあります。
# - GitHub Actionsのワークフローでは、コマンドの終了コードを使用して次のステップに進むかどうかを判断します。終了コ
# ード0（成功）の場合、ワークフローは次のステップに進みます。0以外の場合（エラー）、ワークフローは通常、エラーとして停
# 止します。

# ================================================================================================
# 4
# `Configure AWS Credential`ステップの必要性について
# - Terraformを使用してAWSリソースを管理する際、AWSの認証情報（クレデンシャル）が必要です。
# - GitHub ActionsのワークフローでAWSリソースを操作するには、AWSへの認証が必須です。
# - `Configure AWS Credential`ステップは、AWSアクションズが提供する`configure-aws-credentials`アクションを
# 使用しています。このアクションは、AWSへの認証情報を設定する役割を果たします。
# - このステップでは、指定されたAWSリージョン(`aws-region`)とIAMロール(`role-to-assume`)を使用して、
# GitHub ActionsランナーにAWSクレデンシャルを提供します。
# - IAMロールを使用することで、必要な権限を持つ一時的なクレデンシャルを取得し、セキュリティを確保しつつAWSリソースに
# アクセスできます。
# - Terraformの操作（`init`、`validate`、`plan`など）に必要なAWSリソースへのアクセスを確保するため、このステッ
# プが不可欠です。
# ------------------------------------------------------------------------------------------------
# - GitHub Actions では、AWS の認証情報は通常 localのAWS 設定ファイルやプロファイルでは設定されません。代わりに
# 環境変数や`aws-actions/configure-aws-credentials`のようなアクションによって直接提供されます。
# - Terraform を GitHub Actions で実行して名前付きプロファイル（`portfolio-terraform-aws-profile` など）
# を使おうとすると、このプロファイルが GitHub Actions 環境に存在しないため失敗します。
# ------------------------------------------------------------------------------------------------
# - TerraformのAWSプロバイダ設定で`profile`属性をコメントアウトすることで、TerraformにAWS設定ファイルから特定の
# プロファイルを探さず、代わりに環境（この場合はGitHub Actionsワークフロー）から提供される認証情報を使用するように
# 指示します。
# - ワークフロー内の`aws-actions/configure-aws-credentials`アクションがAWSの認証情報を設定し、Terraformが特
# 定のプロファイルを探さなくなったため、正常に使用されます。
# ------------------------------------------------------------------------------------------------
# まとめると、`profile` 属性を削除することで、Terraform が GitHub Actions 環境に存在しない名前のプロファイルを
# 探す代わりに、GitHub Actions 環境が提供する AWS クレデンシャルを使用できるようになったため、エラーは解決した。

# ================================================================================================
# 4.1
# `continue-on-error: true`
# GitHub Actionsワークフローのジョブ内で特定のステップでエラーが発生した場合でも、ワークフローの実行を中断せずに、
# ワークフローの実行を続行する設定。

# ================================================================================================
# 4.2
# . `id: plan`:
# - このIDは、特定のステップ（この場合は`Terraform plan`ステップ）に一意の識別子を割り当てるために使用されます。
# - `id`を設定することで、そのステップの出力を他のステップで参照することができます。ここでは`Terraform plan`ステ
# ップの実行結果を後のステップで使用するために`plan`というIDを割り当てています。

# ================================================================================================
# 4.3
# . **`-var 'domain=${{ env.DOMAIN }}'`の文法**:
# - この文法は、Terraformにおいてコマンドライン(terraform planに)変数を指定するオプションです。
# - `-var`オプションは、Terraformの`plan`や`apply`コマンドで変数を設定するために使用されます。
# - `'domain=${{ env.DOMAIN }}'`は、`domain`という名前のTerraform変数にGitHub Actionsの環境変数`DOMAIN`
# の値を割り当てます。
# - `${{ env.DOMAIN }}`はGitHub Actionsの構文で、`env`コンテキストの`DOMAIN`環境変数の値を参照しています。
# - ここでの`DOMAIN`は、ワークフローの`env`セクションで定義されている`"horror-domo-app.com"`が代入されます。
# ------------------------------------------------------------------------------------------------
# 2. **`-var`の解説**:
# - `terraform plan`コマンドの`-var`オプションは、Terraformにおいて外部から変数を渡すために使用されます。
# - このオプションにより、スクリプトやCI/CDパイプラインなどの外部プロセスから、Terraformの実行環境に特定の変数値を
# 注入することができます。
# - 通常、`-var`オプションは`-var '変数名=値'`の形式で使用され、ここで指定された変数名と値は、Terraformの実行中
# に利用可能となります。
# ------------------------------------------------------------------------------------------------
# -input=false:
# terraform planの際、ユーザーからの手動入力を受けるかどうかを制御します。デフォルトでは-input=trueです
# 変数の設定がある場合、値が割り当てられていない変数の値をプロンプトでユーザーに尋ねます。
# プロンプトが表示されるのは、変数が定義されていてもデフォルト値が設定されていない場合、またはコマンドライン、環境変数
# 、.tfvars ファイル経由で値が提供されていない場合に限られます。
# - これを設定する理由は変数未定義の際にエラーを出す為
# ------------------------------------------------------------------------------------------------
# no-color:
# Terraform の出力から色を除去するために使用されます。これは主に、ログファイルへの出力や、色を解釈できないツールを介
# して結果を表示する場合に便利です。
# ------------------------------------------------------------------------------------------------
# -detailed-exitcode: コマンド終了時に詳細な情報を返す
# - 実行したプランの結果に応じて異なる終了コードを返すために使用されます。具体的には、以下のような終了コードを返すこ
# とができます：
# 0: 変更が必要なし（アップデートが不要）
# 1: エラー発生
# 2: 変更が必要あり（アップデートが必要）
# - CI/CD パイプライン内で Terraform プランを実行し、変更が発生しているかどうかに基づいて次のステップを決定する場
# 合に -detailed-exitcode を利用します。例えば、変更がある場合のみ Terraform Apply ステップを実行するような条
# 件を設定することができます。
# - ciの場合、2の場合だけ承認を取って後続を実施するようにする
# 特に設定しない場合、２の場合でもエラーで止まる。
# GitHub Actionsのワークフローでは、コマンドの終了コードを使用して次のステップに進むかどうかを判断します。終了コー
# ド0（成功）の場合、ワークフローは次のステップに進みます。0以外の場合（エラー）、ワークフローは通常、エラーとして停
# 止します。

# ================================================================================================
# 5.
# `if: steps.plan.outputs.exitcode == 2`
# - `if`: このキーワードは、GitHub Actionsのワークフロー内で条件分岐を行うために使用されます。指定された条件が真
# （true）の場合にのみ、後続のステップが実行されます。
# - `steps.plan.outputs.exitcode`: これは、`Terraform plan`ステップ（`id: plan`で識別）の実行後に生成され
# る出力である終了コード（exit code）を指します。終了コードはステップの成功、失敗、または変更の必要性などを示す数値
# です。
# - `== 2`: この式は、`Terraform plan`の終了コードが2であるかどうかを評価します。Terraformでは、終了コード2は
# 実行計画に変更が含まれていることを意味します（つまり、実際にリソースの状態が変更される操作が必要であることを示してい
# ます）。
# - `Terraform plan`ステップが変更を必要とする結果（終了コードが2）を返した場合にのみ、後続の`Slack Notify`ステ
# ップを実行するように設定しています。これにより、変更が必要な場合に限り、通知がSlackに送信されるようになります。

# ================================================================================================
# 5.1
# . `with`の`payload`キーの解説:
# - `payload`キーは、GitHub ActionsのワークフローでSlack通知をカスタマイズするために使用されます。
# - このキーは、Slackへ送信されるメッセージの内容とフォーマットをJSON形式で定義します。
# - ここで定義された内容は、Slack APIによって解釈され、指定されたチャンネルにメッセージが送信されます。
# ------------------------------------------------------------------------------------------------
# . `with`の`payload`キーに設定する内容:
# - 以下の例では、Slackメッセージにアタッチメントが含まれており、そのフォーマットが指定されています。
# - アタッチメントには色(`color`)、ヘッダー(`header`)、セクション(`section`)が含まれています。
# - ヘッダーには「Message Header」というテキストが、セクションには「Hello World :ghost:」というMarkdown形式
# のテキストが含まれています。
# - この設定により、指定したフォーマットでSlackチャンネルにメッセージが投稿されます。
# ------------------------------------------------------------------------------------------------
# . attachmentsは、Slackメッセージに追加される構造化されたデータブロックです。
# これにより、Slackメッセージ内で複数のセクションや要素をカスタマイズして表示することができます。
# ------------------------------------------------------------------------------------------------
# `${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`
# - `github.server_url`: GitHubのサーバーURLを指します。通常は`https://github.com`です。
# - `github.repository`: 現在のリポジトリの名前を示します。例えば`user/repository`の形式になります。
# - `github.run_id`: 現在実行中のGitHub Actionsワークフローの一意のIDを表します。
# これらを組み合わせることで、現在実行中のGitHub Actionsワークフローの具体的な実行ページのURLが生成されます。
# つまり、この式はGitHub上での現在のワークフロー実行の詳細ページへのリンクを生成しています。このリンクは、
# GitHub Actionsが実行された際にSlack通知を送るために使用されており、通知内でクリックすると直接そのワークフローの
# 実行詳細ページにアクセスできるようになっています。

# ================================================================================================
# 6.1
# `needs: preview` はGitHub Actionsワークフロー内でジョブ間の依存関係を指定するものです。
# - `needs: preview`: この設定は `deploy` ジョブに対して、`preview` ジョブの完了を待機するように指示しています。
# 依存関係を持つジョブの設定により、ジョブの実行順序や連携を制御できます。異なるジョブ間でデータを共有したり、ジョブの
# 実行順序を制御したりすることができます。

# ================================================================================================
# 6.2
# `if: needs.preview.outputs.TF_PLAN_EXITCODE == 2` はGitHub Actionsワークフローの条件式です。この条件式
# に基づいて、特定のアクションを実行するかどうかを制御します。
# - `preview` ジョブの結果である `TF_PLAN_EXITCODE` の値が `2` と等しい場合にアクションを実行します。具体的に
# は、`preview` ジョブでTerraformの計画 (`terraform plan`) を実行し、その結果のステータスコードが `2` である
# 場合に、`Slack Notify` アクションを実行します。
# ------------------------------------------------------------------------------------------------
# - needs キーワードはジョブの依存関係を指定するだけでなく、他のジョブのアウトプット（出力）を参照にも使用えます。
# `needs` キーワードで指定された `preview` ジョブの実行結果に依存しています。つまり、`preview` ジョブが完了する
# 前に `deploy` ジョブは実行されません。
# - `outputs.TF_PLAN_EXITCODE` は `preview` ジョブの結果から取得される値で、この場合は `TF_PLAN_EXITCODE`
# という名前のアウトプットです。
# - `==` は等しいことを示す比較演算子です。つまり、左辺と右辺が等しい場合に真となります。
# - `2` は比較の右辺で、`preview` ジョブの `TF_PLAN_EXITCODE` の値が `2` と等しい場合に条件が真となります。

# ================================================================================================
# 6.3
# - `environment: 特定のジョブが実行される環境を指定します。GitHub Actionsワークフローで特定の環境（この場合は、
# production）にデプロイメントを行う際に使用されます。GitHubで「Environments」の設定要。
# ------------------------------------------------------------------------------------------------
# . **Environmentsの概念**:
# - GitHub Actionsの「Environments」は、リポジトリごとに異なるデプロイメント環境（例:開発、テスト、本番）を設定
# する機能です。
# - 各環境に対して、デプロイメントの保護規則、環境変数、シークレットなどを個別に設定できます。
# - 例えば、あるジョブが本番環境にアプリケーションをデプロイする際に`environment: production`を使用します。
# - この設定により、本番環境専用のシークレット（APIキー、データベースの接続情報など）がそのジョブで利用できます。
# - また、本番環境へのデプロイメントは通常、厳格な承認プロセスが必要です。`environment: production`を使用すると、
# 本番環境に対するデプロイメントには追加の承認が必要になる設定を反映できます。
# - そのジョブに対して環境特有の設定（例えば、環境変数、シークレット、保護されたブランチのルールなど）が適用されます。
# これにより、開発やテスト環境とは異なる本番環境特有の条件やセキュリティ要件を満たすことができます。
# ------------------------------------------------------------------------------------------------
# . **`environment: production`の文法**:
# - `environment: production`は、GitHub Actionsワークフローの特定のジョブが本番環境（production）に対して実
# 行されることを示します。

# ================================================================================================
# 6.4
# . **`id: apply`での参照可能性**:
# - GitHub Actionsのワークフロー内で、`id`をステップに割り当てると、そのステップの実行結果や出力を後続のワークフロ
# ー内の他のステップやジョブで参照で参照できるようになります。これは、ステップの出力（例：実行ログ）や結果（成功したか
# 失敗したか）を取得するのに役立ちます。
# ------------------------------------------------------------------------------------------------
# . **`outcome`とは**:
# - `outcome`はGitHub Actionsの特定のステップやジョブの実行結果を示す内部変数です。`outcome`は、そのステップが
# 成功したか失敗したかを表します。通常、`success`、`failure`、`cancelled`などの値を取ることができます。
# - ステップの`id`を使用して`outcome`を参照することにより、以降のステップやジョブでそのステップの実行結果に基づいた
# 条件分岐や処理を行うことが可能になります。

# ================================================================================================
# 6.5
# -auto-approve
# このフラグは、この手動承認のステップをスキップし、変更を自動的に承認して適用するために使用されます。
# - GitHub Actionsのワークフローでは、対話的な入力（例えば、yesの入力）が可能ではありません。そのため、Terraform
# の自動化された適用（例えばCI/CDパイプライン内での使用）では、-auto-approveフラグが重要になります。これにより、プ
# ランの自動承認と適用が可能となり、ワークフローが途中で停止することなく完了できます。

# ================================================================================================
# 7.1
# `if: always()`機能は、特定のステップやジョブが前のステップの結果に関わらず実行されるようにするために使用されます。
# これは、特定のクリーンアップ操作や通知（例えば、ビルドの成功や失敗をSlackに通知する）など、条件に関係なく実行したい
# タスクに非常に役立ちます。
