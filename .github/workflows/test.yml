# 1

# 2 name:ワークフローの名前
name: Run rspec
# 3 on:ワークフローを実行するイベントを指定
on:
  pull_request:
    branches: [main]
# 一つのjob内の全てのstepは同じVM内で実行される。ステップ間ではファイルシステム経由で情報のやり取りが出来る。
jobs:
  # jobsのマップのキー（<job_id>）。jobs.<job_id>:rspec。<job_id>:名は重複不可。
  rspec:
    # jobの名前（ = jobs<job_id>.name ）
    name: Rspec Test
    # runs-on:jobが実行されるマシン。必須の設定。
    runs-on: ubuntu-latest
    # jobs.<job_id>.timeout-minutes:ジョブのタイムアウト時間を定義。単位は分。
    timeout-minutes: 10
    # 4 jobs.<job_id>.services:サービスコンテナを定義。
    services:
      # 4.1 jobs.<job_id>.services.<service_name>:この名前はホスト名として他コンテナから参照できる。
      db:
        # jobs.<job_id>.services.<service_name>.image:サービスコンテナのイメージを定義。
        image: mysql:8.0
        # jobs.<job_id>.services.<service_name>.ports:
        # ホストマシンからサービスコンテナにアクセスするポート番号を定義。
        ports:
          - 3306:3306
        # jobs.<job_id>.services.<service_name>.env:コンテナ内の環境変数を定義。
        env:
          MYSQL_ROOT_USER: root
          # MYSQL_ROOT_PASSWORDに空を設定できる用にするフラグ."yes"を設定することで空を設定することが可能。
          # MYSQL_ALLOW_EMPTY_PASSWORD: yes
          MYSQL_ROOT_PASSWORD: rootroot
        # 4.2 jobs.<job_id>.services.<service_name>.options
        options: --health-cmd "mysqladmin ping" --health-interval 10s --health-timeout 5s --health-retries 10
    # 5 jobs.<job_id>.services.steps:jobが実行するステップの定義
    steps:
      # jobs.<job_id>.steps.name:ステップの名前。GitHubリポジトリをgit cloneするアクションの名前を定義。
      - name: Checkout code
        # 6 jobs.<job_id>.steps.uses:アクションの実行を定義
        uses: actions/checkout@v3

      # - name: move to working directory
      #   run: |
      #     cd backend/api
      #     pwd
      # - name: cd api
      #   run: |
      #     cd backend/api
      #     pwd

      - name: Set up Ruby
        # ruby/setup-ruby:Ruby公式のアクション。指定したバージョン(v1.146.0)のRubyをVMにダウンロード
        # uses: ruby/setup-ruby@55283cc23133118229fd3f97f9336ee23a179fcf
        uses: ruby/setup-ruby@v1
        # 7 jobs.<job_id>.steps.with:アクションのパラメータをキー、バリューで定義
        with:
          # ruby-versionの指定が必要
          ruby-version: "3.1.2"
          # 8 bundle installを実行し、インストールされたgemsを自動的にキャッシュする。
          bundler-cache: true

      # 9 jobs.<job_id>.steps.name
      # - name: Cache node modules
      #   # 10 actions/cache(GitHub公式のアクション)を使う事でキャッシュの機能が利用可能。
      #   uses: actions/cache@v3
      #   with:
      #     # 11
      #     path: node_modules
      #     # おまじない
      #     key: ${{ runner.os }}-node-${{ hashFiles('**/yarn.lock') }}
      #     restore-keys: |
      #       ${{ runner.os }}-node-

      - name: Bundler and gem install
        working-directory: ./backend/api
        # 12 jobs.<job_id>.steps.run:コマンドラインの実行を定義
        run: |
          gem install bundler
          bundle install

      # - name: Yarn install
      #   # 13
      #   run: yarn install --check-files

      - name: Database create and migrate
        working-directory: ./backend/api
        # actions/checkout@v3によってチェックアウトされたVMコード内のdatabase.yml.ciをdatabase.ymlにコピーします。
        run: |
          bundle exec rails db:create RAILS_ENV=test
          bundle exec rails db:migrate RAILS_ENV=test

      - name: Run rspec
        run: bundle exec rspec
        working-directory: ./backend/api
# @          @@          @@          @@          @@          @@          @@          @@          @
# 1
# 一般的にCI/CDでやることはビルドとテストとデプロイの3点です。
# ------------------------------------------------------------------------------------------------
# - CI/CDとは「Continuous Integration（継続的インテグレーション）」と、
# 「Continuous Deployment/Continuous Delivery（継続的デプロイメント/継続的デリバリー）」の略です。
# ------------------------------------------------------------------------------------------------
### Continuous Integration（継続的インテグレーション）
# - 開発者が頻繁にコードを一元的なリポジトリに統合するプラクティス。
# - コードがリポジトリにマージされるたびに、自動的にビルドとテストが行われる。
# - 例: GitHub Actionsでプルリクエストが作成された際に、テストを自動実行。
# ------------------------------------------------------------------------------------------------
### Continuous Deployment/Delivery（継続的デプロイメント/継続的デリバリー）
# - 成功したビルドとテストを自動的に本番環境にデプロイする（Continuous Deployment）。
# - 成功したビルドを本番環境に手動でデプロイできる状態に保つ（Continuous Delivery）。
# - 例: テストが成功した後、AWS EC2への自動デプロイ。
# ------------------------------------------------------------------------------------------------
# GitHub actionsがワークフローを実行する環境について。
# ワークフローの実行環境には、GitHubが提供するVM （仮想マシン）環境と、ユーザーが構築した独自の環境（ランナーのセル
# フホスティング）。
# GitHubが提供するVM環境は、ジョブの実行ごとに毎回クリーンな環境が提供されます。ひとつのジョブ内のすべてのステップは
# 同じVM内で実行されるため、ステップ間ではファイルシステム経由で情報のやりとりができます。しかし、異なるジョブ間では別
# のVMが使われるため、ジョブ間で情報をやりとりするためには、アーティファクトなど別の方法が必要になります。
# ------------------------------------------------------------------------------------------------
# . なぜ`rails new`でアプリは作成してないけど、テストできるのか？
# - このGitHub Actionsの設定ファイルは、すでに作成されたRailsアプリがリモートリポジトリにプッシュされている前提で
# 動作します。
# - ワークフローが始まると、`Checkout code`ステップで`actions/checkout@v3`が呼び出されます。このアクションによ
# り、GitHubリポジトリのコードがGitHub Actionsのランナー（`ubuntu-latest`）にチェックアウトされます。
# - その後、`Set up Ruby`、`Bundler and gem install`で必要なRubyとGemsがインストールされます。
# - 最後に`Database create and migrate`でデータベースを作成し、テストを実行します。
# - このフローでは、`rails new`で新しいアプリケーションを作成する必要はありません。なぜなら、リモートリポジトリに既
# にRailsアプリケーションが存在し、それがこのCIプロセスでテストされるからです。

# ================================================================================================
# 2
# name
# nameは、ワークフローの名前を表します。ブラウザー上でリポジトリーのActionsタブを開いたときに表示されます。nameを省
# したときは、ワークフローファイルへの相対パス（今回だと.github/workflows/ci.yml）が代わりにワークフロー名となる。

# ================================================================================================
# 3
# on
# onは、ワークフローを実行するイベント名を表します。必須です。今国だと、pushを指定しているので、リポジトリーにコミット
# がpushされるたびにワークフローが実行されます。文字列でひとつのイベントのみ指定することもできますし、リストで複数のイ
# ベントを指定することもできます。例えば、pushとpull_requestの両方のイベントでワークフローが実行されるようになる。
# on:[push,pull_request]

# ================================================================================================
# 4
# このセクションは、ジョブ内で使用するコンテナベースのサービスを定義します。
# git hub action内で、Dockerが使える。イメージを指定してコンテナを作成出来、それをjob内で使用出来る。
# ubuntu-latest VM（Virtual Machine）の上でコンテナが作成されます。
# ------------------------------------------------------------------------------------------------
# jobs.<job_id> .services
# servicesで、サービスで使う、サービスコンテナを定義します。servicesは、マップで指定でき、複数のコンテナを立ち上げ可
# 能です。
# ジョブをコンテナ内で実行したり、コンテナアクションを実行する場合は、それぞれ同じネットワークを共有した別コンテナとして実行されます。また、servicesのキ
# 一名（リスト2.54だとpostgres)をホスト名として参照できます。
# container とは異なり、こちらはホストマシンのホームやワークスペースはデフォ。

# ================================================================================================
# 4.1
# service_nameは、mysqlではなくてdbにする。ここはdocker-compose.dev.ymlの、services: dbに合わせないと、サー
# ビス名が見つからないとエラーになる。
# ------------------------------------------------------------------------------------------------
# ubuntu-latest VM（Virtual Machine）の上でMySQLコンテナが作成されます。
# git hub actionの仮想環境で使うDB

# ================================================================================================
# 4.2
# jobs.<job_id>.services.<service_name>.options:
# サービスコンテナ作成時に、docker createコマンドに渡るオプションを定義。サービスコンテナのヘルスチェックをしている。
# --health-cmd:
# ヘルスチェックで使用するコマンドを指定する。指定したコマンドの実行結果を監視し、正常な場合と異常な場合を判断します。
# ------------------------------------------------------------------------------------------------
# - "mysqladmin ping":
# mysqladminコマンドを使用してMySQLサーバが起動しているかを確認する
# ------------------------------------------------------------------------------------------------
# --health-interval:
# ヘルスチェックを実行する間隔。10秒ごとにヘルスチェックが実行。
# ------------------------------------------------------------------------------------------------
# --health-timeout:
# ヘルスチェックがタイムアウトするまでの時間を指定。5秒以内にヘルスチェックの結果を取得できない場合、タイムアウト。
# ------------------------------------------------------------------------------------------------
# --health-retries:
# ヘルスチェックの再試行回数を指定。指定された回数だけ再試行を行う。
# ------------------------------------------------------------------------------------------------
# このコマンドの意図
# サービスが正常に起動しているかを確認するために健全性確認が必要。
# 設定がないと、サービスが起動していない状態でテストが始まる可能性がある。

# ================================================================================================
# 5
# このstepsの作業はVM(ubuntu-latest)上で行われる。
# ------------------------------------------------------------------------------------------------
# job内で行われる実際の作業を定義。必須項目。
# それぞれのステップは、異なるプロセスで実行される。この為、ステップ内で環境変数を変更しても、後のステップには変更が反
# 映されません。反映させるには:set-envを設定する。
# 1つのジョブには、steps (ステップ) と呼ばれる一連のタスクがあります。
# すべてのステップでアクションを実行するとは限りませんが、すべてのアクションはステップとして実行されます。

# ================================================================================================
# 6
# uses（ = jobs<job_id>.steps.uses
# アクションの実行に必要なリポジトリーを指定する。アクションはGitHubが提供するもの等。@以降のバージョン指定は必須。
# 外部のリポジトリーだけでなく、ワークフロー実行中のリポジトリー内にあるアクションを相対パスで指定することもできます。
# Docker レジストリにあるイメージをアクションとして実行することもできます。
# この場合は、@ ではなく：でイメージのタグを指定します。
# ------------------------------------------------------------------------------------------------
# actions/checkout@v3:
# GitHub公式の「アクション」。GitHubが提供しているアクションは、actions/で始まるリポジトリーに格納されている。
# （GitHub Actionsでは、よく使う便利な処理のまとまりがモジュール化されており、必要に応じて呼び出して使うことができ
# ます。こうしたモジュールのことを「アクション」と呼びます。アクションはGitHubが公式でリリースしているものもあれば、そ
# れ以外の組織や個人が作成して公開しているものもあります。）
# ------------------------------------------------------------------------------------------------
# - `actions/checkout@v3`は、GitHub Actionsでリポジトリのコードをチェックアウトするためのアクションです。
# - このアクションが実行されると、ワークフローが走る仮想マシンに対象のpushしたローカルのコードのGitHubリポジトリが、
# `git clone`される。
# - コードベースに対して何らかの操作（テスト、ビルドなど）を行う前に、まずそのコードを仮想環境に持ってくる必要がある。
# それを簡単に行うために`actions/checkout`が用いられる。

# ================================================================================================
# 7
# jobs.<job_id>.steps.with
# with はアクションに渡すパラメータを定義します。マップのキーがパラメータ名、バリューが値です。

# ===============================================================================================
# 8
# bundler-cache: true
# setup-ruby アクションにより、rubyのBundlerが自動的にインストールされているので、Bundlerのコマンド、
# [bundle install]が使える。
# ------------------------------------------------------------------------------------------------
# with:
#       bundler-cache: trueで、
# run: bundle installも一緒に行われている
# ------------------------------------------------------------------------------------------------
# - `ruby/setup-ruby@v1`アクションに対してBundlerのキャッシュを使用するよう指示しています。
# - bundle installを実行し、インストールされたgemsを自動的にキャッシュする設定をするパラメーター。
# - マップのキーがbundler-cacheで、バリューがtrueなので、bundler-cacheパラメータにtrueが設定されます。
# - キャッシュとは、データやリソースを一時的に保存して高速なアクセスを可能にする仕組みを指します。この文脈では、
# 「bundle install を実行し、Gemをキャッシュする」というのは、プロジェクトの依存Gem（ライブラリやツール）のインス
# トールを一度行い、そのインストールされたGemを特定の場所に保存しておくことを意味します。二回目以降の実行でキャッシ
# ュを読み込むことで、ビルド時間が短縮される。

# ===============================================================================================
# 9
# . rspecのテストに`node_modules`が出てくる理由
# - node_modules とは package.json を元にしてインストールされる各種npmパッケージがインストールされているディレ
# クトリ先。
# - rspecのテストにおいて、そのテストでJavaScriptのの動作に依存するフィーチャーテストが含まれたり、Railsアプリで
# は、WebpackerやJavaScriptライブラリを使用している場合が多い為。

# ===============================================================================================
# 10
# . actions/cache@v3
# - GitHub Actionsのキャッシュ機能を提供する公式アクションです。
# - `node_modules` ディレクトリをキャッシュして、GitHub Actionsのビルド時間を短縮します。

# ===============================================================================================
# 11
# . path: node_modules
# - `path: node_modules`は、キャッシュするディレクトリ（`node_modules`）を指定しています。
# - この設定の意図は、Node.jsの依存関係を次回のビルドで再利用することで、ビルド時間を短縮することです。
# - GitHub Actionsは仮想環境で毎回環境をセットアップしますが、依存関係のインストールは時間がかかる作業です。
# - そのため、依存関係をキャッシュすることで、時間を節約し、ビルドを高速化することが目的です。

# ===============================================================================================
# 12
# . `gem install bundler`
# - `gem install bundler` コマンドは、Bundlerと呼ばれるGemをインストール。
# - Bundlerは、Rubyプロジェクトで使用される依存関係を管理し、`Gemfile` と `Gemfile.lock` ファイルを使用して必
# 要なGemのバージョンや依存関係を追跡します。
# . `bundle install --jobs 4 --retry 3 --path vendor/bundle`
# - `bundle install` コマンドは、`Gemfile` 内に指定されたGemの依存関係を解決し、Gemをインストールします。
# - `--jobs 4` オプションは、同時に実行するジョブの数を指定。この場合、最大で4つのジョブが同時に実行されます。
# これにより、Gemのインストールが並列化され、効率的に行われます。
# - `--retry 3` オプションは、インストールが失敗した場合に再試行する回数を指定。この場合、最大で3回再試行されます。
# - `--path vendor/bundle` オプションは、インストールされたGemをプロジェクト内の `vendor/bundle` ディレクト
# リに配置することを指定します。これにより、プロジェクトごとにGemを管理し、システム全体のGemとの競合を避けることがで
# きます。

# ===============================================================================================
# 13
# . `yarn install`:
# - YarnというNode.jsのパッケージマネージャを使用して、プロジェクトに記述された依存パッケージをインストール。
# . `--check-files`:
# - このオプションは、既にインストールされているパッケージとプロジェクトに記述されている依存関係を比較し、必要なファ
# イルが欠けているかどうかをチェックします。これにより、不整合がある場合に警告やエラーを表示することで問題を特定する。

# rails db:create RAILS_ENV=test
#           bundle exec rails db:migrate RAILS_ENV=test
