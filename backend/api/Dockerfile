# ベースとなるイメージの指定（rubyのバージョン安定版（22/10現在）3.1.2を指定）
FROM ruby:3.1.2

# 1
RUN apt-get update -qq \
  && apt-get install -y nodejs npm \
  && rm -rf /var/lib/apt/lists/* \
  && npm install --global yarn

# 作業ディレクトリはその後のDockerfile内でのRUN,COPYなどのあらゆる命令の起点となるカレントディレクトリ。
WORKDIR /api-app
#COPY(コピー)はローカル側のファイルをdockerイメージ側の指定したディレクトリにコピーする
COPY Gemfile /api-app/Gemfile
COPY Gemfile.lock /api-app/Gemfile.lock
# RUN mkdir -p /api-app/tmp/sockets
# Gemfileに記載されたGem(初回時はrailsが記載)をインストールする。再ビルド時にbundle installするために記載。
RUN bundle install
# ------------------------------------------------------------------------------------------------
COPY . /api-app
# ------------------------------------------------------------------------------------------------
# コンテナ起動時に毎回実行されるスクリプトを追加する。/usr/bin/はコンテナのLinuxベースのディレクトリ。
COPY entrypoint.sh /usr/bin/
# 1.1 entrypoint.shの権限(+x:すべてのユーザーに実行権限を追加)を変更
RUN chmod +x /usr/bin/entrypoint.sh
# 2 ENTRYPOINTはdocker runの時に実行される
ENTRYPOINT ["entrypoint.sh"]
# ------------------------------------------------------------------------------------------------
VOLUME /api-app/public
VOLUME /api-app/tmp
# ------------------------------------------------------------------------------------------------

# 4
# EXPOSE 3000
# 3 イメージの実行時に実行するメインプロセス
CMD ["rails", "server", "-b", "0.0.0.0"]

# @          @@          @@          @@          @@          @@          @@          @@
# 1
# RUNはビルド時(docker buildのとき)にコンテナ内で実行されます。
# 一つのDockerfileは複数のRUNを持ち、ビルドステップに応じて呼び出されます。
# RUNの数だけレイヤー(中間生成コンテナ)が生成されるので少ないに越したことはないです。
# ------------------------------------------------------------------------------------------------
# apt-get:Debian系のコマンド。Ubuntuパッケージ管理システム＝APTライブラリを利用してパッケージ操作・
# 管理するコマンド
# apt-get update:インストール可能なパッケージの一覧の更新
# -qq:quietモードで実行。ログを極力表示させない。エラー以外を表示しないオプション
# ------------------------------------------------------------------------------------------------
# Railsの起動に必要となるnodejsとnpmをインストールする。常にyesの-y指定。
# apt-get install -y nodejs npm
# ------------------------------------------------------------------------------------------------
# rm -rf:ディレクトリを強制削除。aptのキャッシュを削除し容量を小さくする
# rm -rf /var/lib/apt/lists/* \
# ------------------------------------------------------------------------------------------------
# なぜnodejs、npm、yarnをインストールするのですか？これらはRailsに必要なのでしょうか？
# JavaScriptランタイム： Node.jsはJavaScriptランタイムとして機能します。Railsアプリケーションのアセットをコンパ
# イルする際に必要になることがよくあります。アセットパイプラインに関連する多くの機能にはJavaScriptランタイムが必要で
# す。
# パッケージ管理: npmはNode.jsのパッケージマネージャです。npmをインストールするのは、yarnをインストールするための
# 前提条件だからです。
# Yarn：これもパッケージマネージャのひとつで、JavaScriptパッケージを管理するために最近のRailsアプリケーションでよ
# く使われています。
# これらは必要か: アプリケーションによります。Rails APIを構築していてフロントエンドのコードがない場合、厳密に言えば
# これらは必要ないかもしれません。しかし、インストールしておくことで、将来の開発のための柔軟性を高めることができます。
# ------------------------------------------------------------------------------------------------
# 理由
# Railsは、特にWebpackerのような機能の導入により、JavaScriptをエコシステムに統合する方向に進んでいます。
# より汎用的なRailsイメージに後からフロントエンドのロジックを追加する可能性がある場合、Node.js、npm、Yarnを含める
# のは良い判断です。
# また、Dockerfileにデフォルトでこれらを含めることで、これらの機能が必要になったときにDockerfileを後でカスタマイ
# ズする必要がなくなります。

# ================================================================================================
# 1.1
# `RUN chmod +x /usr/bin/entrypoint.sh`は、Dockerイメージのビルドプロセス内で実行されるコマンドです。このコマ
# ンドの目的は、Dockerコンテナが起動されたときに実行されるスクリプトファイル `entrypoint.sh` に実行権限を付与する
# ことです。
# ------------------------------------------------------------------------------------------------
# `chmod +x` コマンドは、ファイルに実行権限を付与するために使用されます。この場合、`/usr/bin/entrypoint.sh` と
# いうパスにあるスクリプトファイルに対して実行権限が付与されます。
# ------------------------------------------------------------------------------------------------
# `entrypoint.sh` スクリプトは、通常、Dockerコンテナが起動された際に初期化や設定を行うために使用されるスクリプト
# です。例えば、データベースのセットアップ、環境変数の設定、アプリケーションの起動などのタスクを実行することがあります
# 。スクリプトが実行権限を持たない場合、コンテナ内でスクリプトを実行することができないため、このコマンドを使用して実行
# 権限を付与しています。
# ------------------------------------------------------------------------------------------------
# 通常、`ENTRYPOINT` または `CMD` によって指定されたコマンドは、このスクリプトが実行されることでコンテナ内のアプリ
# ケーションが起動されます。

# ================================================================================================
# 2
# ENTRYPOINT
# ENTRYPOINTはCMD同様、イメージからコンテナを作成する時（docker run時）に実行されるのですが、
# ENTRYPOINTはdocker runの引数のcommandに上書きされません。
# ENTRYPOINTはCMDと組み合わせて使います。
# ENTRYPOINTとCMDが両方書かれているとき、書く順番によらず、ENTRYPOINTを実行するコマンドとして、CMD
# をそのコマンドのargumentとして、実行されます。
# ------------------------------------------------------------------------------------------------
# ENTRYPOINTは、コンテナを実行ファイル(executable)として処理するように設定できます。
# exec形式を公式で推奨。shell形式では、CMDやrunコマンドラインの引数を使えません。
# ENTRYPOINTのexec形式は、確実に実行するデフォルトのコマンドと引数を設定するために使います。
# 複数のコマンドが必要な場合は、シェルスクリプトから実行する
# ------------------------------------------------------------------------------------------------
# ["entrypoint.sh"]の最終行の[exec "$@"]より、CMD ["rails", "server", "-b", "0.0.0.0"]が
# 実行される。
# ------------------------------------------------------------------------------------------------
# コンテナが起動するプロセスに関連する各コードは以下のような順序で実行されます。

# 1. **railsのDockerfile**
# - `RUN`コマンドなどでイメージがビルドされる時に実行される。
# - `CMD ["rails", "server", "-b", "0.0.0.0"]`は、このイメージがコンテナとして起動する際のデフォルトのコマン
# ドです。
# ------------------------------------------------------------------------------------------------
# 2. **entrypoint.sh**
# - コンテナが起動する際に、`ENTRYPOINT ["entrypoint.sh"]`が最初に実行されます。
# - `rm -f /api-app/tmp/pids/server.pid`というコマンドが含まれており、古い`server.pid`が削除されます。
# - `exec "$@"`は、このスクリプトが引数として受け取ったコマンド（例：`rails server`）を実行します。
# ------------------------------------------------------------------------------------------------
# 3. **docker-compose.prod.ymlの`command`**
# - `command: bash -c "rm -f tmp/pids/server.pid && rails s -p 3000 -b '0.0.0.0'"` は、
# `docker-compose up`が実行された際に、`api`サービスに対して実行されます。
# - この`command`は`Dockerfile`の`CMD`をオーバーライドします。
# ------------------------------------------------------------------------------------------------
# 根拠:
# - Dockerfileの`CMD`はデフォルトのコマンドですが、docker-composeや`docker run`で指定された`command`によっ
# てオーバーライドされます。
# - `ENTRYPOINT`はコンテナが起動する際に最初に実行される点で、一種のイニシャライザとして機能します。
# ------------------------------------------------------------------------------------------------
# 総合すると、起動の順番は以下の通りです。
# 1. `ENTRYPOINT ["entrypoint.sh"]` が実行され、古い`server.pid`が削除されます。
# 2. docker-composeの`command`が実行されます。このとき、新たに`rails s -p 3000 -b '0.0.0.0'`が呼び出されます。
# ------------------------------------------------------------------------------------------------
### docker-compose -f docker-compose.dev.yml run --rm api rails db:seedを実行したとき
# 1. `entrypoint.sh` が実行される。この中で `/api-app/tmp/pids/server.pid` が削除される。
# 2. コマンドラインで指定した `rails db:seed` が実行される。
# 3. `command: bash -c "rm -f tmp/pids/server.pid && rails s -p 3000 -b '0.0.0.0'"` は実行されない。
# `docker-compose run`で特定のコマンドを指定した場合、そのコマンドが実行されるので、`docker-compose.yml`の
# `command`は無視される。
# ------------------------------------------------------------------------------------------------
### docker-compose -f docker-compose.dev.yml upを実行したとき
# 1. `entrypoint.sh` が実行される。この中で `/api-app/tmp/pids/server.pid` が削除される。
# 2. `command: bash -c "rm -f tmp/pids/server.pid && rails s -p 3000 -b '0.0.0.0'"` が実行される。
# 3. `CMD ["rails", "server", "-b", "0.0.0.0"]` は**実行されない**。
# 根拠：`docker-compose up`を使ってコンテナを起動すると、`docker-compose.yml`に記載された`command`が、
# `Dockerfile`の`CMD`より優先されて実行されます。

# ================================================================================================
# 3
# bindオプションで0.0.0.0を指定。0.0.0.0は全てのアドレスという意味。由まり、どのIP Addressからも
# railsサーバーに接続可能という意味。
# ------------------------------------------------------------------------------------------------
# CMD
# CMDは完成したイメージからコンテナを作成するときに実行されます。つまりdocker runの時に実行されます。
# 1つのDockerfileにつき1つのCMDが呼び出され、複数書いてあったとしても最後に書かれたものが実行されま
# す。ただし、docker runの引数としてcommandが指定されていた場合、これが最後のコマンドと捉えられ、こ
# れに上書きされてしまいます。
# ------------------------------------------------------------------------------------------------
# ↓pumaでUNIXドメインソケット通信する為、ポート指定は不要になる。
# CMD ["rails", "server"]
# ------------------------------------------------------------------------------------------------
# コンテナでメインとして実行するプロセスは、 Dockerfileの最後に書かれているENTRYPOINTかCMD か、あるいは両方によっ
# て指定します。
# ------------------------------------------------------------------------------------------------
# なぜCMDと`docker-compose.prod.yml` の`command`を両方書くのか？
# - `CMD`: これはデフォルトのコマンドを設定。このCMDをDockerfile に記述することで、`docker run` などで明示的な
# コマンド（`docker-compose run rails db:create`など）が指定されない限り、このCMDが実行される。
# - `docker-composeのcommand`: docker-compose の設定で、`CMD` を上書きする役割を果たします。
### なぜ両方設定するか
# - 柔軟性：`docker-compose.prod.yml` の `command` は、開発環境で必要なコマンド（たとえば
#  `rm -f tmp/pids/server.pid` のような）ができる。一方、Dockerfile の `CMD` はより一般的な使用ケースで使わ
# れる。
# - 冗長性：どちらかが削除または変更された場合、もう一方がデフォルトのコマンドとして機能する。
# - 明確な区分：`Dockerfile` はイメージ作成に関する設定、`docker-compose.yml` はコンテナ起動に関する設定という
# ように、責任範囲が分かれている。
# このように、それぞれ異なる目的や状況で使われるため、両方を設定している場合も多いです。

# ================================================================================================
# 4
# EXPOSE 3000
# コンテナがホスト(ローカルPC)に対してリッスンするport番号を3000に設定する。
# ここで設定しなくても、コンテナ立ち上げ時に-p 3010:3000のようにすれば、ポート接続出来る
# pumaでUNIXドメインソケット通信する為、ポート指定は不要に。