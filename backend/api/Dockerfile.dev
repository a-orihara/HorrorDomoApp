# ベースとなるイメージの指定（rubyのバージョン安定版（22/10現在）3.1.2を指定）
FROM ruby:3.1.2

# 1
RUN apt-get update -qq \
  && apt-get install -y nodejs npm vim\
  && rm -rf /var/lib/apt/lists/* \
  && npm install --global yarn

# 作業ディレクトリはその後のDockerfile内でのRUN,COPYなどのあらゆる命令の起点となる、Dockerコンテナ内でのカレントディレクトリ。
WORKDIR /api-app
#COPY(コピー)はローカル側のファイルをdockerイメージ側の指定したディレクトリにコピーする
COPY Gemfile /api-app/Gemfile
COPY Gemfile.lock /api-app/Gemfile.lock
# RUN mkdir -p /api-app/tmp/sockets
# Gemfileに記載されたGem(初回時はrailsが記載)をインストールする。再ビルド時にbundle installするために記載。
RUN bundle install
# COPY . /api-appは、docker-compose.dev.ymlでバウンドされているのでいらない
# コンテナ起動時に毎回実行されるスクリプトを追加する。/usr/bin/はコンテナのLinuxベースのディレクトリ。
COPY entrypoint.sh /usr/bin/
# 1.1 entrypoint.shの権限(+x:すべてのユーザーに実行権限を追加)を変更
RUN chmod +x /usr/bin/entrypoint.sh
# 2 ENTRYPOINTはdocker runの時に実行される
ENTRYPOINT ["entrypoint.sh"]
# 4
# EXPOSE 3000
# 3 イメージの実行時に実行するメインプロセス
CMD ["rails", "server", "-b", "0.0.0.0"]

# @          @@          @@          @@          @@          @@          @@          @@
# 1
# docker exec -it <コンテナID> bash
# ------------------------------------------------------------------------------------------------
# RUNはビルド時(docker buildのとき)にコンテナ内で実行されます。
# 一つのDockerfileは複数のRUNを持ち、ビルドステップに応じて呼び出されます。
# RUNの数だけレイヤー(中間生成コンテナ)が生成されるので少ないに越したことはないです。
# ------------------------------------------------------------------------------------------------
# apt-get:Debian系のコマンド。Ubuntuパッケージ管理システム＝APTライブラリを利用してパッケージ操作・
# 管理するコマンド
# apt-get update:インストール可能なパッケージの一覧の更新
# -qq:quietモードで実行。ログを極力表示させない。エラー以外を表示しないオプション
# リポジトリの情報を最新の状態に保ち、インストールやアップデートされるパッケージが最新バージョンであることを確認する
# ために使用される。
# Dockerコンテナ内での利用では、コンテナビルド時に最新のパッケージ情報を取得し、依存関係を正しく解決するために重要。
# ------------------------------------------------------------------------------------------------
# Railsの起動に必要となるnodejsとnpmをインストールする。常にyesの-y指定。
# apt-get install -y nodejs npm
# ------------------------------------------------------------------------------------------------
# rm -rf:ディレクトリを強制削除。aptのキャッシュを削除し容量を小さくする
# rm -rf /var/lib/apt/lists/* \
# ------------------------------------------------------------------------------------------------
# パッケージ管理: npmはNode.jsのパッケージマネージャです。npmをインストールするのは、yarnをインストールするための
# 前提条件だからです。
# Yarn：これもパッケージマネージャのひとつで、JavaScriptパッケージを管理するために最近のRailsアプリケーションでよ
# く使われています。
# ------------------------------------------------------------------------------------------------
# 理由
# Rails 6はWebpackerを標準でサポートしており、JavaScriptの管理にNode.jsとnpm（またはYarn）が必要。
# APIモードであっても、アセットパイプライン（JavaScriptやCSSなどのフロントエンドアセットの管理）にNode.jsが必要に
# なる場合がある。
# 特に、Rails 6ではWebpackerが標準で組み込まれているため、JavaScriptのパッケージ管理やビルドプロセスにNode.jsと
# npmが用いられる。
# ただし、完全にAPIのみを提供し、フロントエンドアセットを使用しない場合は、Node.jsとnpmは不要になることもある（詳細
# 不明）。
# ------------------------------------------------------------------------------------------------
# -y nodejs npm vim
# - `nodejs`、`npm`、`vim`パッケージをインストールする。
# - Docker コンテナ内の `vim` のインストール場所を確認するには、コンテナのシェルから `which vim` や
# `whereis vim` などのコマンドを実行する。

# ================================================================================================
# 1.1
# `RUN chmod +x /usr/bin/entrypoint.sh`は、Dockerイメージのビルドプロセス内で実行されるコマンドです。このコマ
# ンドの目的は、Dockerコンテナが起動されたときに実行されるスクリプトファイル `entrypoint.sh` に実行権限を付与する
# ことです。
# ------------------------------------------------------------------------------------------------
# `chmod +x` コマンドは、ファイルに実行権限を付与するために使用されます。この場合、`/usr/bin/entrypoint.sh` と
# いうパスにあるスクリプトファイルに対して実行権限が付与されます。
# ------------------------------------------------------------------------------------------------
# `entrypoint.sh` スクリプトは、通常、Dockerコンテナが起動された際に初期化や設定を行うために使用されるスクリプト
# です。例えば、データベースのセットアップ、環境変数の設定、アプリケーションの起動などのタスクを実行することがあります
# 。スクリプトが実行権限を持たない場合、コンテナ内でスクリプトを実行することができないため、このコマンドを使用して実行
# 権限を付与しています。
# ------------------------------------------------------------------------------------------------
# 通常、`ENTRYPOINT` または `CMD` によって指定されたコマンドは、このスクリプトが実行されることでコンテナ内のアプリ
# ケーションが起動されます。

# ================================================================================================
# 2
# ENTRYPOINT
# ENTRYPOINTはCMD同様、イメージからコンテナを作成する時（docker run時）に実行されるのですが、
# ENTRYPOINTはdocker runの引数のcommandに上書きされません。
# ENTRYPOINTはCMDと組み合わせて使います。
# ENTRYPOINTとCMDが両方書かれているとき、書く順番によらず、ENTRYPOINTを実行するコマンドとして、CMD
# をそのコマンドのargumentとして、実行されます。
# ------------------------------------------------------------------------------------------------
# ENTRYPOINTは、コンテナを実行ファイル(executable)として処理するように設定できます。
# exec形式を公式で推奨。shell形式では、CMDやrunコマンドラインの引数を使えません。
# ENTRYPOINTのexec形式は、確実に実行するデフォルトのコマンドと引数を設定するために使います。
# 複数のコマンドが必要な場合は、シェルスクリプトから実行する
# ------------------------------------------------------------------------------------------------
# ["entrypoint.sh"]の最終行の[exec "$@"]より、CMD ["rails", "server", "-b", "0.0.0.0"]が
# 実行される。
# ------------------------------------------------------------------------------------------------
# コンテナが起動するプロセスに関連する各コードは以下のような順序で実行されます。

# 1. **railsのDockerfile**
# - `RUN`コマンドなどでイメージがビルドされる時に実行される。
# - `CMD ["rails", "server", "-b", "0.0.0.0"]`は、このイメージがコンテナとして起動する際のデフォルトのコマン
# ドです。
# ------------------------------------------------------------------------------------------------
# 2. **entrypoint.sh**
# - コンテナが起動する際に、`ENTRYPOINT ["entrypoint.sh"]`が最初に実行されます。
# - `rm -f /api-app/tmp/pids/server.pid`というコマンドが含まれており、古い`server.pid`が削除されます。
# - `exec "$@"`は、このスクリプトが引数として受け取ったコマンド（例：`rails server`）を実行します。
# ------------------------------------------------------------------------------------------------
# 3. **docker-compose.prod.ymlの`command`**
# - `command: bash -c "rm -f tmp/pids/server.pid && rails s -p 3000 -b '0.0.0.0'"` は、
# `docker-compose up`が実行された際に、`api`サービスに対して実行されます。
# - この`command`は`Dockerfile`の`CMD`をオーバーライドします。
# - docker-compose runは特定のコマンドを実行し、docker-compose.ymlのcommandは無視される。
# docker-compose upはdocker-compose.ymlのcommandを実行する。
# ------------------------------------------------------------------------------------------------
# 根拠:
# - Dockerfileの`CMD`はデフォルトのコマンドですが、docker-compose upや`docker run`で指定された`command`によっ
# てオーバーライドされます。
# - `ENTRYPOINT`はコンテナが起動する際に最初に実行される点で、一種のイニシャライザとして機能します。
# ------------------------------------------------------------------------------------------------
# 総合すると、起動の順番は以下の通りです。
# 1. `ENTRYPOINT ["entrypoint.sh"]` が実行され、古い`server.pid`が削除されます。
# 2. docker-composeの`command`が実行されます。このとき、新たに`rails s -p 3000 -b '0.0.0.0'`が呼び出されま
# す。
# ------------------------------------------------------------------------------------------------
### `docker-compose -f docker-compose.dev.yml run --rm api` コマンドを実行した場合の起動順序
# . **entrypoint.shの実行**:
# - コマンドが実行されると、まず`entrypoint.sh`が実行されます。これは`Dockerfile`で
# `ENTRYPOINT ["entrypoint.sh"]`として指定されているためです。
# - `entrypoint.sh`内の`rm -f /api-app/tmp/pids/server.pid`コマンドが実行され、古い`server.pid`ファイル
# が削除されます。
# . **指定されたコマンドの実行**:
# - `docker-compose run`コマンドは、`docker-compose.yml`ファイル内の`command`を無視し、代わりにコマンドライ
# ンで指定されたコマンドを実行します。
# - この場合、`docker-compose -f docker-compose.dev.yml run --rm api`には追加のコマンドが指定されていない
# ため、`Dockerfile`内の`CMD ["rails", "server", "-b", "0.0.0.0"]`が実行されます。

# ------------------------------------------------------------------------------------------------
### docker-compose -f docker-compose.dev.yml run --rm api rails db:seedを実行したとき
# 1. `entrypoint.sh` が実行される。この中で `/api-app/tmp/pids/server.pid` が削除される。
# 2. コマンドラインで指定した `rails db:seed` が実行される。
# 3. `command: bash -c "rm -f tmp/pids/server.pid && rails s -p 3000 -b '0.0.0.0'"` は実行されない。
# `docker-compose run`で特定のコマンドを指定した場合、そのコマンドが実行されるので、`docker-compose.yml`の
# `command`は無視される。
# ------------------------------------------------------------------------------------------------
### docker-compose -f docker-compose.dev.yml upを実行したとき
# 1. `entrypoint.sh` が実行される。この中で `/api-app/tmp/pids/server.pid` が削除される。
# 2. `command: bash -c "rm -f tmp/pids/server.pid && rails s -p 3000 -b '0.0.0.0'"` が実行される。
# 3. `CMD ["rails", "server", "-b", "0.0.0.0"]` は**実行されない**。
# 根拠：`docker-compose up`を使ってコンテナを起動すると、`docker-compose.yml`に記載された`command`が、
# `Dockerfile`の`CMD`より優先されて実行されます。

# ================================================================================================
# 3
# bindオプションで0.0.0.0を指定。0.0.0.0は全てのアドレスという意味。由まり、どのIP Addressからも
# railsサーバーに接続可能という意味。
# Dockerコンテナ内でRailsアプリケーションを実行する場合、このオプションを使うことで、コンテナ外からのリクエスト（例
# えばホストマシンや他のコンテナからのリクエスト）を受け入れることができます。
# デフォルトでは、Railsサーバーはlocalhost（127.0.0.1）でのみリスニングするため、コンテナ外からはアクセスできませ
# ん。0.0.0.0を使用することで、これを外部アクセス可能にすることができます。
# ------------------------------------------------------------------------------------------------
# CMD
# CMDは完成したイメージからコンテナを作成するときに実行されます。つまりdocker runの時に実行されます。
# 1つのDockerfileにつき1つのCMDが呼び出され、複数書いてあったとしても最後に書かれたものが実行されま
# す。ただし、docker runの引数としてcommandが指定されていた場合、これが最後のコマンドと捉えられ、こ
# れに上書きされてしまいます。
# ------------------------------------------------------------------------------------------------
# ↓pumaでUNIXドメインソケット通信する為、ポート指定は不要になる。
# CMD ["rails", "server"]
# ------------------------------------------------------------------------------------------------
# コンテナでメインとして実行するプロセスは、 Dockerfileの最後に書かれているENTRYPOINTかCMD か、あるいは両方によっ
# て指定します。
# ------------------------------------------------------------------------------------------------
# なぜCMDと`docker-compose.prod.yml` の`command`を両方書くのか？
# - `CMD`: これはデフォルトのコマンドを設定。このCMDをDockerfile に記述することで、`docker run` などで明示的な
# コマンド（`docker-compose run rails db:create`など）が指定されない限り、このCMDが実行される。
# - `docker-composeのcommand`: docker-compose の設定で、`CMD` を上書きする役割を果たします。
### なぜ両方設定するか
# - 柔軟性：`docker-compose.prod.yml` の `command` は、開発環境で必要なコマンド（たとえば
#  `rm -f tmp/pids/server.pid` のような）ができる。一方、Dockerfile の `CMD` はより一般的な使用ケースで使わ
# れる。
# - 冗長性：どちらかが削除または変更された場合、もう一方がデフォルトのコマンドとして機能する。
# - 明確な区分：`Dockerfile` はイメージ作成に関する設定、`docker-compose.yml` はコンテナ起動に関する設定という
# ように、責任範囲が分かれている。
# このように、それぞれ異なる目的や状況で使われるため、両方を設定している場合も多いです。

# ================================================================================================
# 4
# EXPOSE 3000
# コンテナがホスト(ローカルPC)に対してリッスンするport番号を3000に設定する。
# ここで設定しなくても、コンテナ立ち上げ時に-p 3010:3000のようにすれば、ポート接続出来る
# pumaでUNIXドメインソケット通信する為、ポート指定は不要に。