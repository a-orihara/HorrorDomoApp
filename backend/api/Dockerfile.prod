# 1 ベースとなるイメージの指定（rubyのバージョン安定版（22/10現在）3.1.2を指定）
FROM ruby:3.1.2
# 1.1
ENV LANG C.UTF-8
# 2
ENV TZ Asia/Tokyo
# 3
ENV RAILS_ENV=production
# 作業ディレクトリはその後のDockerfile内でのRUN,COPYなどのあらゆる命令の起点となるカレントディレクトリ。
WORKDIR /api-app
#COPY(コピー)はローカル側のファイルをdockerイメージ側の指定したディレクトリにコピーする
COPY Gemfile /api-app/Gemfile
COPY Gemfile.lock /api-app/Gemfile.lock
# 4
RUN gem update --system
# 5
RUN bundle update --bundler
# Gemfileに記載されたGem(初回時はrailsが記載)をインストールする。再ビルド時にbundle installするために記載。
RUN bundle install
# localのコードをimageの中に含ませる
COPY . /api-app
# 6
RUN mkdir -p /api-app/tmp/sockets
# 7
RUN mkdir -p /api-app/tmp/pids
# 8
VOLUME /api-app/public
# 9
VOLUME /api-app/tmp
# 10 コンテナ起動時に毎回実行されるスクリプトを追加する。/usr/bin/はコンテナのLinuxベースのディレクトリ。
COPY entrypoint.prod.sh /usr/bin/
# 11 entrypoint.shの権限(+x:すべてのユーザーに実行権限を追加)を変更
RUN chmod +x /usr/bin/entrypoint.prod.sh
# 2 ENTRYPOINTはdocker runの時に実行される
ENTRYPOINT ["entrypoint.prod.sh"]
EXPOSE 3000

# @          @         @@          @@          @@          @@          @@          @@          @@
# 1
# - Dockerfileにimageに名前を付けるディレクティブはない
# DockerfileにDockerイメージ名を指定するためのディレクティブは特に必要ありません。イメージ名はDockerfile内で設
# 定するものではなく、ビルドプロセスを通して外部から設定するものです。
# ------------------------------------------------------------------------------------------------
# - 例えば、`Dockerfile.prod`のあるディレクトリに移動し、以下のコマンドを実行してください：
#   bash
#   docker build -t rails-img-prod -f backend/api/Dockerfile.prod .
# - ここで、`-t`は名前と、オプションでタグを'name:tag'の形式で設定します。この場合、画像は `rails-img-prod` と
# いう名前になる。
# - f` フラグは Dockerfile の名前とパスを指定する。複数のDockerfileがある場合に便利である。
# - 末尾の `.` はビルドコンテキストを指定する。

# 1.1
# - ENV LANG C.UTF-8` はシステム言語とロケールを UTF-8 に設定します。
# - システム全体の文字エンコードをUTF-8に標準化することです。これは、さまざまな文字セットに遭遇する可能性のある国
# 際化されたアプリケーションを扱うときに特に重要になる。

# ================================================================================================
# 2
# - ENV TZ Asia/Tokyo` はシステムのタイムゾーンをアジア/東京に設定します。
# - タイムゾーンは、システムが時間ベースの操作をどのように処理するかを制御するために設定されます。本番環境では、既知
# のタイムゾーンを持つことは、タスクのスケジューリングやログの記録な どの時間ベースの機能にとって有益である。

# ================================================================================================
# 3
# - ENV RAILS_ENV=production` はRailsの環境変数を "production "に設定します。
# - 本番モードでアプリケーションを実行するようにRailsに指示します。

# ================================================================================================
# 4
# - RUN gem update --system` コマンドは、RubyGems システムソフトウェアを互換性のある最新バージョンにアップデー
# トします。RubyGems は Ruby のパッケージマネージャであり、Ruby ライブラリ (gems) をインストール、削除、管理する
# ことができます。
# - RubyGems システムをアップデートすることで、最新の機能、パフォーマンス改善、セキュリティパッチを確実に使用できる
# ようになります。gemsやRubyGems自体の古いバージョンや互換性のないバージョンから発生する可能性のある問題を回避する
# ことができます。これは、本番イメージを構築する場合に、環境を可能な限り最新かつセキュアにしたい場合に役立ちます。

# ================================================================================================
# 5
# - RUN bundle update --bundler` コマンドは Bundler gem を互換性のある最新バージョンにアップデートします。
# Bundler は Ruby の依存関係マネージャで、プロジェクトの gem を管理するのに役立ちます。
# このコマンドはBundler gemのみを更新し、`Gemfile`で指定した他のgemは更新しません。
# - 目的は、Bundlerの最新バージョンを確実に使用することです。これはBundlerの最新機能、バグフィックス、パフォーマン
# ス向上の恩恵を受けるために非常に重要です。

# ================================================================================================
# 6
#  - ソケットディレクトリ**： api-app/tmp/sockets`ディレクトリは、プロセス間通信を促進するUnixソケットファイル
# を格納するために一般的に使用されます。Pumaによって提供され、NginxによってリバースプロキシされるRailsアプリケーシ
# ョンのコンテキストでは、このディレクトリはPumaとNginxが通信するUnixソケットを格納するために使用されます。
# ------------------------------------------------------------------------------------------------
# - プロセス間通信**： Nginx と Puma の両方を実行している場合、Unix ソケットを使用することで、ネットワークスタッ
# クを介さずにこれらのプロセス間で効率的なデータ交換が可能になり、待ち時間が短縮されてパフォーマンスが向上します。

# ================================================================================================
# 7
# - Pidsディレクトリ**： /api-app/tmp/pids`ディレクトリはPID（プロセスID）ファイルを格納するために使用される。
# これらのファイルにはPumaサーバーのプロセスのプロセスIDが含まれており、管理や監視に役立ちます。
# ------------------------------------------------------------------------------------------------
# - プロセス管理**： /api-app/tmp/pids`にあるPIDファイルはサーバプロセスの管理に役立ち、プロセスの停止、再起動、
# ステータスの確認が容易になります。

# ================================================================================================
# 8
# - Dockerfileの`VOLUME`ディレクティブは、コンテナ内の特定のディレクトリをボリュームのマウントポイントとしてみな
# すように指定するために使用します。ボリュームは、以下のいずれかのデータを保存するために使用されます：
# .複数のコンテナ間で共有される。
# .コンテナがクラッシュまたは停止しても永続する。
# ------------------------------------------------------------------------------------------------
# - api-app/public`**の目的： このボリュームは、アプリケーションが提供する静的ファイルを格納するために使用される。
# このボリュームを作成することで、コンテナの複数のインスタンス間でファイルを永続的に共有できるようになる。

# ================================================================================================
# 9
# - /api-app/tmp`***の目的： このボリュームは、キャッシュファイルやPIDファイルのような一時ファイルを格納するため
# のものである。これをボリュームとして定義することで、コンテナが停止、強制終了、または削除された場合でも、これらのファ
# イルが永続することを保証する。これは、デバッグや操作の迅速な再開に役立ちます。

# ================================================================================================
# 10
# - `entrypoint.prod.sh` スクリプトを Docker イメージの `/usr/bin/` ディレクトリにコピーします。このエントリ
# ーポイントスクリプトを `/usr/bin/` に移動して実行可能にする目的は、Dockerコンテナの起動時に実行できるようにする
# ためです。ENTRYPOINT`は、`entrypoint.prod.sh` がコンテナ起動時に Docker が実行するスクリプトになるように指
# 定します。

# ================================================================================================
# 11
#  - chmod`： このコマンドはファイルのパーミッションを変更する。
# - `+x`: このフラグは指定されたファイルに実行権限を追加する。
# ------------------------------------------------------------------------------------------------
# - **RUN chmod +x /usr/bin/entrypoint.prod.sh`** の目的： このコマンドは `entrypoint.prod.sh` スクリプ
# トの "execute" パーミッションを設定します。+x` フラグはファイルを実行可能にします。
# ------------------------------------------------------------------------------------------------
# - chmod +x /usr/bin/entrypoint.prod.sh` コマンドがないと、`entrypoint.prod.sh` スクリプトファイルには実
# 行権限がありません。スクリプトはDockerコンテナ内で実行できません。
# entrypoint.prod.sh`スクリプトは、データベースのセットアップやPuma Webサーバーの起動など、Railsアプリケーショ
# ンに不可欠な初期化ステップを実行するようです。実行権限がないと、アプリケーションの起動に失敗する可能性があります。
# ------------------------------------------------------------------------------------------------
# - Dockerコンテキストにおける必要性**： Dockerのコンテキストでは、エントリポイントスクリプトはコンテナを実行する
# ときに実行されるデフォルトのコマンドとして機能する。このスクリプトが実行可能でない場合、コンテナの起動に失敗し、パー
# ミッションエラーが表示されます。

# ================================================================================================
# 再ビルドのコマンド
# docker build --no-cache -t rails-img-prod -f backend/api/Dockerfile.prod ./backend/api/
