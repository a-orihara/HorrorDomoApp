class Api::V1::PostsController < ApplicationController
  # 1
  before_action :authenticate_api_v1_user!
  before_action :correct_user, only: :destroy

  # 2 指定useridの投稿pagenationか、currentuserの投稿総数を返す
  def index
    # 3
    page = params[:page] || 1
    per_page = params[:per_page] || 10

    if params[:user_id]
      # 6
      user = User.find_by(id: params[:user_id])
      # 送られたidでuserが入れば、
      if user
        # 指定したページの1ページ当たりの表示件数分（user.postsで一覧）のpostを取得
        posts = user.posts.page(page).per(per_page)
        total_posts = user.posts.count
        posts_with_likes_info = posts.map do |post|
          # liked:サインインユーザーがいいねしたかの真偽値
          liked = current_api_v1_user.already_liked?(post)
          # そのpostのlikes数を取得
          likes_count = post.likes.count
          # 6.1 post一件をjson化して下記をさらにマージ
          post.as_json.merge(liked: liked, likes_count: likes_count)
        end
        render json: { status: '200', data: posts_with_likes_info, total_posts: total_posts }, status: :ok
      # userがnilの場合
      else
        render json: { status: '404', message: 'User not found' }, status: :not_found
      end
    else
      # 4
      total_posts = current_api_v1_user.posts.count
      render json: { status: '200', total_posts: total_posts }, status: :ok
    end
  end

  # 11
  def show
    post = Post.find_by(id: params[:id])
    if post
      render json: { status: '200', data: post }
    else
      render json: { status: '404', message: '投稿が見つかりません' }, status: :not_found
    end
  end

  # 7
  def create
    # Rails.loggerの省略形
    logger.info "Postのcreateアクションが発火"
    # 7
    @post = current_api_v1_user.posts.build(post_params)
    if @post.save
      # 8
      render json: { status: '201', message: '投稿しました', data: @post }, status: :created
    else
      # 9 フロントでerr.response.data.message、err.response.data.errorsのようにアクセス
      render json: { status: '422', message: '投稿に失敗しました', errors: @post.errors.full_messages.join(', ') }, status: :unprocessable_entity
    end
  end

  def destroy
    if @post.destroy
    render json: { status: '200', message: '投稿を削除しました', data: @post }, status: :ok
    else
    # render json: { error: '削除に失敗しました' }, status: :unprocessable_entity
    # correct_userのエラーメッセージに合わせるため、
    render json: { status: '422', message: '削除に失敗しました', errors: @post.errors.full_messages.join(', ') }, status: :unprocessable_entity
    end
  end

  # 9.1
  def search
    page = params[:page] || 1
    per_page = params[:per_page] || 10
    query = params[:query]
    # 9.2 部分一致するレコードを取得
    posts = Post.where("title LIKE ?", "%#{query}%").page(page).per(per_page)
    # 部分一致するレコード総数を取得
    total_posts_count = Post.where("title LIKE ?", "%#{query}%").count
    # 部分一致するレコードにlike情報を付与
    posts_with_likes_info = posts.map do |post|
          # 12 likedは真偽値
          liked = current_api_v1_user.already_liked?(post)
          # そのpostのlikes数を取得
          likes_count = post.likes.count
          # 部分一致するレコードをjson化し、like情報を付与
          post.as_json.merge(liked: liked, likes_count: likes_count)
    end
    # 9.3
    user_ids = posts.map(&:user_id).uniq
    users = User.where(id: user_ids)
    # users情報にavatr情報を付加してjson形式に
    users_with_avatar = users.map do |user|
          avatar_url = generate_avatar_url(user)
          user.as_json.merge(avatar_url: avatar_url)
    end
    # 検索結果のpostとその総数、そのpostに紐づくuserを返す
    render json: { status: '200', posts: posts_with_likes_info, total_posts_count: total_posts_count, users: users_with_avatar }, status: :ok
  end

  private

    # 10
    def post_params
      params.require(:post).permit(:content, :title)
    end

    # 13 「現在のユーザーが操作しようとしている投稿が自分のものであるか（つまり、削除操作が許可されているか）」を確認
    def correct_user
      @post = current_api_v1_user.posts.find_by(id: params[:id])
      # ↓ rubocopにより、下記を1行に修正
      # if @post.nil?
      #   render json: { status: '404', message: '自分の投稿のみ削除できます', errors: '自分の投稿のみ削除できます' }, status: :not_found
      # end
      render json: { status: '404', message: '自分の投稿のみ削除できます', errors: '自分の投稿のみ削除できます' }, status: :not_found if @post.nil?
    end
end

=begin
@          @@          @@          @@          @@          @@          @@          @@          @
1
authenticate_api_v1_user!
Devise Token Authによって提供されるメソッドで、APIリクエストが認証済みのユーザーから来ているかどうかを確認しま
す。それ以外の確認は行いません。
認証を確認すると、それはリクエストが認証済みのユーザーから来ていることを意味しますが、そのユーザーが自分のpostを操
作しようとしているユーザー自身であることを直接確認するわけではありません。ただし、authenticate_api_v1_user!に
より認証が確認された後に、そのユーザーの情報に基づいて特定の操作を制限したり制御したりすることが可能です。
しかし、このメソッドが行うのは「認証」であり、「認可」ではありません。つまり、ユーザーがログインしていることは確認で
きますが、そのユーザーが特定のリソース（ここではpost）に対して何を行って良いのか、というアクセス権限の管理はこれら
のメソッドの範囲外です。

================================================================================================
2
送信apiからparams[:user_id]があれば、そのid指定userのページネーション用の投稿一覧（いいねの真偽値付き）を取得。
なければcurrentUserの投稿総数を返す。
------------------------------------------------------------------------------------------------
/posts?user_id=${userId}で、rails側のpostコントローラーのindexアクション内の、if params[:user_id]が反応
する仕組みは、HTTPリクエストが送られるときに、URLに含まれるクエリパラメータがRailsのparamsハッシュに自動的に追加
されるためです。
つまり、user_id=${userId}というクエリパラメータがURLに含まれていると、params[:user_id]でその値を取得すること
ができます。
------------------------------------------------------------------------------------------------
paramsオブジェクトの仕組みは以下の通りです：
paramsは、コントローラへ送られたリクエスト情報を含むハッシュのようなオブジェクトです。
paramsには、URLのパスパラメータ、クエリパラメータ、POSTリクエストの本文など、リクエストに関連するさまざまな情報が
含まれます。
例えば、/users?name=Johnというリクエストがあった場合、params[:name]は"John"という値を返します。
また、/users/1というリクエストがあった場合、params[:id]は"1"という値を返します。
------------------------------------------------------------------------------------------------
1. URLのパスパラメータとクエリパラメータの違いは次の通りです:

- パスパラメータ:
パスパラメータは、URLのパスの一部として渡されるパラメータです。
例えば、`/users/:id`のようなURLパターンでは、`:id`がパスパラメータです。
パスパラメータは、特定のリソース（ここではユーザー）を識別するために使用されます。
パスパラメータは、Railsのルーティングで定義され、コントローラー内で`params[:id]`のようにアクセスされます。

- クエリパラメータ:
クエリパラメータは、URLの末尾に`?`を付けてキーと値のペアで指定されるパラメータです。
例えば、`/users?name=John`のようなURLでは、`name=John`がクエリパラメータです。
クエリパラメータは、特定のリクエストに関連する追加の情報を提供するために使用されます。
クエリパラメータは、Railsのコントローラー内で`params[:name]`のようにアクセスされます。

================================================================================================
3
if params[:user_id]
この条件は、リクエストのパラメーターにuser_idが含まれているかどうかをチェックしています。
もしuser_id（一般的な利用としては、他ユーザーのID）が含まれていれば、指定されたuser_idに紐づくユーザーの投稿一覧
を取得します。
もしuser_idが含まれていない場合は、次のelse節の処理に進みます。

================================================================================================
4
current_api_v1_user
Devise Token Auth gem が提供するヘルパーメソッドです。このメソッドは現在の認証済みユーザーを返します。
そのため、そのユーザーの属性や関連するオブジェクト（例えば、そのユーザーが持つpostsなど）にアクセスすることができま
す。
current_api_v1_userメソッドは認証済みのユーザーを返すため、そのユーザーが操作しようとしているpostが自分自身のも
のかどうかを確認するために使用することができます。
------------------------------------------------------------------------------------------------
これはDevise Token Auth gem で定義されています。ApplicationController` は `current_api_v1_user` メソッ
ドを提供する `DeviseTokenAuth::Concerns::SetUserByToken` モジュールを含んでいるので、コントローラで使用する
ことができます。
これを使う意図は、リクエストのコンテキストで現在認証されているユーザーにアクセスすることです。このメソッドを使用して
、認証済みユーザーに関連するアクションを実行したり、データにアクセスしたりすることができる。
------------------------------------------------------------------------------------------------
posts` は `User` モデルの `has_many :posts` 関連付けで `current_api_v1_user` に追加されます。
この関連付けにより、ユーザインスタンスで `posts` を呼び出して、そのユーザに関連付けられたすべてのマイクロポストに
アクセスすることができます。
参考：user.posts
User のマイクロポストの集合をかえす。
------------------------------------------------------------------------------------------------
エラー処理を書かない理由
authenticate_api_v1_user!で認証済み確認。
current_api_v1_userで、現在の認証済みでサインインユーザーに関する情報を取得。
この二つにより、ユーザが自分の投稿にしかアクセスできない状態を実現している。
このチェックは、authenticate_api_v1_user!とcurrent_api_v1_userにより自動的に行われる。
そして、認証関連のエラー処理は、authenticate_api_v1_user!とcurrent_api_v1_userで自動的に行われるため。

================================================================================================
5
render json: @postsから、render json: { data: @posts }へ変更
------------------------------------------------------------------------------------------------
1.
`render json: @posts`とすると、フロントエンド側で取得したデータが直接配列やオブジェクトとして扱われます。これは一
見シンプルに見えますが、APIから返されるデータ形式が変わると、全てのフロントエンドのコードが影響を受ける可能性があり
ます。
2.
`render json: { data: @posts }`とすると、`data`というキーで実際のデータを包む形式になります。このようにするこ
とで、他のメタ情報（全件数、ページング情報など）を一緒に送る場合や、エラーメッセージを返す場合にも対応が容易になりま
す。
Next.jsや他のフロントエンドフレームワークを利用する場合、APIのレスポンス形式が一貫していると、データの取り扱いが容
易になります。また、必要に応じてメタ情報を追加したり、エラー処理を統一的に行うことができます。したがって、ここでは、
`render json: { data: @posts }`の方が適切と言えます。
------------------------------------------------------------------------------------------------
render json: @posts
戻り値はdataをキーに持つオブジェクトが返る。
そのオブジェクトの値は、配列で、その配列の値はオブジェクト。
# { date:[{},{},{}] }
------------------------------------------------------------------------------------------------
render json: { data: @posts }
最外部のdataキーの値はdataをキーに持つオブジェクト。
その内側のdataキーの値は投稿データを表現するオブジェクトの配列。
各オブジェクトはそれぞれの投稿が持つ属性（id, content等）を表現しています。
# { date:{ data:[{},{},{}] } } /（dataキーの値は、オブジェクトの配列というオブジェクトが返る。

================================================================================================
6
find_byはfindでも可能ですが、違いがあります。findメソッドは主キー（通常はid）を基にレコードを検索し、該当するレ
コードがない場合はActiveRecord::RecordNotFoundエラーを発生させます。一方、find_byメソッドは指定した条件にマッ
チする最初のレコードを返し、該当するレコードがない場合はnilを返します。つまり、find_byを使用すると、該当するレコー
ドがない場合にアプリケーションがエラーで止まらずに、その後の処理を進めることができます。

================================================================================================
6.1
post.as_json.merge(liked: liked, likes_count: likes_count)
`Post`モデルのインスタンスをJSON形式に変換し、そのデータに追加情報を統合しています。
- `post.as_json`: この部分は`Post`インスタンス（`post`）をJSON形式に変換します。これにより、`Post`モデルの
属性がキーと値のペアとして含まれたハッシュマップ（または辞書型のデータ構造）になります。例えば、`title`、`body`、
`created_at`などの属性が含まれます。
- `.merge(liked: liked, likes_count: likes_count)`: この部分は、上記のJSON表現に新しいデータを統合します
。`merge`メソッドは、元のハッシュに新しいキーと値のペアを加えます。
- `liked: liked`：これは、現在のユーザーがその投稿を「いいね」しているかどうかのブール値（`true`または`false`）
を表します。
- `likes_count: likes_count`：これは、その投稿に対する「いいね」の総数を表す整数です。
結果として、このコードは投稿の基本情報に加えて、「いいね」されているかどうかの状態とその総数を含むJSONオブジェクト
を生成します。

================================================================================================
7
current_api_v1_user
DeviseTokenAuthが提供しており、ヘッダー情報に含まれる認証トークンを使用して、認証済みのユーザーを検索します。
そして現在の認証済みのユーザーを取得します。
------------------------------------------------------------------------------------------------
posts
現在のユーザーが持っている投稿を取得するためのメソッドです。
has_many :postsのアソシエーションによってUserモデルはpostsメソッドを使えるようになります。これにより、特定のユ
ーザーに関連する投稿を簡単に取得できます。
post.ではダメです。なぜなら、has_many :postsのアソシエーションによりUserモデルは複数の投稿を持つことができ、
postsメソッドを通じてこれらの投稿にアクセスすることができるからです。postではなくpostsを使用することで、ユーザー
に関連するすべての投稿にアクセスできます。
------------------------------------------------------------------------------------------------
build(post_params)関数は、新しいPostオブジェクトをメモリ上に作成しますが、まだデータベースに保存はしません。
引数post_paramsは、新しいPostオブジェクトを作成するためのパラメータです。post_paramsメソッドによって、パラメー
タから必要な属性(:content)だけを抽出しています。
buildはcreateでも可能ですが、違いがあります。buildは新しいオブジェクトをメモリ上に作成しますが、データベースには
保存しません。一方、createは新しいオブジェクトを作成し、それをデータベースにすぐに保存します。なので、作成後に何ら
かの処理を行いたい場合や、保存前にバリデーションを行いたい場合などはbuildを使用します。

# -backend/api/app/controllers/api/v1/posts_controller.rb
def create
  @post = current_api_v1_user.posts.build(post_params)
  if @post.save
    render json: { status: '201', message: 'Post created', data: @post }, status: :created
  else
    render json: { status: '422', message: 'Post not created', errors: @post.errors }, status: :unprocessable_entity
  end
end

================================================================================================
8
'201'はHTTPステータスコードで、「リソースが正常に作成された」という意味です。'200'は「リクエストが成功した」とい
う一般的な成功を示すコードで、リソースが新規作成された場合には'201'を使用するのが一般的です。
------------------------------------------------------------------------------------------------
:createdはRailsで使用されるシンボルで、HTTPステータスコードの'201'を表します。このステータスコードは、リクエス
トが成功し、新たにリソースが作成されたことを意味します。
------------------------------------------------------------------------------------------------
render json: { status: '201', message: 'Post created', data: @post }, status: :createdというコード
におけるstatusの重複は、異なる目的のために存在します。
内側のstatus: '201'はJSONレスポンスボディの一部で、フロントエンドがこのステータスを見てリクエストの結果を理解し
ます。一方、外側のstatus: :createdはHTTPステータスコードを設定し、これはHTTPレスポンスヘッダーの一部として送信
されます。
フロントエンドはこのステータスコードを見てリクエストが成功したかどうかを瞬時に判断します。
------------------------------------------------------------------------------------------------
JSON レスポンス内の `status` キー (`{ status: '200', message: 'Post created', data: @post }`) は、
フロントエンドアプリケーションのためのものです。このステータスは、JavaScript/TypeScript コードで直接使用するこ
とができ、次に何をすべきかを決定することができます (例えば、エラー処理、リダイレクトなど)。

レスポンスの HTTP ステータスコードを設定するために、Rails は `render json: {...}, status: :created` のよ
うに JSON レスポンスの外側に `status: :created` を指定します。これはHTTPレスポンスヘッダの一部として送信され
るステータスコードです。

HTTPステータスコードは、リクエストの成功、失敗、その他の状態に関する情報を提供する標準化されたコードです。これらの
ステータスコードは、ウェブブラウザを含むすべてのHTTPクライアントによって理解され、リクエストの低レベル処理に使用さ
れます。冗長に見えますが、これらはそれぞれ異なる役割を担っています。
------------------------------------------------------------------------------------------------
1.HTTPステータスコードとJSONレスポンスボディ内のステータスコードの2つを設定する利点について詳しく説明します：

**HTTPステータスコード**
HTTPレスポンスのステータスラインに表示されるステータスコードです。これにより、フロントエンドはリクエストが成功した
か、それとも何かエラーが発生したかを瞬時に知ることができます。これは一般的なプロトコルレベルの通信であり、ブラウザ
や他のHTTPクライアントがリクエストの成功または失敗を自動的に判断できるようになっています。

**JSONレスポンスボディ内のステータス**
これはアプリケーションレベルの通信で、フロントエンドが具体的なアクション（例えば、新規作成、更新、削除など）が成功
したかどうか、または特定のビジネスロジックが満たされたかどうかを理解するために使用します。これにより、フロントエン
ドは更に詳細なエラーメッセージをユーザーに表示したり、特定のアクションをトリガーすることが可能になります。
リクエストが成功したかどうかをフロントエンドが瞬時に判断できる利点は、ユーザーエクスペリエンスの向上につながります。
具体的には、HTTPステータスコードを用いることで、フロントエンドはリクエストの結果を迅速に判断し、必要ならエラーメッ
セージを即座に表示したり、成功した操作に基づいてUIを更新したりすることができます。その結果、アプリケーションのレス
ポンスが速くなり、ユーザーにとって使いやすいアプリケーションとなります。

================================================================================================
9
フィールド名はデータベーステーブルのカラム名を指します。例えば、Userモデルがある場合、'name'や'email'などがフィ
ールド名になります。
------------------------------------------------------------------------------------------------
モデルインスタンスとは@postのことです。モデルインスタンスとは特定のモデルから生成されたオブジェクトのことを指します
。@postはPostモデルから生成されたインスタンスです。
------------------------------------------------------------------------------------------------
モデルインスタンスはオブジェクトです。Rubyの世界では、全てのデータはオブジェクトとして扱われます。したがって、モデ
ルインスタンスもオブジェクトです。
------------------------------------------------------------------------------------------------
モデルインスタンスのオブジェクトの中にActiveModel::Errorsクラスのインスタンスが入っています。モデルインスタンス
（@postなど）には、バリデーションの結果を格納するためのerrorsオブジェクトが含まれています。このerrorsオブジェク
トはActiveModel::Errorsクラスのインスタンスです。
------------------------------------------------------------------------------------------------
ActiveModel::Errorsは別にエラーになっていなくても初めからインスタンスに存在しています。モデルインスタンスが生成
された時点で、ActiveModel::Errorsクラスのインスタンスとしてのerrorsオブジェクトも一緒に作成されます。しかし、
その時点ではエラーメッセージはまだ格納されていません。バリデーションが実行され、エラーが発生した場合に初めてエラーメ
ッセージがerrorsオブジェクトに格納されます。
------------------------------------------------------------------------------------------------
@post.errors.full_messages.join(', ')が「contentを入力してください」を表示する理由
full_messagesメソッドは、@post.errors内の全てのエラーメッセージを配列として返します。
@messages={name:["を入力してください"]}のように、フィールド名とエラーメッセージがハッシュの形で格納されています。

*参考
user.errors.messages
{
  :first_name=>["First Name is required."],
  :contact_number=>["Contact number is not a number."]
}
user.errors.full_messages
[
  "First name is required.",
  "Contact number is not a number."
]

そしてそれぞれのエラーメッセージは、対応するフィールド名とメッセージ本文を結合した形式になります。例えば、"content
を入力してください"のように。
join(', ')メソッドで、全てのエラーメッセージをカンマ区切りの1つの文字列にしています。
------------------------------------------------------------------------------------------------
`@post.errors.full_messages.join(', ')`について詳しく説明します。

. `@post.errors`はモデルのインスタンスである@postに対するバリデーションエラー情報を格納する
ActiveModel::Errorsクラスのインスタンスです。バリデーションが通らなかった場合、対応するフィールド名とエラーメッ
セージが格納されます。
Postモデルにはcontentというフィールドが存在し、presence: trueというバリデーションが設定されているとします。つま
り、contentフィールドは空ではないという条件を満たさなければならないということです。
ユーザーが何も入力せずに投稿をしようとしたとき、contentフィールドは空になります。そのため、バリデーションが通らず、
@post.errorsにはcontentフィールドに関するエラーメッセージが格納されます。
@post.errors[:content]
これは"を入力してください"というメッセージを返します。

. `full_messages`メソッドは、`@post.errors`に格納された全てのエラーメッセージをフィールド名とメッセージ本文を
結合した形式の配列として返します。
上記の状況で、full_messagesメソッドを呼び出すと、エラーメッセージは"contentを入力してください"という形式で配列と
して返されます。具体的には次のようになります。
@post.errors.full_messages
これは["contentを入力してください"]という配列の値を返します。この配列の中には、contentフィールドに対するエラーメ
ッセージの他、他のフィールドに関するエラーメッセージも存在すれば、それらもこの配列に含まれます。

. `join(', ')`メソッドは配列の要素を引数で与えた文字列（この場合は`, `）で連結して一つの文字列にします。これに
より、複数のエラーメッセージがあった場合でも一つの文字列として表示することができます。
join(', ')メソッドの具体例
["contentを入力してください", "titleが長すぎます"].join(', ')
このコードは "contentを入力してください, titleが長すぎます"という一つの文字列を返します。
contentのエラーが一つの場合でも、join(', ')メソッドは有用です。なぜなら、エラーメッセージは通常配列で返されるた
め、それを一つの文字列に変換する必要があるからです。エラーメッセージが一つしかなくても、そのメッセージは配列内にあり
ます。
複数エラーがある場合の@post.errors.full_messagesの具体例：
モデルにcontentとtitleの2つのフィールドが存在し、それぞれにバリデーションが設定されているとします。ユーザーが無効
な入力を行い、両方のフィールドでバリデーションエラーが発生した場合、@post.errors.full_messagesは以下のようにな
ります。
@post.errors.full_messages
これは ["contentを入力してください", "titleが長すぎます"]という配列を返します。
そして、これらのメッセージをjoin(', ')メソッドで繋げた場合の戻り値は次のようになります：
@post.errors.full_messages.join(', ')
これは "contentを入力してください, titleが長すぎます"という一つの文字列を返します。
------------------------------------------------------------------------------------------------
422はrailsでバリデーションエラーによりリクエストに従えない場合によく使われます。
'422'は、「リクエストの構文は適切に形成されているが、意味上のエラーや無効な操作のために処理できない」を意味します。
例えば、必要なパラメータが欠けている、またはパラメータの形式が無効等、処理できなかった場合に使われます。
------------------------------------------------------------------------------------------------
:unprocessable_entity（処理不能な実体）はRailsで使用されるシンボルで、HTTPステータスコードの'422'を表します。

================================================================================================
9.1
. `query = params[:query]`
- この行では、クライアントから送られてくる`query`パラメータ（検索文字列）を取得しています。
- 検索クエリとして使用するためのパラメータを取得します。

================================================================================================
9.2
. `posts = Post.where("title LIKE ?", "%#{query}%")`
- この行では、`Post` モデルから`title`カラムが検索クエリに部分一致するレコードを取得しています。
- 検索クエリにマッチする`Post` レコードをデータベースから探し出します。
------------------------------------------------------------------------------------------------
`.Post.whereのメソッドと引数`
- `Post.where` は、ActiveRecordの`where`メソッドを使用しています。このメソッドは、指定した条件にマッチするレ
コードをデータベースから取得します。
- `Post` モデルから特定の条件に一致するレコードを取得するために使用します。
------------------------------------------------------------------------------------------------
. `("title LIKE ?", "%#{query}%")の"title LIKE ?"
- `"title LIKE ?"`はSQLの`LIKE`演算子を使用しています。`LIKE`はSQLの演算子の一つで、文字列が特定のパターンと
一致するかどうかを判断します。`%`は任意の0文字以上の文字列に一致するワイルドカードです。
- これは部分一致検索を行う際に使用します。たとえば、`query`が`"test"`であれば、`"My test Post"`、`"test"`、
`"Another test"` などがマッチします。
------------------------------------------------------------------------------------------------
- `?`はプレースホルダであり、後の`"%#{query}%"`で置き換えられます。
------------------------------------------------------------------------------------------------
.`%#{query}%`
- `%#{query}%` という形式では、`%` はSQLのLIKE演算子で使用するワイルドカードです。ワイルドカード`%`が前後につ
いているため、`query`が含まれる任意の位置の文字列にマッチします。
- 例えば、`query` が "test" であれば、"This is a test"、"test example"、"another test case" など、
"test" を含むすべての `title` をマッチさせることができます。
------------------------------------------------------------------------------------------------
この`Post.where("title LIKE ?", "%#{query}%")`の全体的な利用意図は、`title`カラムに含まれるテキストがクラ
イアントから送信された検索クエリに部分一致する`Post`レコードをデータベースから取得することです。
------------------------------------------------------------------------------------------------
. `render json: { status: '200', data: posts }, status: :ok`
- この行では、検索結果をJSON形式でレスポンスとして返します。HTTPステータスコードは200（OK）です。
- クライアントに検索結果を返すため、適切な形式とステータスコードでレスポンスを生成します。

================================================================================================
9.3
`user_ids = posts.map(&:user_id).uniq`の解説:
- `&:`はRubyの省略記法で、特に`map`メソッドと組み合わせて使われることが多い。この記法はブロックを渡す代わりに、
オブジェクトのメソッドを直接呼び出すために使われる。`&:user_id`は`{ |post| post.user_id }`と同じ意味で、各
`post`オブジェクトに対して`user_id`メソッドを呼び出す。
- この式は、`posts`配列に含まれるすべての投稿（`Post`オブジェクト）から`user_id`属性を取り出し、それらを配列に
集める。その後、`uniq`メソッドを使用して、重複する`user_id`を削除し、ユニークな`user_id`のみを含む配列を作成す
る。
------------------------------------------------------------------------------------------------
全体として、このコードは特定の投稿のコレクション（`posts`）から、それらの投稿を作成したユーザーのIDの一覧を取得し
、その一覧をユニークな値のみに絞り込む処理を行っている。これは、例えば、投稿に関連するユーザー情報を効率的に取得する
ために使用される場合がある。

================================================================================================
10
. 通常、Railsのコントローラはリクエストパラメータとして、特定のリソース（この場合は 'post'）の名前のキーの下に、
そのリソースの属性を表すキー（この場合は 'content'）を持つハッシュを期待します。これはストロングパラメータという
機能の一部であり、意図しないデータがデータベースに保存されることを防ぐためのものです。
------------------------------------------------------------------------------------------------
. Railsのコントローラは、'params' メソッドを通じてクライアントから送られてきたデータにアクセスします。コントロ
ーラのアクション内で 'params[:post]' というコードを書いた場合、その値はクライアントが送信したデータ内の 'post'
キーに対応する値になります。
------------------------------------------------------------------------------------------------
. ストロングパラメータは、createやupdateなどのアクションで使用する属性をホワイトリストに追加することで、意図し
ない属性が更新されることを防ぎます。
------------------------------------------------------------------------------------------------
. したがって、フロントエンドから送信するリクエストデータは、Railsのストロングパラメータの要件を満たす形にする必
要があります。上記のコードでは、クライアントが送信するデータの形式を 'post' キーの下に 'content' キーが存在す
る形に修正することで、Railsのコントローラが期待するデータ形式を満たし、リクエストが成功するようになりました。

================================================================================================
11
# @post = Post.find(params[:id])
# render json: { status: 200, data: @post }
------------------------------------------------------------------------------------------------
ここでは、findメソッドの代わりにfind_byメソッドを使用しています。findメソッドは、該当するデータが見つからない場
合にはActiveRecord::RecordNotFoundエラーを発生させます。
一方、find_byメソッドは該当するデータが見つからない場合にはnilを返します。そのため、find_byメソッドを使用して該
当するデータがない場合に適切なレスポンスを返すことができます。

================================================================================================
12
devise では、認証情報に基づいて判断されたユーザーに関する便利なメソッドを提供しています。
current_user: サインインユーザーのuserレコードを取得する
このメソッドはコントローラーの中から呼び出すことができるのですが、devise_token_auth の仕様として、これらメソッド
がこの名前のまま利用できるのは、/controllersディレクトリ直下のコントローラーのみとなります。
今回コントローラーを実装していくディレクトリは/controllers/api/v1となりますので、この配下のコントローラーで上記
メソッドを使用するときは、以下のような書き方をしなくてはなりません。
current_api_v1_user

================================================================================================
13
post` が `nil` でない場合（つまり、投稿が存在し、現在のユーザが所有している場合）、 `correct_user` メソッドは
明示的に値を返しません。Rubyでは、明示的なreturn文がないということは、メソッドが最後に評価された式の値を返すことを
意味します。しかし、この場合、メソッドの役割はデータを返すことよりも、権限を与えることにあります。
postがあれば、メソッドは`destroy` アクションまでフローを継続させます。存在しない場合、メソッドはフローを停止して
エラーレスポンスを返します。
=end
