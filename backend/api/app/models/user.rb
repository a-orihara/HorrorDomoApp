# frozen_string_literal: true

# Rails 5.0 以降を使用している場合は、User < ActiveRecord::Baseから変更。
class User < ApplicationRecord
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  # deviseやincludeなどのマクロスタイルの呼び出しは先頭に配置
  devise :database_authenticatable, :registerable,
  # 19
         :recoverable, :rememberable, :validatable, :confirmable
  # 4
  include DeviseTokenAuth::Concerns::User

  # 3 has_one_attachedやhas_manyなどのアソシエーションはバリデーションの前に配置
  has_one_attached :avatar
  # 5 一人のuserは複数のpostを持つのでpostsと複数形にする
  has_many :posts, dependent: :destroy
  # 7 一人のuserは複数のuserをフォローをするのでactive_relationshipsと複数形にする
  has_many :active_relationships, class_name: "Relationship",
                                  # 7.1 `Relationship` モデル内で、どのフィールドが `User` モデルへの参照（フォローする側）を表すかを指定
                                  foreign_key: "follower_id",
                                  dependent: :destroy,
                                  # 8 `Relationship` オブジェクトが `User` オブジェクトを "follower"（フォローする側のユーザー）として参照することを意味
                                  inverse_of: :follower

  # 13
  has_many :passive_relationships, class_name: "Relationship",
                                   foreign_key: "followed_id",
                                   dependent: :destroy,
                                   #  13.1
                                   inverse_of: :followed
  # 9 引数の値にシンボルがあれば、rubyだとそれは慣習的にメソッドのこと。そのメソッドを呼び出す。
  has_many :following, through: :active_relationships, source: :followed
  # 14
  has_many :followers, through: :passive_relationships, source: :follower
  # Userが自分の「いいね」したリストを取得。いいねの集合。
  has_many :likes, dependent: :destroy
  # 16 Userが自分の「いいね」したPostのリストを取得する。Postの詳細情報を取得できる。
  has_many :liked_posts, through: :likes, source: :post

  # 1 ↓validates(:name, { presence: true, length: { maximum: 30 } })の省略形
  validates :name,  presence: true, length: { maximum: 30 }
  # 2
  validates :email, length: { maximum: 255 }
  # presence: trueがないので、プロフィールが空でもいい
  validates :profile, length: { maximum: 160 }
  # 6
  validates :avatar, content_type: { in: %w[image/jpeg image/gif image/png],
                                     message: :invalid_image_format },
                     size: { less_than: 5.megabytes,
                             message: :size_over }

  # ここ以下のメソッドは、privateにしていないので外部（コントローラー）から呼び出せる
  # 10 ユーザーをフォローする。followingはhas_manyで定義したメソッド
  def follow(other_user)
    # self.following << other_user
    following << other_user
  end

  # 11 ユーザーをフォロー解除する
  def unfollow(other_user)
    #  self.active_relationships.find_by(followed_id: other_user.id).destroy
     active_relationships.find_by(followed_id: other_user.id).destroy
  end

  # 12 現在のユーザーがフォローしてたら true を返す
  def following?(other_user)
    # self.following.include?(other_user)
    following.include?(other_user)
  end

  # 18 ユーザーがその投稿をいいね済みかどうかを返す
  def already_liked?(post)
    # ↓書換: self.likes.exists?(post_id: post.id)
    likes.exists?(post_id: post.id)
  end

  # 15 Feed（自ユーザーとフォローユーザーの投稿データ）を返す。戻り値はpostの配列
  def feed
    # following_ids:特定のUserがフォローしているユーザーのIDの集まり。SQL分を生成
    following_ids = "SELECT followed_id FROM relationships
                     WHERE follower_id = :user_id"
    Post.where("user_id IN (#{following_ids})
                     OR user_id = :user_id", user_id: id)
  end
end

=begin
@          @@          @@          @@          @@          @@          @@          @@          @
1
devise_token_auth は、デフォルトでは name 属性に対して presence: true や uniqueness: true のようなバリ
デーションは設定されていません。
emailに対しては、presence: trueやuniqueness: trueのバリデーションが初めから付いている。また、デフォルトで
email 属性にはフォーマットのバリデーションも設定されており、正しいメールアドレス形式であることが求められます。
下記は不要
.VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/
.validates :email, length: { maximum: 255 },  format: { with: VALID_EMAIL_REGEX }
*formatの部分
------------------------------------------------------------------------------------------------
validatesはActive Recordのメソッドです。
1つ以上の引数を取ることができます。一般的にはバリデーション対象の属性名をシンボルで指定し、その後にオプションのハ
ッシュを渡します。このオプションのハッシュには、バリデーションの種類やオプション、エラーメッセージなどを指定するこ
とができます。

validates(:email, { length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX } })
.バリデーション対象の属性名/:email
.オプションのハッシュ/{ length: { maximum: 255 }, format: { with: VALID_EMAIL_REGEX } }
------------------------------------------------------------------------------------------------
presence: true
空白スペースのみの文字列も空文字の文字列も無効。空文字列やnilではないことが要求されます。

================================================================================================
2
emailに対しては、presence: trueやuniqueness: trueのバリデーションが初めから付いている。また、デフォルトで
email 属性にはフォーマットのバリデーションも設定されており、正しいメールアドレス形式であることが求められます。
下記は不要
------------------------------------------------------------------------------------------------
format
フォーマットの制約を指定するオプションであり、この場合はemailが正規表現VALID_EMAIL_REGEXに一致することを指定し
ています。
指定できるのは正規表現（Regexpオブジェクト）のみです。
formatオプションの引数はハッシュであり、メソッドではありません。
------------------------------------------------------------------------------------------------
with
正規表現のパターンを指定するオプションであり、この場合はemailが正しいフォーマットであることを確認するために使用さ
れます。
------------------------------------------------------------------------------------------------
# 以前の内容。メールアドレスが小文字で統一されれば、大文字小文字を区別するマッチが問題なく動作できるから不要に。
# :case_sensitive:大文字小文字の違いを区別する。
uniqueness: { case_sensitive: false },
=大文字小文字の違いを区別しない。つまり小文字のメアドと同じ文字の大文字のメアドは、区別しないので、同じ文字と判断
され、登録されない。

================================================================================================
3
RailsのActive Storageは、アプリケーション内でファイルアップロードを簡単にするためのフレームワークです。
Active Storageを使うことで、簡単にファイルをアップロードし、クラウドストレージに保存することができます。また、
Active Storageは、画像リサイズやサムネイル生成などの機能も提供しています。
どのモデル（例えばUser）に紐付けられた画像もこの2つのテーブルを利用します。
------------------------------------------------------------------------------------------------
Userモデルでhas_one_attached :avatarと設定すると、実際には

has_one :avatar_attachment
has_one :avatar_blob, through: :avatar_attachment
のようなhas_one :through関連付けが行われます。
has_one_attachedに渡したavatarはAttachmentオブジェクトのname属性の値となります。
ActiveRecordによってUserオブジェクトがデータベース上のデータにマッピングされているように、Blobオブジェクトがロー
カルまたはクラウドストレージ上のファイルにマッピングされます。
------------------------------------------------------------------------------------------------
has_one_attached
Active Storageを使って、アップロードされたファイルをモデル（この場合User）に1対1の関連付けを添付するためのメソッ
ドです。
つまり、has_one_attachedは、DBに activeStorage_blobとして保存されている実際のファイルデータにリンクする、
activeStorage_attachmentを作成することによって、User モデルとアップロードされたファイルとの間の接続を確立する。
これにより、Userモデルはアップロードされたファイルと1対1の関係を持つことができる。
activeStorage_attachment
Userモデルと実際のファイルデータとの間の接続を表し、ファイルデータは`blob`としてデータベースに格納される。
activeStorage_blob
アップロードされたファイルに関連するファイルコンテンツ、メタデータ、その他の情報など、実際のファイルデータそのものを
指します。
------------------------------------------------------------------------------------------------
なお、レコードとファイルが1対1の場合は has_one_attached ですが、1対多の場合は has_many_attached になります。
Userモデルにavatar（この名前は何でもいい）という名前の1つの添付ファイルを添付することができます。これにより、画像
ファイルをUserレコードに関連付けることができます。
has_one_attachedメソッドは、Userモデルにアバターを添付するためのメソッドです。これにより、user.avatarというメ
ソッドを使って、Userモデルのインスタンスにアバターを添付できます。
アバター画像をアップロードするためには、フロント側でフォームを作成する必要があります。
------------------------------------------------------------------------------------------------
has_one_attachedによって生成されるメソッド
avatar
添付されたファイルを取得する。
user.avatar.attach
ユーザーオブジェクトにavatarを添付するためのメソッドです。ファイルをアップロードすることができます。
user.avatar.attached?
特定のユーザーがavatrを持っているかどうか検証し、真偽値を返すメソッドです

================================================================================================
4
include DeviseTokenAuth::Concerns::User
`include` はRubyのモジュールをクラスに取り込むためのメソッドです。これにより、モジュール内のメソッドや定数をクラ
スで使用できるようになります。
`DeviseTokenAuth::Concerns::User` は、Devise Token Auth gemが提供するモジュールで、トークンベースの認証
機能を追加するためのものです。
`include DeviseTokenAuth::Concerns::User` によって、Userモデルにトークン認証に必要なメソッドやバリデーシ
ョンが追加されます。これにより、APIモードでの認証が容易になります。

================================================================================================
5
このアソシエーションがなくても主キーや外部キーなどを使って値を取得できるが、アソシエーションを使用する事で、主キーや
外部キーなどのテーブル同士の関連付けを直感的に記述する事が出来るのです。
------------------------------------------------------------------------------------------------
has_many :posts
一対多のテーブルを作成した時，テーブル user を参照先，テーブル post を参照元と呼びます。
参照元には外部キーが必要です。
------------------------------------------------------------------------------------------------
has_many  <Model（クラス）名>で、そのクラス名を使ったメソッドが複数生成されます。
そのメソッドはUserモデルを通して関連するPostモデルを取得するためのものです。
つまり、Userモデルを通じて関連するPostモデルを取得することができます。これは、Userモデルが複数のPostモデルと関連
付けられていることを意味します。
具体的には、Userインスタンスから関連するすべてのPostインスタンスを取得することができます。
------------------------------------------------------------------------------------------------
has_many :postsで、自動で外部キーが設定される。
外部キー（2つのテーブルを繋ぐ）はuser_idです。この外部キーはPostモデルに付与されます。Userモデルではない。
------------------------------------------------------------------------------------------------
dependent: :destroy
ユーザーが削除されたときに、そ のユーザーに紐付いた(そのユーザーが投稿した)マイクロポストも一緒に削除されるようにな
ります。
これは、管理者がシステムからユーザーを削除したとき、持ち主の存在しないマイクロポストがデータベースに取り残されてしま
う問題を防ぎます。

================================================================================================
6
message: :invalid_image_format
config/locales/ja.ymlの日本語化ファイルからエラーメッセージを取得。

================================================================================================
7
has_many <Model（クラス）名>
一対多のテーブルを作成した時，テーブル user を参照先，テーブル active_relationships を参照元と呼びます。
参照元には外部キーが必要です。
------------------------------------------------------------------------------------------------
has_many :active_relationships
userモデルのインスタンスに、active_relationshipsというメソッドを作成する。
------------------------------------------------------------------------------------------------
has_many :active_relationshipsだと、railsはactive_relationshipクラスを探しに行く。
しかしそれは存在しないので、class_name:  "Relationship"で、Relationshipクラスを探しに行くように指定している。
:active_relationshipsは任意の名前を設定している。railsの規約にない設定の為、こういう記述になる。
------------------------------------------------------------------------------------------------
has_manyは、Userモデルを通して関連するRelationshipモデルを取得するためのものです。
つまり、Userモデルを通じて関連するRelationshipモデルを取得することができます。これは、Userモデルが複数の
Relationshipモデルと関連付けられていることを意味します。
具体的には、Userインスタンスから関連するすべてのRelationshipインスタンスを取得することができます。
------------------------------------------------------------------------------------------------
has_many :postsで、自動で外部キーが設定される。
外部キーはuser_idです。この外部キーはPostモデルに付与されます。
------------------------------------------------------------------------------------------------
自動で設定される外部キーを、foreign_key: "follower_id"によって、名称をfollower_idに変更している。
Relationshipクラスに、デフォルトの"user_id"ではなく、"follower_id"という外部キーが設定される。
こののケースでは自分がフォローしているユーザーを follower_id という外部キーを使って特定します。
------------------------------------------------------------------------------------------------
foreign_keyとは、参照先を参照するための外部キーの名前を指定するもの。
foreign_key は、関連付けを行う際に参照するカラムの名前を指定するために使われます。このオプションは、関連付けのデ
フォルトの外部キー（通常は モデル名_id）と異なるカラム名を持つ場合に使用されます。
------------------------------------------------------------------------------------------------
has_many :active_relationships の関連性を示す際に、foreign_key: "follower_id" を指定することで、
active_relationships テーブルの follower_id カラムが User モデルの外部キーとなることを明示しています。
------------------------------------------------------------------------------------------------
双方向関連付けをセットアップするには、belongs_to関連付けを使うときに相手側のモデルにhas_oneまたはhas_many関連付
けを指定します。
has_many :active_relationships の関連性を示す際に、foreign_key: "follower_id" をuser側（has_many側）で
指定することで、active_relationships テーブルの follower_id カラムが User モデルの外部キーとなることを明示し
ています。これにより、関連するレコードを正しく紐付けることができます。
------------------------------------------------------------------------------------------------
has_many :active_relationships によって生成されるメソッド
active_relationships
1. `active_relationships` の使用例は以下の通りです：
- `user.active_relationships`：`user` オブジェクトに関連する `active_relationships` を取得します。
- `user.active_relationships.count`：`user` オブジェクトに関連する `active_relationships` の数を取得し
ます。
- `user.active_relationships.create(followed_id: other_user.id)`：`user` オブジェクトに関連する
`active_relationships` を作成します。user と紐付けて能動的関係を作成/登録する。
user.active_relationships.create(followed_id: 4)のように使う。
- `user.active_relationships.create!(followed_id: other_user.id)`：`user` オブジェクトに関連する
`active_relationships` を作成します。userを紐付けて能動的関係を作成/登録する(失敗時にエラーを出力)。
------------------------------------------------------------------------------------------------
. **Userモデル間の多対多の関係性**
- `relationships`モデルを介してUserモデル同士が多対多の関係になっている。これは、一人のユーザーが複数のユーザー
をフォローでき、また複数のユーザーにフォローされる状況を表している。
- `Relationship`モデルは`follower_id`と`followed_id`の二つの外部キーを持つ。これらは`User`モデルへの参照で
ある。
- `User`モデルにおいて、`has_many :active_relationships`はユーザーがフォローしている他のユーザーを表し、
`foreign_key: "follower_id"`はこのユーザーがフォロワーであることを示す。これにより、一人のユーザーが複数のユー
ザーをフォローできる。

================================================================================================
7.1
自分がフォローしているユーザーを取得するには、 "follower_id"が自分になっているユーザーを探すから、
foreign_key: "follower_id"のになる。
外部キーは参照元に書く。多対多だからuserモデルに外部キーを書いている。
foreign_key: "follower_id"で結果的にそれに紐づく自分がフォローしているユーザーを返す機能を有するメソッドになる。
------------------------------------------------------------------------------------------------
foreign_key
- foreign_keyとは、外部キー制約のカラム名を指定することが出来るオプションです。通常は、外部キー制約のカラム名を、
「user_id」の様に「参照先のモデル名(小文字) 」+ 「_id」の形式になり外部キーだと認識されます。
- しかし、「参照先のモデル名(小文字) 」+ 「_id」の形式ではなく、違う名前の形式で外部キーに名前をつける場合は、
foreign_keyオプションで明示的に宣言する必要があります。
------------------------------------------------------------------------------------------------
. **`User` モデルに `foreign_key` オプションが記載される理由**:
- foreign_key オプションは通常、belongs_to が記述されているモデルに設定される。しかし、`User` モデルで
`foreign_key` オプションが `has_many` とともに使われるのは、実際には多対多の関連付けを設定しているためです。こ
のケースでは、`User` モデルが `Relationship` モデルを介して他の `User` モデルと多対多の関係を持っています。
`User` モデルにおける `has_many :active_relationships` と `has_many :passive_relationships` の両方で
、`foreign_key` オプションが使われており、これは `Relationship` モデルにおけるどのフィールドが `User` モデル
を参照するかを示します。
- `has_many :active_relationships, foreign_key: "follower_id"` では、`User` モデルがフォロワー
（follower）として `Relationship` モデルと関連付けられており、`foreign_key: "follower_id"` は
`Relationship` テーブルの `follower_id` カラムが `User` モデルのIDを参照していることを明示しています。
- 同様に、`has_many :passive_relationships, foreign_key: "followed_id"` では、`User` モデルがフォロー
される側（followed）として `Relationship` モデルと関連付けられており、`foreign_key: "followed_id"` は
`Relationship` テーブルの `followed_id` カラムが `User` モデルのIDを参照していることを明示しています。
- この設定により、`User` モデルは `Relationship` モデルを通じて他の多対多の `User` モデルとの関連を効果的に管
理できるようになっています。これは多対多の関連付けの一般的な実装方法であり、中間テーブル（この場合は
`Relationship`）を介して複雑な関連を表現しています。

================================================================================================
8
railsの場合は設定されていない。ないと不要なクエリが発生したり、エラーが発生する可能性有り。
------------------------------------------------------------------------------------------------
`inverse_of` の説明
- **`inverse_of` の役割**: `inverse_of` は、関連するオブジェクト間で双方向のリンクを作成するために使われる。
これにより、関連付けられたオブジェクト間で効率的にデータを取得し、処理を行うことができる。
------------------------------------------------------------------------------------------------
通常は、関連付けを双方向に機能させるために、2つのモデルの両方に関連付けを定義する必要があります。
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :author
end
------------------------------------------------------------------------------------------------
- `User` モデルには `has_many :books, inverse_of: :author` が定義されています。これは、`User` オブジェク
トが多くの `Book` オブジェクトを持つことを示し、`inverse_of: :author` はこれらの `Book` オブジェクトが
`User` オブジェクトを "author" として参照することを意味します。
- `Book` モデルには `belongs_to :author, foreign_key: "user_id", class_name: "User",
inverse_of: :books` が定義されています。これは、`Book` オブジェクトが `User` オブジェクトに属しており、その
`User` オブジェクトは "books" コレクションの一部として関連付けられることを示します。
------------------------------------------------------------------------------------------------
- 本件の例では、`User` オブジェクトが多くの `Relationship` オブジェクトを持つことを示し、
`inverse_of: :follower` は、これらの `Relationship` オブジェクトが `User` オブジェクトを "follower"（フ
ォローする側のユーザー）として参照することを意味します。
- このオプションは、関連付けるモデルが `Relationship` であることを明示しています。Railsは通常、関連名からモデル
名を推測しますが、ここではカスタム名（`active_relationships`）を使用しているため、`class_name` で関連するモデ
ルの実際のクラス名を指定する必要があります。
. **`foreign_key: "follower_id"`**:
- `Relationship` モデル内で、どのフィールドが `User` モデルへの参照（フォローする側）を表すかを指定します。ここ
では `follower_id` がその役割を果たしています。
------------------------------------------------------------------------------------------------
*具体例
# 特定のユーザー（例えば、idが1のユーザー）を取得
user = User.find(1) (*momo)

# そのユーザーが持つ active_relationships（フォロー関係）の一つを取得
relationship = user.active_relationships.first (*momoのfirstのフォローイング)

# relationship オブジェクトから follower にアクセスし、それが user オブジェクトであることを確認
relationship.follower == user # => true (*momoと一緒)

# relationship の followerという名前で user オブジェクトにアクセス可能
relationship.follower.name # => user の名前 (*momo)

# user の名前を変更
user.name = "新しい名前"

# relationship を通じて変更が反映されていることを確認
relationship.follower.name # => "新しい名前"
------------------------------------------------------------------------------------------------
inverse_of::follower`と`inverse_of::followed`をアソシエーションに設定しても、自動的に便利なメソッドが生成さ
れるわけではない。その代わり、`inverse_of` には別の目的がある：
. ** `inverse_of`:** の目的
- inverse_of`は、Railsで関連付けられた2つのモデル間の逆関係を明示的に指定するために使用されます。これはRailsが
関連付けが互いにどのように関連しているかを理解するのに役立ち、特にメモリ上でパフォーマンスを向上させ、不必要なデータ
ベースクエリを防ぐことができます。
- 例えば `User` モデルに `active_relationships` と `passive_relationships` がある場合、
`inverse_of: :follower` と `inverse_of: :followed` を設定することで、Rails はこれらのリレーションシップが
互いに逆であることを知ることができます。
- これは、メモリ上で関連オブジェクトを一緒に扱うような状況で特に役立ちます。例えば、`follower`の属性を変更した場
合、Railsはその変更を関連付けられた`Relationship`オブジェクトに反映させることができます。

2. **便利なメソッド:**。
   - あなたが挙げたメソッド (`has_many :following, through: :active_relationships, source: :followed` と `has_many :followers, through: :passive_relationships, source: :follower`) は確かに便利なメソッドです。これらは `User` モデルを通して、フォロワーやフォローしているユーザーのコレクションに直接アクセスする簡単な方法を提供します。
   - これらのメソッドは `invers
------------------------------------------------------------------------------------------------
- **自動認識の限界**: `ActiveRecord` は、`belongs_to` と `has_many` の基本的な関連付けは自動的に認識するが、
`foreign_key` や `class_name` といったカスタムオプションが使用されている場合は、関連付けを自動的に認識しない。
このため、`inverse_of` を明示的に指定する必要がある。
- has_many, has_one, belongs_to で:foreign_keyオプションなどをつかって規約とは違う命名をするときには、
:inverse_ofにつづけて関連先モデルからの関連名（エイリアス名、何という名前で参照するよう自作しているか、どの名前で
探すか）を書くことで双方向の関連をActiveRecordへ教えることができます。
------------------------------------------------------------------------------------------------
- **コード内での使用**: `User` モデルでは、`has_many :active_relationships` と
`has_many :passive_relationships` に `inverse_of` を使用している。これにより、`Relationship` モデルの
`follower` と `followed` との間で効率的な双方向関連付けが可能となる。
- **効果**: `inverse_of` を使用することで、リレーションシップを通じて関連オブジェクトにアクセスした際に、不必要
なデータベースクエリが発生するのを防ぎ、パフォーマンスを向上させることができる。
------------------------------------------------------------------------------------------------
詳細は下記参考
https://zenn.dev/igaiga/books/rails-practice-note/viewer/ar_inverse_of
------------------------------------------------------------------------------------------------
. 双方向関連付け（bidirectional association）とは、2つのモデル間の関連性を、両方向に機能するように設定するこ
とです。通常、関連付けを双方向にするためには、2つのモデルの両方に関連付けを定義する必要があります。一方のモデルに対
して関連付けを定義すると、もう一方のモデルからも関連するモデルにアクセスできるようになります。
------------------------------------------------------------------------------------------------
. 双方向関連付けでない場合、一方向の関連付けしか定義されていないため、片方向の関連性しか利用できません。例えば、
`Author`モデルが`has_many :books`と関連付けられているが、`Book`モデルには対応する`belongs_to :author`の関
連付けがない場合、次のような問題が発生します:
------------------------------------------------------------------------------------------------
- `Author`モデルからは関連するすべての`Book`インスタンスにアクセスできますが、`Book`モデルからは関連する
`Author`インスタンスにアクセスできません。
- `Book`モデルに新しい本を追加する場合、それがどの作者に属しているかを指定する方法がありません。
- `Book`モデルから`Author`モデルに関連付けられたメソッド（例: `book.author`）を利用できません。
このように、片方向の関連付けしかない場合、関連するモデルの間で情報や操作を共有するための便利なメソッドやアクセスが
制限されることになります。双方向関連付けを使用することで、より柔軟で便利な関連性を実現することができます。

================================================================================================
9
より使いやすくするためにfollowing（ユーザーがフォローしている他のユーザーの集合を取得）を作成。
これが定義されていない場合、ユーザーがフォローしている他のユーザーの集合を取得するには、active_relationshipsを
直接使ってクエリを行う必要があります。以下はその例です：

# Userモデルのインスタンスであるuserに対して、userがフォローしているユーザーの集合を取得する式
user_active_relationships = user.active_relationships
following_users = user_active_relationships.map { |relationship| relationship.followed }

user.active_relationshipsを使って、特定のユーザーが持つactive_relationships（つまり、そのユーザーがフォロ
ーしている関係）の集合を取得します。
それぞれのRelationshipオブジェクトに対して、relationship.followedを呼び出して、ユーザーがフォローしている各
ユーザー（followed）を取得します。
これらのfollowedユーザーを配列または集合として取得します。
------------------------------------------------------------------------------------------------
つまり、followingはuserのインスタンスにactive_relationshipsメソッドを実行した戻り値に、ひとつづつfollowedメ
ソッドを実行した返り値
------------------------------------------------------------------------------------------------
has_many :following, through: :active_relationships, source: :followed
userインスタンスにfollowingメソッドを作成する。
このfollowingメソッドは、userインスタンスのactive_relationshipsメソッドを通して、followed_id（そのユーザー
がフォローしているユーザーの集合）を取得する。

has_many :through関連付けは、他方のモデルと「多対多」（本件の場合はUserとUser）のつながりを設定する場合によく
使われます。
この関連付けでは、2つのモデル（この場合UserとUser）の間に「第3のモデル」（joinモデル:この場合Relationshipモデ
ル）が介在し、それを経由（through）して相手のモデル（Userモデル）の「0個以上」のインスタンスとマッチします。
------------------------------------------------------------------------------------------------
userインスタンスに対して、active_relationshipsメソッドを実行し、それで得られたそれぞれのRelationshipのインス
タンスデータ（自分がフォローしているデータの集合）の一つ一つに対して、followedメソッド（active_relationships.
followed）を実行する。
------------------------------------------------------------------------------------------------
through オプション
関連する別のモデル（Relationshipモデル）を介して関連を設定するためのオプションです。
through: :active_relationships と指定することで、active_relationships テーブル（Relationshipモデル）を
経由して関連を設定します。
through オプションは、引数に、関連を設定するために使用する中間テーブル（アソシエーションテーブル:この場合
Relationshipモデル）を指定するためのもの、中間テーブルを表すメソッドや直接中間テーブル名などを指定します。

:active_relationships, class_name: "Relationship",より、
through: :active_relationshipsは、Relationshipモデルのこと。
------------------------------------------------------------------------------------------------
source: :followed
source オプションは、through オプションと組み合わせて使用され、中間テーブルで参照する関連(取得する値)を指定しま
す。
through オプションで指定した中間テーブルに、さらにその中間テーブルにおいて、followedを通して、関連するモデルの名
前（User、フォローしているユーザー）を指定します。
------------------------------------------------------------------------------------------------
`through: :active_relationships` を指定している場合、`source: :followed` を追加することで、`User` モデル
が `:following` という関連を通じて直接的に `:followed` （外部キー:followed_id）の関連を持つことを示していま
す。
`:followed` メソッドは、（外部キー:followed_id）で取得できる値＝そのユーザーがフォローしているユーザーを取得する
`through: :active_relationships` と指定している場合、`has_many :following` によって返される関連オブジェク
トは、`User` モデルが `active_relationships` テーブルを介して関連付けられた `Relationship` モデルのコレクシ
ョンです。
しかし、`Relationship` モデルそのものではなく、`User` モデルがフォローしているユーザーを取得したい場合に
`source: :followed` を使用します。
`source: :followed` は、`Relationship` モデルの中で関連するユーザーモデルの名前を指定しています。
具体的には、`followed` という関連モデルを通じて `User` モデルと関連付けることで、`User` モデルがフォローしてい
るユーザーを取得します。
`followed` は `Relationship` モデルの中で `belongs_to :followed, class_name: "User"` のように定義され
ている関連です。（外部キー:followed_id）のことです。それで取得できる値＝そのユーザーがフォローしているユーザーを取
得する。
したがって、`has_many :following, through: :active_relationships, source: :followed` は、「`User` モ
デルが `active_relationships` テーブルを介して関連付けられた `Relationship` モデルを通じて、`followed` モ
デル（つまり、（外部キー:followed_id）で取得できる`User` モデルがフォローしているユーザー）を取得する」という意
味になります。
------------------------------------------------------------------------------------------------
has_many :followeds, through: :active_relationshipsだと、
Rails は「followeds」というシンボル名を見て、これを「followed」という単数形に変え、 relationships テーブル（
モデル）のfollowed_id を使って対象のユーザーを取得してきます。
つまり、デフォルトのhas_many throughという関連付けでは、Rails はモデル名(relationship:単数形)に対応する外部キ
ー(followed_id)を探します。
しかし、user.followeds という名前は英語として不適切です。代わりに、user.following という名前を使うために、
Rails のデフォルトを上書きする必要があります。ここでは:source パラメーターを使って、「following 配列の元は、
followed id の集合である」ということを明示的に Rails に伝えます。
------------------------------------------------------------------------------------------------
followingメソッドの戻り値は、そのユーザーがフォローしているユーザーのリスト
（ActiveRecord::Associations::CollectionProxyオブジェクト）です。

================================================================================================
10
followメソッドの戻り値は、other_userをfollowing配列に追加した結果となります。これは、
ActiveRecord::Associations::CollectionProxyオブジェクト（つまりフォロー中のユーザーのコレクション）です。
------------------------------------------------------------------------------------------------
<<
<<はRubyのArrayのメソッドで、要素を配列の最後に追加します。following << other_userはother_userをfollowing
配列の末尾に追加することを意味します。

================================================================================================
11
- active_relationships.find_by(followed_id: other_user.id).destroyという式は、まず
active_relationships（現在のユーザーがフォローしている関係）からother_userに対応する関係を検索し、それを削除す
る。
- この処理は二段階に分かれており、まず関連するオブジェクトを検索し、次にそのオブジェクトを削除するというステップを
含む。
------------------------------------------------------------------------------------------------
unfollowメソッドの戻り値は、find_byメソッドにより見つけたactive_relationships（つまりフォロー関係）の、
destroyメソッドの結果となります。成功した場合、削除されたRelationshipオブジェクトが返ります。
find_byで該当するRelationshipが見つからない場合はnilが返ります。
Railsのモデルのインスタンスのdestroyメソッドは、削除対象が存在しない場合：destroyメソッドはnilを返します。

================================================================================================
12
include?は、配列が特定の要素を含むかどうかを確認します。
following.include?(other_user)はfollowing配列がother_userを含むかどうかを確認します。
------------------------------------------------------------------------------------------------
following?と対照的な followed_by?メソッドを定義してもよかったのですが、サンプルアプリケーションで実際に使う場面
がなかったのでこのメソッドは省略

================================================================================================
13
詳細な説明は、7のhas_many :active_relationshipsを参考

================================================================================================
13.1
user.passive_relationships.first.followedでフォロー側にアクセス可能

================================================================================================
14
9のhas_many :followingを参考
------------------------------------------------------------------------------------------------
これは:followers 属性の場合、Rails が「followers」を単数形にして自動的に外部キーfollower_id を探してくれるか
ら、参照先(followers)を指定するための:source キーを省略してもよい。
必要のない:source キー をそのまま残しているのは、has_many :followingとの類似性を強調させるためです。

================================================================================================
15
すべてのユーザーがフィードを持つので、feed メソッドは User モデルで作るのが自然です。
つまり、
- このコードでは「フィード」とは、あるユーザーがフォローしている他のユーザーの投稿（このコードではPostとして表現さ
れている）の集合を指しています。
- すべてのユーザーが自分自身のフィードを持つというのは、そのユーザーがフォローしているユーザーの投稿が存在することを
意味しています。それぞれのユーザーのフィードは、そのユーザーがフォローしているユーザーによって異なります。
- `feed`メソッドは、あるユーザー（メソッドを呼び出すUserインスタンス）がフォローしているユーザーの投稿を取得する
機能を提供します。
- フィードはユーザー固有の情報であり、そのユーザーがフォローしているユーザーからの投稿を取得するためのメソッドです。
したがって、このメソッドはUserモデルに定義するのが最も適切で自然と言えます。なぜなら、Userモデルはユーザーに関する
情報とそのユーザーが行う動作を管理する責任を持つからです。
- また、`feed`メソッドがUserモデルに定義されていることにより、Userインスタンスから直接フィードを取得することがで
きます。例えば`@user.feed`のように呼び出すことができます。これは直感的に理解しやすく、使用しやすいと言えます。
------------------------------------------------------------------------------------------------
第一段階

def feed
    Micropost.where("user_id IN (?) OR user_id = ?", following_ids, id)
end
------------------------------------------------------------------------------------------------
following_idsは結果的にSQLクエリを生成しています。
------------------------------------------------------------------------------------------------
User.first.following.map(&:id)
各要素の id を呼び出し、フォローして いるユーザーの id を配列として扱うことができます。例えばデータベースの最初の
ユーザーに対して実行すると、次のような結果に。
[3, 4, 5, 6, 7, ...]
------------------------------------------------------------------------------------------------
map(&:id)
よく使われ、アンパサンド(Ampersand)& と、メソッドに対応するシンボルを使った短縮表記が使えます。
この短縮表記であれば、変数 i を使 わずに済みます。
[1, 2, 3, 4].map { |i| i.to_s }
=> ["1", "2", "3", "4"]
>> [1, 2, 3, 4].map(&:to_s)
=> ["1", "2", "3", "4"]
------------------------------------------------------------------------------------------------
following_ids メソッドは、has_many :following の関連付けをしたときに Active Record が自動生成したものです。
これにより、user.following コレクションに対応する id を得るためには、関連付けの名前の末尾に_ids を付け足すだけ
で済みます。
User.first.following_ids
[3, 4, 5, 6, 7, ...]
関連付けの名前の末尾に_ids を付け足すだ けで済みます。結果として、フォローしているユーザー id の文字列は、次のよう
にして取得することができます。
User.first.following_ids.join(', ')
=> "3, 4, 5, 6, 7, ..."
------------------------------------------------------------------------------------------------
?に、following_ids, idがそれぞれ入る。

^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^
第二段階

def feed
    Micropost.where("user_id IN (:following_ids) OR user_id = :user_id",
    following_ids: following_ids, user_id: (self.)id)
end

?の部分をシンボル値で置き換えられる

^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^
第三段階

SQLは一つの文で表すのが最善。その為には、SQL のサブセレクト(subselect)を使う。
まずfollowing_idsは、このような SQL に置き換えることができます。

following_ids = "SELECT followed_id FROM relationships
                 WHERE  follower_id = :user_id"

このコードを SQL のサブセレクトとして使います。つまり、「ユーザー 1 がフォローして いるユーザーすべてを選択する」とい
うSQLを既存のSQLに内包させる形になり、結果 として SQL は次のようになります。

SELECT * FROM microposts
WHERE user_id IN (SELECT followed_id FROM relationships
                  WHERE  follower_id = 1)
      OR user_id = 1

このサブセレクトは集合のロジックを(Rails ではなく)データベース内に保存するので、 より効率的にデータを取得することが
できます。
------------------------------------------------------------------------------------------------
改めての解説

Post.where("user_id IN (#{following_ids})
                     OR user_id = :user_id", user_id: id)

. `Post.where("user_id IN (#{following_ids}) OR user_id = :user_id", user_id: id)`の各引数の解説:
- `Post.where`は`Post`モデルに対する条件付きクエリを作成します。
- `"user_id IN (#{following_ids}) OR user_id = :user_id"`はSQLのWHERE句です。
- `user_id IN (#{following_ids})`は、`following_ids`で得られるIDのリストに含まれるユーザーIDを持つ投稿を
選択します。
- `OR user_id = :user_id`は、クエリの一部として現在のユーザーのID（`user_id`）に等しい投稿も選択します。
- `user_id: id`は、SQL文中の名前付きバインド変数`:user_id`に現在のユーザーのID（`id`）を渡します（代入される）
つまり、`user_id: id`は、`user_id: self.id`のこと。
------------------------------------------------------------------------------------------------
例: 現在のユーザーのIDが `5` の場合、`feed`メソッド内のクエリは次のようになります。
- SQLクエリの部分: `"user_id IN (#{following_ids}) OR user_id = :user_id"`
- バインド変数の部分: `user_id: 5`
この場合、`following_ids`は現在のユーザー（IDが5のユーザー）がフォローしているユーザーのIDのリストを返すSQLクエ
リの文字列です。
クエリを実行すると、`Post.where`メソッドは次のようなSQL文を生成します：

```sql
SELECT * FROM posts
WHERE user_id IN (SELECT followed_id FROM relationships WHERE follower_id = 5)
   OR user_id = 5;
```

このSQL文は、次の2つの条件に合致する`posts`テーブルのレコードを取得します：
. `posts`テーブルの`user_id`が、現在のユーザーがフォローしているユーザー（`following_ids`で得られるIDのリスト
に含まれるユーザー）のいずれかのIDと一致する。
. `posts`テーブルの`user_id`が現在のユーザー（この例ではIDが5）のIDと一致する。
------------------------------------------------------------------------------------------------
OR
「OR」条件は複数の条件式のいずれかが真である場合に対象の行を選択する。
この場合の条件は、①.follower_id=5のfollowed_idの投稿と、②.user_id=5の投稿
「いずれかを満たす」とは、これら2つの条件のうち少なくとも一つが真である場合に、その（投稿）が結果に含まれる。
結果として、このクエリは①.follower_id=5のfollowed_idの投稿と、②.user_id=5の投稿の両方を含む結果を生成する。
------------------------------------------------------------------------------------------------
. `where`はActiveRecordのメソッドであり、データベースから特定の条件を満たすレコードを探すために使用されます。
. `where`の引数は文字列にすることも可能ですが、ハッシュ、配列、範囲オブジェクトなども使用できます。文字列を引数と
して使用する場合は、SQLの構文を直接書くことが可能です。
. `where`メソッドについて詳しく説明すると：
- 引数にはハッシュ、文字列、配列、範囲オブジェクトなどが使用できます。例えば、`User.where(age: 20)`とすると
、ageカラムが20のユーザーのレコードを取得します。
- 引数として文字列を使用すると、その文字列がそのままSQLクエリの一部として使われます。この場合、プレースホルダー
を合わせて用いて値を埋め込むこともできます。例えば、あなたが示した
`"user_id IN (#{following_ids}) OR user_id = :user_id"`という文字列では、`following_ids`の部分が
直接文字列として展開され、`:user_id`の部分はプレースホルダーとして使われています。
- `where`メソッドは、結果としてActiveRecord::Relationオブジェクトを返します。このオブジェクトは配列のよう
に扱うことができ、また他のクエリメソッドをチェインしてさらに詳細なクエリを構築することも可能です。
------------------------------------------------------------------------------------------------
あなたが示した`feed`メソッドについて詳しく解説すると：
- `following_ids = "SELECT followed_id FROM relationships WHERE follower_id = :user_id"`で、
`relationships`テーブルから`follower_id`が`:user_id`（ここでは自分自身のid）に一致するレコードの
`followed_id`をすべて取得するSQL文を生成しています。
- 次に、`Micropost.where("user_id IN (#{following_ids}) OR user_id = :user_id", user_id: id)`
で、生成したSQL文を用いて`microposts`テーブルから特定のレコードを取得しています。取得するレコードは`user_id`
が自分がフォローしているユーザー（つまり、`following_ids`に含まれる）か、または自分自身
（`user_id = :user_id`）であるレコードです。
- この`feed`メソッドを用いることで、自分自身と自分がフォローしているユーザーが投稿したマイクロポストを取得する
ことができます。

================================================================================================
16
. `has_many :liked_posts, through: :likes, source: :post`:
- この関連付けは、`User`モデルと`Post`モデルの間の間接的な関係（多対多の関係）を定義する。中間はlikeテーブル。
- `User`が「いいね」した`Post`の集合を取得するために使用される。
- `through: :likes`は、この関連付けが`Like`モデルを介して行われることを示し、`source: :post`は、関連付けられ
る対象が`Post`モデルであることを指定する。
- この設定により、`User`インスタンスに対して`.liked_posts`メソッドを呼び出すことで、そのユーザーが「いいね」し
た全ての投稿を取得できる。
------------------------------------------------------------------------------------------------
. `liked_posts`を定義する意図は、直接的にユーザと投稿の間に関連付けがない場合でも、`likes`という中間テーブルを
通してユーザがいいねした投稿を簡単に取得できるようにするためです。このようにすることで、どの投稿をユーザがいいねした
のか、という情報を簡単に取り出すことができます。
------------------------------------------------------------------------------------------------
. `through: :likes`は`likes`テーブル（中間テーブル）を経由して関連付けを行うことを指定しています。つまり、
`likes`テーブルを通じて`liked_posts`を取得します。
`source: :post`は、中間テーブル`likes`のどの関連付けを`liked_posts`の元にするのかを指定しています。つまり、
`likes`テーブルの`post`関連付けを`liked_posts`の元とします。この記述があることで、Railsは`likes`テーブルの
`post_id`を使って投稿を取得します。この`source`オプションがないと、Railsは`liked_posts`という名前から投稿を
取得しようとしますが、そのような関連付けは`likes`テーブルに存在しないため、エラーになります。
------------------------------------------------------------------------------------------------
. liked_postsという命名は、liked_postsという名前から、これが「ユーザーがいいねした投稿」を表していることが直
感的にわかります。

================================================================================================
17
. "いいね"を確認するメソッドは、UserモデルでもPostモデルでも定義することができます。どちらに書くかは、実装者の設
計意図や使い勝手によるところが大きいです。Userモデルに書くことで「ユーザーが特定の投稿にいいねをしたかどうか」を直
感的に確認できますし、Postモデルに書くことで「特定の投稿が特定のユーザーからいいねをもらっているかどうか」を直感的
に確認できます。
------------------------------------------------------------------------------------------------
. 一般的に、LikeモデルはUserとPostの中間テーブルとしての役割を持ちます。このため、UserとPostの間の関連性を表す
メソッドはUserモデルやPostモデルに定義するのが一般的です。

================================================================================================
18
`self.liked_posts.`
`has_many :liked_posts, through: :likes, source: :post`というコードにより、Userオブジェクトは自身が「い
いね」したPostオブジェクトの集合に対して直接アクセスできます。それらのPostオブジェクトの集合を参照するために、
`liked_posts`というメソッドを使用します。
------------------------------------------------------------------------------------------------
`exists?`
ActiveRecordの関連付けのコレクションに対して、指定した条件に一致するレコードが存在するかどうかを確認します。
`exists?`メソッドはデータベースに直接問い合わせを行い、該当するレコードが見つかった時点で検索を終了します。これに
より、大量のレコードの中から検索を行う場合でも、パフォーマンスを効率的に維持することが可能です。
------------------------------------------------------------------------------------------------
`include?`
ある配列やコレクションに特定の要素が含まれているかどうかを調べるメソッド。真偽値を返す。
たとえば、`[1, 2, 3].include?(2)`は`2`が配列`[1, 2, 3]`に含まれているかを調べるため、結果は`true`となる。
`self.liked_posts.include?(post)`は`self`が「いいね」した投稿(`liked_posts`)の中に`post`が含まれているか
どうかを判定しています。
------------------------------------------------------------------------------------------------
`include?`と`exists?`の違いは、以下の通りです。
`include?`メソッドは、全ての関連付けられたレコードをメモリにロードし、その後で特定のレコードが含まれているかを、
Rubyのレベルで検索します。これはレコードの数が少ない場合には問題ありませんが、レコードの数が多い場合にはメモリ消費が
大きくなり、パフォーマンスに影響を及ぼす可能性があります。
したがって、大量のレコードの中から検索を行うような場合には、`exists?`メソッドを使用することが推奨されます。

================================================================================================
19
このシナリオにおける各機能の実装元について説明します：
. **[railsからユーザーへアカウント認証用のmailを送信。]**
- これはDeviseの機能です。Railsはフレームワークとしてメール送信機能を提供していますが、ユーザーのアカウント認証用
メールを自動的に送信する機能はDeviseの `confirmable` モジュールによって提供されます。このモジュールは、ユーザー
がサインアップした後に確認メールを自動的に送信する機能を持っています。
------------------------------------------------------------------------------------------------
. **[mailをクリックすると、認証が行われる]**
- これもDeviseの機能です。Deviseの `confirmable` モジュールには、メール内の確認リンクをユーザーがクリックした
際にユーザーのアカウントを認証（有効化）する機能が含まれています。このリンクは通常、ユーザーのメールアドレスと一緒
に送信される一意の認証トークンを含んでおり、クリックされるとDeviseはこのトークンを検証し、ユーザーのアカウントを有
効にします。
------------------------------------------------------------------------------------------------
. **[その後、next.jsのサインインページへ遷移。]**
- これは、DeviseとRailsの組み合わせによる機能ですが、実際にページ遷移をトリガーするのはRails（またはDevise）の
設定です。Deviseの確認プロセスが完了した後、ユーザーを特定のURL（この場合はNext.jsのサインインページ）へリダイレ
クトする設定をRails側で行います。このリダイレクト先は、Deviseの設定（例えば、`confirm_success_url`）で定義され
ることが一般的です。
=end
