# 1
class CreateRelationships < ActiveRecord::Migration[6.1]
  def change
    create_table :relationships do |t|
      # 2 idのカラムを作成。外部キーとして使用。
      t.integer :follower_id
      t.integer :followed_id

      t.timestamps
    end
    # 3
    add_index :relationships, :follower_id
    add_index :relationships, :followed_id
    # 3.1
    add_index :relationships, [:follower_id, :followed_id], unique: true
  end
end

=begin
@          @@          @@          @@          @@          @@          @@          @@          @
1
$ rails generate model Relationship follower_id:integer followed_id:integer
で作成
------------------------------------------------------------------------------------------------
user:referencesを付けていないので、t.references :userがない。
. `backend/api/db/migrate/20230711103017_create_relationships.rb`で`t.references`を使ってない理由
- `t.references`は外部キーとしての関連付けを設定するために使われる。`Relationship`モデルでは、`follower_id`
と`followed_id`を単純な整数型のカラムとして定義している。これは、`User`モデルへの参照を直接的ではなく、
`belongs_to`メソッドに`class_name: "User"`オプションを使用して関連付けを行っているためである。
`t.references`は自動的に外部キーを設定するが、ここではその必要がないため使用していない。
- 規約に則った場合、つまり{モデル名_id}がそのまま使える場合に限り、user:referencesが使える。followerや、
forrowedクラスがあるとrailsは誤解する
------------------------------------------------------------------------------------------------
. `backend/api/db/migrate/20230711103017_create_relationships.rb`に`t.references`を用いるRailsコマ
ンド
- `t.references`を使用するためのRailsコマンドは以下のようになる:
rails generate model Relationship follower:references followed:references
- このコマンドは`follower_id`と`followed_id`という外部キーを自動的に作成し、それぞれ`User`モデルへの参照とし
て機能する。ただし、この場合はモデル内で`class_name: "User"`の指定が必要になる可能性がある。これは、Railsがデ
フォルトで`follower`や`followed`という名前のモデルを参照しようとするためである。現在の設計では、これらのIDを直
接指定しているので、`t.references`の使用は必須ではない。
以上の点を踏まえて、現在の`Relationship`モデルの設計は適切であり、`t.references`を使わない選択はその設計に基づ
いている。また、`t.references`を使用する場合はモデル内での関連付けの定義を適切に行う必要がある。

================================================================================================
2
foreign_keyとは、参照先（この場合useモデル）を参照するための外部キーの名前を指定するもの。
外部キーは参照元（この場合relationshipモデル）のみに付ける。
つまり、belongs_toで参照する相手（参照先:user）の外部キーを指定するために、belongs_toを行う側(relationship)
のmodelファイルに記述しなければならないもの

================================================================================================
3
良く検索で使用するであろうものにindexを付ける。userのフォロー、フォロワーはよく検索するであろうから付ける。
------------------------------------------------------------------------------------------------
add_index
指定したテーブルにインデックスを追加。インデックスとは、データベースの検索性能を向上させるためのデータ構造。
------------------------------------------------------------------------------------------------
add_index :relationships, :follower_id は、relationships テーブルにおいて follower_id 列に対して単一の
インデックスを作成する操作です。
この単一のインデックスは、follower_id 列に基づいた検索や並び替えなどのクエリを効率的に実行するために使用されます。

================================================================================================
3.1
:relationshipsと[:follower_id, :followed_id]の2つの引数
:relationshipsはインデックスを追加するテーブルを指定します。
[:follower_id, :followed_id]はインデックスを作成するフィールドを指定します。follower_id, :followed_idの両
方を1つの配列に含めている。こうすることで Active Record は、両方のキーを同時に扱う複合キーインデックス
(Multiple Key Index)作成します。
------------------------------------------------------------------------------------------------
一人のユーザーが何人もフォローしなようにすrためにもuniqueを付ける。
------------------------------------------------------------------------------------------------
follower_id と followed_id には、複合キーインデックスと単一のインデックスの2つが付与されます。つまり、両方の列
に対して個別のインデックスが作成されます。
follower_id, :followed_idの両方のキーを同時に扱う複合キーインデックスは、follower_id と followed_id の組み
合わせが必ずユニークであることを保証する仕組みです。これにより、あるユーザーが同じユーザーを 2 回以上フォローするこ
とを防ぎます。
このような重複(2 回以上フォロー すること)が起きないよう、インターフェイス側の実装でも注意を払います。しかし、ユーザ
ーが何らかの方法で(例えば curl などのコマンドラインツールを使って) Relationship のデータを操作するようなことも
起こり得ます。そのような場合でも、一意 なインデックスを追加していれば、エラーを発生させて重複を防ぐことができます。
------------------------------------------------------------------------------------------------
複合キーインデックスとは、複数のカラム（列）を組み合わせたインデックスのことです。
この場合、:follower_id と :followed_id の2つのカラムを組み合わせて複合キーインデックスを作成しています。
複合キーインデックスは、複数のカラムの値を組み合わせた検索条件に効果的なパフォーマンスを提供することができます。
例えば、:follower_id と :followed_id の組み合わせでの検索や並び替えが頻繁に行われる場合に、効率的な検索を可能
にします。
------------------------------------------------------------------------------------------------
このインデックスの設定により、以下のような使用が想定されています：
フォローしているユーザーを取得する際に、follower_id を検索条件として効率的に検索できます。
フォローされているユーザーを取得する際に、followed_id を検索条件として効率的に検索できます。
特定のユーザーが他のユーザーをフォローしているかどうかを判定する際に、follower_id と followed_id の組み合わせ
が一意であるかを確認することができます。
具体的な例としては、ユーザーAがユーザーBをフォローしている場合、follower_id にはユーザーAのIDが、followed_idに
はユーザーBのIDが格納されます。
このインデックスの設定により、ユーザーAがユーザーBをフォローしているかどうかを効率的に確認したり、ユーザーAがフォロ
ーしているユーザー一覧やユーザーBをフォローしているユーザー一覧を取得することができます。
------------------------------------------------------------------------------------------------
30のfollower_idに対して、必ずユニークなfollowed_idが存在することを保証するために、unique: trueを指定していま
す。
unique: true は、複合キーインデックスにおいて重複を許さない制約を設定するためのオプションです。
このオプションを指定することで、:follower_id と :followed_id の組み合わせが一意であることを保証します。
つまり、同じ :follower_id と :followed_id の組み合わせを持つレコードが複数存在しないようにします。
これにより、データの整合性を維持し、重複したレコードが作成されることを防ぎます。
------------------------------------------------------------------------------------------------
別の書き方
`t.references`はActiveRecordのMigrationで使用され、2つの役割を持っています。一つ目は指定した名前のカラムを作
成すること、二つ目はそのカラムにインデックスを自動的に作成することです。
そのため、`t.references :user`と書いた場合、`user_id`というカラムが作成され、その上にインデックスが自動的に作
成されます。
`t.references :user`と`t.references :post`でそれぞれ`user_id`と`post_id`に対するインデックスが作成されて
います。
`t.integer :follower_id`と`t.integer :followed_id`でインデックスは自動的に作成されません。
そのため、その後の`add_index :relationships, :follower_id`と`add_index :relationships, :followed_id`
で初めてインデックスが作成されます。そのためこちらではインデックスの重複エラーは出ません。
まとめると、`t.references`は自動的にインデックスを作成するのに対し、`t.integer`は手動で`add_index`を使ってイ
ンデックスを作成する必要がある、というのがこの2つの間の主な違いです。
=end

