# 1 @@ こちらはリバースプロキシ先のバックエンドのサーバーの設定 @@
# upstream api-app が無意味かどうか
# 意味がある。Nginxでtry_files $uri/index.html $uri @api-app;が指定されているため、リクエストがRails（Puma）に転送されます。
# 根拠: try_files ディレクティブは、指定されたURIが見つからない場合、@api-app（upstream api-app）に転送する。

# 1.1
upstream api-app {
  server unix:///api-app/tmp/sockets/puma.sock fail_timeout=30s;
}

# 2 @@ こちらはNginx（リバースプロシキサーバー）の設定 @@
# server:サーバー情報を定義。デフォルトのバーチャルホストの設定。
server {
  # 2.1
  listen 80;
  # 3
  server_name localhost;
  # 3.1
  access_log /var/log/nginx/access.log;
  # 3.2
  error_log  /var/log/nginx/error.log;
  # 3.3
  root /api-app/public;  # またはnenxt.jsの場合は /usr/src/front/.next
  # .next フォルダや Rails の public フォルダは、静的なファイルを格納する一般的な場所です。

  # Nginxが受信可能なリクエストボディの量を指定
  client_max_body_size 100m;

  # error_page:ステータスコードに応じて表示するページを指定
  error_page 404             /404.html;
  error_page 505 502 503 504 /500.html;

  # try_files:ファイルが存在するかを確認。引数3つ。何もなければ@api-app(puma)へ
  # 5
  try_files  $uri/index.html $uri @api-app;

  # HTTP通信のタイムアウトを待つ秒数を指定
  keepalive_timeout 5;

  # 4 @@ リバースプロキシ関連の設定（serverコンテキスト内のlocationディレクティブ）@@
  # ディレクティブの{}内はそのディレクティブのコンテキストでさらにディレクティブを記述できる。
  # location /:全てのパスが一致
  location / {
    # 4.1 実際のクライアントのIPアドレスをバックエンドサーバに送るために使用されます。
    proxy_set_header X-Real-IP $remote_addr;
    # 4.2 クライアントがどのIPアドレスから来たか、そしてリバースプロキシを経由したかどうかをバックエンドサーバに通知します
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    # 4.3 元のホスト名（Host ヘッダーの内容：アプリのドメイン名等）をバックエンドサーバに渡します。
    proxy_set_header Host $http_host;
    # 4.4 frontサービスの3000番ポートに転送
    proxy_pass http://front:3000/;
  }

  # 管理側（バックエンド）
  location /backend/ {
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    # 4.5 proxy_passにapi-app(upstream)を設定。unixドメインソケット通信なのでポート番号は不要。
    proxy_pass http://api-app;
  }

  # location @api-app {
  #   # proxy_set_header:アプリケーションサーバーに送信するヘッダを定義
  #   # X-Real-IP $remote_addr:X-Real-IPで送信元を判別、$remote_addrで送信元IPを取得
  #   proxy_set_header X-Real-IP $remote_addr;
  #   # X-Forwarded-For $proxy_add_x_forwarded_for:リクエストが経由したアドレス全てを指定
  #   proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  #   # Host $http_host:ユーザーリクエストに含まれるホスト名を指定
  #   proxy_set_header Host $http_host;
  #   # proxy_pass:転送先URIまたは転送先のupstreamの名前を指定(転送先サーバー)し、リクエストを転送先URIにプロキシする。
  #   # 今回はupstreamでapi-appとして定義した[unix:///api-app/tmp/sockets/puma.sock]に転送。
  #   proxy_pass http://api-app;
  # }

# 消してみる
  # location /backend {
  #   # proxy_set_header:アプリケーションサーバーに送信するヘッダを定義
  #   # X-Real-IP $remote_addr:X-Real-IPで送信元を判別、$remote_addrで送信元IPを取得
  #   proxy_set_header X-Real-IP $remote_addr;
  #   # X-Forwarded-For $proxy_add_x_forwarded_for:リクエストが経由したアドレス全てを指定
  #   proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  #   # Host $http_host:ユーザーリクエストに含まれるホスト名を指定
  #   proxy_set_header Host $http_host;
  #   # proxy_pass:転送先URIまたは転送先のupstreamの名前を指定(転送先サーバー)し、リクエストを転送先URIにプロキシする。
  #   # 今回はupstreamでapi-appとして定義した[unix:///api-app/tmp/sockets/puma.sock]に転送。
  #   proxy_pass http://api-app:3000;
  # }
}

# @          @@          @@          @@          @@          @@          @@          @@          @
# ================================================================================================
# nginxの設定ファイルについて
# ------------------------------------------------------------------------------------------------
# Nginxの設定ファイルは、コンテキスト（Context）とディレクティブ（Directive）という2つの主要な要素を使用してサー
# バーの動作を設定します。以下にそれぞれの要素の説明をします。
# ------------------------------------------------------------------------------------------------
# 一番外側がmainコンテキスト。その中にディレクティブを書く。
# 各ディレクティブの中にあるのが、そのディレクティブのコンテキストという構成
# ------------------------------------------------------------------------------------------------
# **コンテキスト（Context）**:
# コンテキストは、設定ファイル内の特定のセクションを指します。Nginxの設定ファイルは階層構造を持ち、異なるコンテキスト
# 内で異なる設定が行われます。設定ファイルの各コンテキストは、特定のタスクや設定グループに関連する設定を含みます。一般
# 的なコンテキストには以下のようなものがあります：
# - `events`: イベント駆動の設定を行うコンテキスト。プロセスの動作や接続の扱いに関する設定を含みます。
# - `http`: HTTPサーバー全体の設定を行うコンテキスト。サーバー全体で共通の設定を指定します。
# - `server`: 個別のHTTPサーバーの設定を行うコンテキスト。ドメインやポートごとの設定を含みます。
# - `location`: 特定のURLパスに対する設定を行うコンテキスト。リクエストのURIに基づく設定を指定します。
# ------------------------------------------------------------------------------------------------
# **ディレクティブ（Directive）**:
# ディレクティブは、設定ファイル内で使用されるコマンドや設定の指示です。ディレクティブはコンテキスト内で使用され、特定
# の設定や動作を指定します。設定ファイルのディレクティブは、コンテキストに応じて異なる効果を持ちます。いくつかの一般的
# なディレクティブには以下のようなものがあります：
# - `listen`: サーバーが受け付けるポートを指定します。
# - `server_name`: ドメイン名を指定して、特定のサーバーブロックを識別します。
# - `location`: 特定のURLパスに対する設定を指定します。
# - `proxy_pass`: リバースプロキシとして動作する際に、バックエンドのサーバーを指定します。
# ------------------------------------------------------------------------------------------------
# ディレクティブはその効果を持つコンテキスト内で使用されるため、正しいコンテキスト内でディレクティブを配置することが重
# 要です。設定ファイルのディレクティブはコマンドラインのように一つずつ実行するのではなく、設定全体を定義するためのもの
# です。
# ------------------------------------------------------------------------------------------------
# 総括すると、Nginxの設定ファイルはコンテキストとディレクティブを組み合わせて、サーバーの動作や設定を制御します。コン
# テキストは設定の階層構造を形成し、ディレクティブは特定の設定を指定します。

# ================================================================================================
# nginxの設定ファイルの読み込み順
# ------------------------------------------------------------------------------------------------
# Nginxの設定ファイルを自作する場合、/etc/nginx/conf.d/以下に作る。名前は任意で最後が.confで終わるように。
# e.g:/etc/nginx/conf.d/hoge.conf
# Nginxの設定ファイルはデフォルトで２つあり、以下の順番で読み込まれます。
# /etc/nginx/nginx.conf、/etc/nginx/conf.d/default.conf
# nginx.confが一番初めに読み込まれる。nginx.confがnginx/conf.d以下を読み込む。

# ================================================================================================
# 1
# . **upstreamの解説**
# - `upstream` ディレクティブは、Nginxがリバースプロキシとして動作する際に、バックエンドサーバーやアプリケーション
# サーバーへの接続方法を指定するために使用されます。バックエンドサーバーの一連のアドレスや設定をまとめて定義することが
# できます。例えば、負荷分散や冗長性の確保などのために複数のバックエンドサーバーを指定することができます。
# -`upstream api-app` ブロックが定義されています。これは `api-app` という名前のバックエンドグループを定義してい
# ます。`server` ディレクティブを使用してバックエンドのサーバーアドレスを指定し、そのサーバーに接続する方法を指定し
# ています。
# - ここで使用されている `unix:///api-app/tmp/sockets/puma.sock` は、Unixソケットを介してバックエンドのアプ
# リケーションサーバーに接続する方法を表しています。
# - `fail_timeout=30s` は、接続がタイムアウトした場合に30秒間隔で再試行することを意味します。
# api-appはこのサーバーに繋ぐという設定
# unixドメインソケット（サーバとクライアントの二者間通信）によるコンテナ間通信をしたいので、puma.sockを指定。
# ------------------------------------------------------------------------------------------------
# . **serverの解説**:
# - `server` ディレクティブは、NginxがHTTPリクエストを受け取った際の振る舞いを設定するために使用されます。Nginxは
# 複数の `server` ブロックを持つことができ、それぞれが異なるドメインやポートに対するリクエストを処理します。
# この`upstream` ディレクティブ内では、リクエストの処理方法やリバースプロキシの設定などが指定されます。
# ------------------------------------------------------------------------------------------------
# このupstreamに付けたapi-appという名前はproxy_passディレクティブで再度使用します。
#  設定ファイルの例では、`server` ブロックが定義されているかどうかは示されていませんが、一般的には `server` ディレ
# クティブの中でドメインやポートの指定、リクエストの処理方法、リバースプロキシの設定、SSL設定などが行われます。
# 提供された設定ファイルの一部を見る限り、`upstream` ディレクティブはアプリケーションサーバーへの接続方法を定義して
# おり、`server` ディレクティブはリクエストの受け取りと処理に関する設定を行う場所であると考えられます。
# ------------------------------------------------------------------------------------------------
# Unixドメインソケットの設定
# upstreamコンテキストは、バックエンドのアプリサーバーを示すもので、サーバーのipアドレスとポート番号を
# 並べたserverディレクティブを並べて記載し、まとめたものに名前を付ける。
# ------------------------------------------------------------------------------------------------
# upstream:アプリケーションサーバーの指定(バックエンドのアプリケーションサーバPumaとUnixドメインソケット
# 通信で接続する場合は、puma.sock を指定すればOK)。
# puma.rbのソケット設定(puma.sock)の絶対パスを記載。
# ------------------------------------------------------------------------------------------------
# *ソケット＝ざっくりネットワークとの接続の出入り口。機器間の通信やプロセス(プログラムの処理)間の通信に使用
# されるインターフェイス。
# *ソケット通信＝ソケットを利用した、外部のネットワークに繋がるインタフェースに接続する、サーバとクライアント
# の二者間通信。
# *Unixドメインソケット＝カーネル内部で完結する高速なネットワークインタフェースを作成し、ウェブサーバやアプリ
# サーバーとNGINXなどのリバースプロキシとの間、あるいはウェブサーバとデータベースとの間の接続を高速にできる。
# ------------------------------------------------------------------------------------------------
# サーバ（要求を待ち続けるコンピュータ）の中の実行中のプログラムは、通常サーバーソケットと
# データ送受信用のソケットの二つにバインドされる。
# 別のパソコンからサーバーへ通信を開始したい時には、まずアクセスする際は、サーバソケットに対して、通信を投げる。
# サーバソケットから別のパソコンへの返信には、データ送受信用ソケットに関する情報が含まれているのが普通。
# それを受けた別のパソコンは、サーバとデータの送受信が出来るようになる。
# ここでソケットと実行中のプログラムを結びつける事をバインドと言う
# サーバーのIPアドレス（あるいはサイト名）とサーバーソケットのポート番号を指定して通信を開始する
# データ送受信用ソケットは状況に応じて増えたり減ったりする
# ------------------------------------------------------------------------------------------------
# ここのapi-appはDockerfileで記述したWORKDIR /api-app
# ------------------------------------------------------------------------------------------------
# ソケット通信とは
# インターネットはTCP/IPと呼ぶ通信プロトコルを利用しますが、そのTCP/IPをプログラムから利用するには、
# プログラムの世界とTCP/IPの世界を結ぶ特別な出入り口が必要となります。
# その出入り口となるのがソケット(Socket)であり、TCP/IPのプログラミング上の大きな特徴とのことで、
# 普段利用しているHTTP通信もソケット通信
# ------------------------------------------------------------------------------------------------
# Unixドメインソケット:
# 「UNIXドメインソケット」とは、LinuxなどのUNIX系OS（オペレーティングシステム）
# で実行されるプロセス間のデータ通信の終点に使われるインターフェースのことをいう。LinuxなどのUNIX系OSは、
# 各種デバイスの入出力にデバイスファイルというインターフェースを利用するため、
# 一般のファイルを読み書きするのと同じ手順で周辺機器を操作できる。ところが、プロセス同士がネットワーク経由で通信するときには、
# ファイル・インターフェースを拡張した「ソケット」というインターフェースが必要になる。
# 通常インターネットで利用しているソケット通信（INETドメインソケット通信）とは異なり、
# ネットワーク経由ではないローカルマシン上のプロセスが利用するソケットが、UNIXドメインソケットである。
# ------------------------------------------------------------------------------------------------
# Nginxのバーチャルホスト
# 同一のサーバで複数のドメインを振り分けるには、バーチャルホストという仕組みを用います。
# バーチャルホストとは、ドメイン毎にサーバーの処理を振り分けるものです。 ドメイン毎に違う処理を行うので、
# あたかも複数のサーバに見える(仮想的)、というのが名前の由縁なのだと思います。
# バーチャルホストは、一台のサーバーで仮想的に複数のドメインを運用するサーバー技術の一種で、
# 主にメールサーバーやWebサーバーなどで利用されています。
# メールサーバーやWebサーバーを運営する場合、一般的にドメインの数を上回るサーバーを用意することが多いのですが、
# バーチャルホスト機能を利用することで、1つのサーバー上で複数ドメインを同時に運用することができるようになります。
# このため、IPアドレスの節約効果やサーバー機器を減らすことで運用コストの削減などのメリットがあります。

# ================================================================================================
# 1.1
# . `upstream api-app`
# バックエンドのアプリケーションを識別するための名前を[api-app]で設定しています。この名前は、後でリバースプロキシの
# 設定で使用されます。

# ================================================================================================
# 2
# . **server :
# - `server { ... }` ブロックは、Nginxの設定ファイル内で特定のサーバーを定義するためのものです。これは、リクエス
# トを受け取った際の振る舞いや処理方法を設定するために使用されます。特定のポートやドメイン、パスに対するリクエストを処
# 理するための設定が含まれます。
#    あなたの提供した設定ファイルの例では、`server { ... }` ブロックがNginxサーバーの設定を定義しています。具体的な設定内容は以下のようになります：

# ================================================================================================
# 2.1
# listen:バーチャルホスト(IPアドレスでHTTPリクエストした場合に応答するホスト)が接続を許可するポート番号を定義。
# 別途IPアドレス＋ポート番号の指定も可能:ex.[listen 192.0.2.1:80]
# ------------------------------------------------------------------------------------------------
# iPアドレスのデフォルト値はすべてのインターフェイスアドレスを意味する"*"であり、ポート番号のデフォルト値は"80"にな
# ります。そのため、listenディレクティブを省略すると、次の設定と同じになります。
# listen *:80;
# この設定は次のそれぞれの設定と同じ意味を持ちます。
# listen 80;
# listen *;
# ------------------------------------------------------------------------------------------------
# 一番上に設定した
# server {
#     listen 80;
#     server_name www.test.jp  w3.test.jp;
#     ...
# }
# が特に指定しない場合、デフォルトサーバーになる。

# ================================================================================================
# 3
# server_name:ホスト名の指定。アクセスを受け付けるURLかドメインもしくはIPを指定する。
# localホストはIPアドレスだと、通常は127.0.0.1
# 本番環境は、ロードバランサーのDNS or ローカルでデプロイするなら、localhost
# 例：server_name 52.69.235.20;
# ------------------------------------------------------------------------------------------------
# server_nameディレクティブにはバーチャルサーバの名前を設定します。
# 仮にバーチャルサーバの名前を[server_name example.com]として、ウェブブラウザがウェブサーバに、
# リクエスト先のサーバーのホスト名を"example.com"と指定したリクエストを送った場合、nginxはこのリク
# エストを受け取ると、このホスト名がserver_nameディレクティブに設定したサーバ名に一致するserverディレク
# ティブのバーチャルサーバを選び、そのserverディレクティブ内の設定が適応されます。このようにserver_name
# ディレクティブは名前ベースのバーチャルサーバを設定するために使われます。

# ================================================================================================
# 3.1
# access_log:アクセスログの出力先を設定 (/var/log配下だとわかりやすい)
# /var/log/nginx/access.log;がコンテナ内に作成される。
# varディレクトリ:ログファイルやキャッシュファイルなどの一時的なデータを残しおく為のディレクトリ
# tmpディレクトリと違うのは、再起動しても残る。

# ================================================================================================
# 3.2
# error_log:エラーログの出力先を設定 (/var/log配下だとわかりやすい)
# エラーが起きたとき:cat /var/log/nginx/error.logを見てデバッグしましょう

# ================================================================================================
# 3.3
# - root:アプリのルートディレクトリ(公開するディレクトリ)を定義。ドキュメントルートの指定。
# - ドキュメントルートはWebサーバーが公開するコンテンツの配置ディレクトリのことです。
# - ドキュメントルートとは、Webサーバにアクセスがあった際に参照するディレクトリのことです。Webサーバーがクライアントか
# らのHTTPリクエストに対して、どのディレクトリ内のファイルを提供するかを示すディレクトリのことです。要するに、Webサー
# バーが公開するコンテンツ（HTMLファイル、画像、CSSファイルなど）が置かれるディレクトリのパスを指します。
# - Webサーバーがリクエストを受け取ると、そのリクエストのURI（Uniform Resource Identifier）に基づいて、ドキュメ
# ントルート内の対応するファイルやディレクトリを探し、クライアントに返します。つまり、ドキュメントルートはWebサーバー
# が公開するコンテンツへのアクセスポイントとなる場所です。
# - 静的ファイル（画像など）のパスをドキュメントルートに設定
# -静的コンテンツは「(Railsアプリケーションのルート)\public\」ディレクトリに格納されています。
# ------------------------------------------------------------------------------------------------
# 「ドキュメントルート」とは、WebサーバーがクライアントからのHTTPリクエストに対して、どのディレクトリ内のファイルを
# 提供するかを示すディレクトリのことです。要するに、Webサーバーが公開するコンテンツ（HTMLファイル、画像、CSSファイル
# など）が置かれるディレクトリのパスを指します。
# ------------------------------------------------------------------------------------------------
# Webサーバーがリクエストを受け取ると、そのリクエストのURI（Uniform Resource Identifier）に基づいて、ドキュメン
# トルート内の対応するファイルやディレクトリを探し、クライアントに返します。つまり、ドキュメントルートはWebサーバーが
# 公開するコンテンツへのアクセスポイントとなる場所です。

# ================================================================================================
# 4
# locationディレクティブ
# ------------------------------------------------------------------------------------------------
# 一般的に、next.jsとrails(api)に対して、両方の前段にnginxを配置します。
# 根拠: nginxはリバースプロキシとして機能し、クライアントからのリクエストを適切なバックエンド（ここではNext.jsや,
# Rails API）にルーティングする役割を持つため。
# 一般的にクライアントからのリクエストはnginx -> Next.js -> Rails(API) の順に流れます。
# ------------------------------------------------------------------------------------------------
# locationの設定について: 両方の設定（Next.jsとRails）が必要です。
# 根拠: nginxは単にリバースプロキシであり、どのリクエストがAPI（Rails）に行くべきか、どれがフロントエンド（Next.
# js）に行くべきかを判別する必要があります。
# ------------------------------------------------------------------------------------------------
# locationディレクティブは、引数に指定されたパス名に対応するコンテキストを作る。複数の書式あり。
# [location パス名]という書式は前方一致（語頭部分以下は全て任意）させる書式。
# ex.[location / ]:すべてのパスが一致
# ex.[location /files/ ]:/files/で始まるすべてのパスが一致
# ------------------------------------------------------------------------------------------------
# locationディレクティブではURIのパス毎の設定を記述できます。括弧{ }で囲まれた部分がlocationコンテキスト
# になります。リクエストURIのパスがこのlocationディレクティブのパスの条件に一致した場合にこのlocationコン
# テキストに記述した設定が適応されます。パスの条件の評価方法は前方一致と正規表現の2つです。
# ------------------------------------------------------------------------------------------------
# locationディレクティブではURIのパスの代わりに@の後に名前を付けることにより、名前付きロケーションを作ること
# ができます。この名前付きロケーションは内部リダイレクトで使用します。
# ------------------------------------------------------------------------------------------------
# 普通のリダイレクト（HTTPリクエストの達成に追加処理が必要なときに返される）はレスポンスコード（３桁の数字）に
# 301や302を、Locationヘッダフィールドにリダイレクト先のURIを指定して返し、クライアントはそのURIに対して再び
# リクエストを送ります。これとは別に内部リダイレクトというものがあります。これは、レスポンスコードに301や302を
# 指定せずに、内部的にURIのパスの書き換えを行い、その結果のページの内容を返します。クライアントから見るとリダイ
# レクトしているようには見えません。nginxではこのような内部リダイレクトがよく使われます。
# ------------------------------------------------------------------------------------------------
# indexディレクティブ、error_pageディレクティブ、tri_filesディレクティブではこの内部リダイレクトが使われます。
# 内部リダイレクトではリダイレクト先のパスに対して毎回locationディレクティブの評価が行われます。なお、この名前
# 付きロケーションはserverコンテキストにしか記述できません。
# 今回の例では、リクエストURIのパスの先頭が"@api-app"に一致した場合に適応されます。
# *パスの一致条件が少々複雑なので注意。

# ================================================================================================
# 4.1
### . `proxy_set_header`
# - `proxy_set_header`はNginxでリバースプロキシを設定する際に使用します。
# - リクエストがプロキシサーバ（Nginx）を経由してバックエンド（Rails等）に到達するとき、このディレクティブで指定さ
# れたHTTPヘッダーを追加・書き換えします。
# ------------------------------------------------------------------------------------------------
### . `proxy_set_header`の引数の解説
# - 第一引数: 追加または変更するHTTPヘッダーの名前
# - 第二引数: ヘッダーに設定する値／特定の変数（`$remote_addr`など）を使用できます。
# -----------------------------------------------------------------------------------------------
### . `X-Real-IP`の解説
# - `X-Real-IP`は元のクライアントのIPアドレスを保存するためのカスタムHTTPヘッダーです。
# - リバースプロキシを使用している場合、バックエンドが実際のクライアントのIPを知るために用います。
# ------------------------------------------------------------------------------------------------
### . `$remote_addr`の解説
# - `$remote_addr`はNginx変数で、リクエストを行ったクライアントのIPアドレスを保持します。
# - `proxy_set_header X-Real-IP $remote_addr;`とすることで、バックエンドがこのIP情報を把握できます。
# - 明示的に設定しなくても、Nginxが自動で設定します。

# ================================================================================================
# 4.2
# . X-Forwarded-For
# - HTTPヘッダーの一つ。。クライアントのIPアドレス情報をサーバーに伝える役割。リバースプロキシやロードバランサーを
# 経由する際に用いられる。
# - LB（ロードバランサー）や、リバースプロキシによる代理アクセスなど、IPヘッダのソースIPアドレスがクライアントのIPア
# ドレスからその中継機器のIPアドレスに置き換えられてしまう場合に、クライアントのIPアドレスをバックエンドサーバが取得
# できるよう、中継機器が設定するリクエストヘッダです。クライアントのIPアドレスと、中継した機器のIPアドレスを配列とし
# て格納します。
# ------------------------------------------------------------------------------------------------
# . $proxy_add_x_forwarded_for
# - Nginx変数。X-Forwarded-ForヘッダーにプロキシサーバーのIPを追加する。nginx.confによく設定されるが、基本的に
# デフォルトで設定される。
# ------------------------------------------------------------------------------------------------
# $proxy_add_x_forwarded_forの具体的な値:
# 例: クライアントIPが "192.168.0.1"、NginxのサーバーIPが "203.0.113.1" の場合
# X-Forwarded-For: 192.168.0.1, 203.0.113.1
# *複数のプロキシを経由する場合、カンマ区切りでIPが追加されます。

# ================================================================================================
# 4.3
# . Host
# - HTTPヘッダーの一つ。Hostリクエストヘッダーは、リクエスト送信先のサーバーのホスト名とポート番号を指定する。ドメ
# イン名やIPアドレス、ポートを含むことがある。
# ------------------------------------------------------------------------------------------------
# . $http_host
# - Nginx変数。HTTPのHostヘッダーの内容を保持。nginx.confで特に設定しなくても自動的に取得される。
# - ここには、クライアント(user)がリクエストを送信した際のホスト名（アプリのドメイン名）が格納される。

# ================================================================================================
# 4.4
# front:doxker-composeのサービス（コンテナ）名
# [localhost:/]に来たら、frontサービスコンテナの3000番ポートと接続
# ------------------------------------------------------------------------------------------------
# . `proxy_pass`の解説:
# - `proxy_pass`ディレクティブは、Nginxが受け取ったHTTPリクエストをリバースプロキシ先（向こうの）のサーバーに転送
# するために使用されます。具体的には、リバースプロキシが受け取ったリクエストを指定されたアップストリームやURLにリダイ
# レクトする役割を果たします。
# - `proxy_pass`は、指定されたURLへリクエストを転送します。
# - この場合、`http://front:3000/`と設定されているので、リクエストはこのURLに転送されます。
# ------------------------------------------------------------------------------------------------
# . `proxy_pass http://front:3000/`でなぜ設定できるのか、コンテナのサービス名は？
#   - この設定ができる理由はDocker Composeによって定義されたサービス名を使用しているからです。
#   - `docker-compose.prod.yml`の`services`セクションで`front`という名前のサービスが定義されています。これに
# より、`front`はDocker内部のDNSに登録され、この名前で解決できます。
#   - ポートは3000に設定されているので、`http://front:3000/`とすることでNginxからそのサービスにアクセスできます。
# ------------------------------------------------------------------------------------------------
# 具体的な変換の流れ：
#   - ユーザーがアクセスした際に、Nginx（`nginx-ctr-prod`コンテナ）がリクエストを受け取ります。
#   - `location /`の設定によって、そのリクエストは`http://front:3000/`に転送されます。
#   - `front:3000`は、`docker-compose.prod.yml`で定義された`front`サービス（`nextjs-ctr-prod`コンテナ）
# の3000番ポートを指しています。
#   - したがって、実際のリクエストは`nextjs-ctr-prod`コンテナの3000番ポートに転送されることになります。
# ------------------------------------------------------------------------------------------------
# このようにDocker Composeの設定とNginxの`proxy_pass`が連携して、リバースプロキシとして機能します。
# ------------------------------------------------------------------------------------------------
# Docker内部のDNS（Domain Name System）とは、Dockerエンジンに組み込まれている名前解決システムです。この機能によ
# って、コンテナ間の通信が容易になります。
# 具体的には：
# - Docker Composeで定義したサービス名（この場合は`front`）が自動的にDocker内部のDNSサーバに登録されます。
# - この名前（`front`）を使って他のコンテナ（この場合はNginxコンテナ）からアクセスすると、Docker内部のDNSサーバが
# 対応するコンテナのIPアドレスに解決してくれます。
# この仕組みにより、コンテナのIPアドレスを直接指定する必要がなく、サービス名で簡単に通信相手を指定できます。

# ================================================================================================
# 5
# try_filesディレクティブには存在をチェックするファイルやディレクトリと存在しなかったときにリダイレクトする
# URIのパスを指定します。記述方法は次の通りです。
# [try_files ファイル ... パス;]
# [try_files ファイル ... =コード;]
# try_filesという名前の通り、指定したファイルやディレクトリの存在を順番に調べ、存在すれば、そのファイルやディ
# レクトリに対応したファイルを返します。一つも存在しなかったら、最後に記述したパスに内部リダイレクトします。
# パスの代わりに名前付きロケーション（@名前）を指定することもできます。"=コード"を指定したときには指定した
# 応答コードが返されます。このtry_filesディレクティブはバックエンドのウェブアプリケーションと連携するため
# によく使われます。
# ------------------------------------------------------------------------------------------------
# ドキュメントルート配下を以下の先頭からファイルが存在するか順番に辿る。指定したファイルパスがある場合は
# リダイレクト、ない場合はその次のファイルパスへと繰り返し、最後までない場合は最後に指定されたURI(@api-app
# :webアプリケーション)へとリダイレクト。
# $: 変数を展開している。Nginxではもともと定義されている予約語的な変数がある。今回はほとんど予約語を使っている。
