# 1 @@ こちらはリバースプロキシ先のバックエンドのサーバーの設定 @@
# upstream api-app が無意味かどうか
# 意味がある。Nginxでtry_files $uri/index.html $uri @api-app;が指定されているため、リクエストがRails（Puma）に転送されます。
# 根拠: try_files ディレクティブは、指定されたURIが見つからない場合、@api-app（upstream api-app）に転送する。

# 1.1 userの設定はなくてもデフォルトでnginxユーザーが設定されるが、明示的に記載。
user  nginx;
worker_processes  auto;

# 1.2
error_log  /var/log/nginx/global_error.log warn;
# 1.3
pid        /var/run/nginx.pid;

# 1.4
http {
  # 1.5
upstream api-app {
  # 1.6 このapi-appは、Dockerfileで記述したWORKDIR /api-app
  server unix:///api-app/tmp/sockets/puma.sock fail_timeout=30s;
}

# 2 @@ こちらはNginx（リバースプロシキサーバー）の設定 @@
# server:サーバー情報を定義。デフォルトのバーチャルホストの設定。
server {
  # 2.1 nginxのサーバーの設定
  listen 80;
  # 3
  server_name localhost;
  # 3.1
  access_log /var/log/nginx/access.log;
  # 3.2
  error_log  /var/log/nginx/server_error.log;
  # 3.3
  root /api-app/public;
  # またはnenxt.jsの場合は /usr/src/front/.next
  # .next フォルダや Rails の public フォルダは、静的なファイルを格納する一般的な場所です。
  # 3.4
  proxy_connect_timeout 600;
  proxy_read_timeout    600;
  proxy_send_timeout    600;

  # Nginxが受信可能なリクエストボディの量を指定
  client_max_body_size 100m;

  # error_page:ステータスコードに応じて表示するページを指定
  error_page 404             /404.html;
  error_page 505 502 503 504 /500.html;

  # 5
  # try_files  $uri/index.html $uri @api-app;

  # HTTP通信のタイムアウトを待つ秒数を指定
  keepalive_timeout 600;

  # 6
  location /healthcheck {
      root   /usr/share/nginx/html;
      empty_gif;
      break;
  }

  # 7 try_files:ファイルが存在するかを確認。引数3つ。何もなければ@api-app(puma)へ
  location / {
      try_files $uri @api-app;
  }

  # 4 @@ リバースプロキシ関連の設定（serverコンテキスト内のlocationディレクティブ）@@
  # ディレクティブの{}内はそのディレクティブのコンテキストでさらにディレクティブを記述できる。
  # location /:全てのパスが一致
  # location / {
  #   # 4.1 実際のクライアントのIPアドレスをバックエンドサーバに送るために使用されます。
  #   proxy_set_header X-Real-IP $remote_addr;
  #   # 4.2 クライアントがどのIPアドレスから来たか、そしてリバースプロキシを経由したかどうかをバックエンドサーバに通知します
  #   proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  #   # 4.3 元のホスト名（Host ヘッダーの内容：アプリのドメイン名等）をバックエンドサーバに渡します。
  #   proxy_set_header Host $http_host;
  #   # 4.4 frontサービスの3000番ポートに転送
  #   proxy_pass http://front:3000/;
  # }

  # 管理側（バックエンド）
  # リバースプロキシ関連の設定
  # location /backend/ {
  # location / {
  location @api-app {
    # http://localhost:80/backend/api/v1/tests -> `http://api-app/api/v1/tests`
    # 4.5
    # rewrite ^/backend(/.*)$ $1 break;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    # 4.6 proxy_passにapi-app(upstream)を設定。unixドメインソケット通信なのでポート番号は不要。
    proxy_pass http://api-app;
  }
}

}




# @          @@          @@          @@          @@          @@          @@          @@          @
# ================================================================================================
# nginxの設定ファイルについて
# ------------------------------------------------------------------------------------------------
# Nginxの設定ファイルは、コンテキスト（Context）とディレクティブ（Directive）という2つの主要な要素を使用してサー
# バーの動作を設定します。以下にそれぞれの要素の説明をします。
# ------------------------------------------------------------------------------------------------
# 一番外側がmainコンテキスト。その中にディレクティブを書く。
# 各ディレクティブの中にあるのが、そのディレクティブのコンテキストという構成
# ------------------------------------------------------------------------------------------------
# **コンテキスト（Context）**:
# コンテキストは、設定ファイル内の特定のセクションを指します。Nginxの設定ファイルは階層構造を持ち、異なるコンテキスト
# 内で異なる設定が行われます。設定ファイルの各コンテキストは、特定のタスクや設定グループに関連する設定を含みます。一般
# 的なコンテキストには以下のようなものがあります：
# - `events`: イベント駆動の設定を行うコンテキスト。プロセスの動作や接続の扱いに関する設定を含みます。
# - `http`: HTTPサーバー全体の設定を行うコンテキスト。サーバー全体で共通の設定を指定します。
# - `server`: 個別のHTTPサーバーの設定を行うコンテキスト。ドメインやポートごとの設定を含みます。
# - `location`: 特定のURLパスに対する設定を行うコンテキスト。リクエストのURIに基づく設定を指定します。
# ------------------------------------------------------------------------------------------------
# **ディレクティブ（Directive）**:
# ディレクティブには、セミコロンで終わるものと、{}で終わるものがある。{}はコンテキストを作成する。
# ------------------------------------------------------------------------------------------------
# 一番外側のディレクティブがmainディレクティブ。{}で囲ったのが、その名前を取ったディレクティブ（httpディレクティブ
# 等）。
# ディレクティブにはそれぞれ、記述できるコンテキストが決まっていきす。Httpディレクティプはmainコンテキスト、server
# ディレクティブはhttp コンテキストの中にしか書けません。また、location ディレクティブは server コンテキストか,
# location コンテキストの中にしか書け ません。 ディレクティブの中には、複数の種類のコンテキストに記述できるものもあ
# ります。
# ------------------------------------------------------------------------------------------------
# ディレクティブが複数の階層に記述されている場合は、条件に合う中で最も内側のコンテキストに記述した内容が有効になります
# 。たとえば、アクセスログの出力先を設定する access_log デイレクテイプは、http や server、location コンテキスト
# のいずれにも設定できますが、location コンテキストの条件に合うアクセスの場合は、location コンテキストでのアクセス
# ログの設定が使 用されますし、location コンテキストの条件に合わなければ、server コンテキスト、server コンテキス
# トの条件に合わなければhttp コンテキストの設定が使用されます。
# ------------------------------------------------------------------------------------------------
# 同じ名前のディレクティブが、コンテキストによって別の意味で使われることもあります。たとえば、server というディレク
# ティプは、http コンテキストの中に書かれていれば、バーチャルホストの設定をするコンテキストを作るディレクティプですが
# 、upstream コンテキストの中に書かれていれば、ロードバランサの振り分け先を記述するディレクティプになります。
# ------------------------------------------------------------------------------------------------
# ディレクティブは、設定ファイル内で使用されるコマンドや設定の指示です。ディレクティブはコンテキスト内で使用され、特定
# の設定や動作を指定します。設定ファイルのディレクティブは、コンテキストに応じて異なる効果を持ちます。いくつかの一般的
# なディレクティブには以下のようなものがあります：
# - `listen`: サーバーが受け付けるポートを指定します。
# - `server_name`: ドメイン名を指定して、特定のサーバーブロックを識別します。
# - `location`: 特定のURLパスに対する設定を指定します。
# - `proxy_pass`: リバースプロキシとして動作する際に、バックエンドのサーバーを指定します。
# ------------------------------------------------------------------------------------------------
# ディレクティブはその効果を持つコンテキスト内で使用されるため、正しいコンテキスト内でディレクティブを配置することが重
# 要です。設定ファイルのディレクティブはコマンドラインのように一つずつ実行するのではなく、設定全体を定義するためのもの
# です。
# ------------------------------------------------------------------------------------------------
# 総括すると、Nginxの設定ファイルはコンテキストとディレクティブを組み合わせて、サーバーの動作や設定を制御します。コン
# テキストは設定の階層構造を形成し、ディレクティブは特定の設定を指定します。

# ================================================================================================
# nginxの設定ファイルの読み込み順
# ------------------------------------------------------------------------------------------------
# Nginxの設定ファイルを自作する場合、/etc/nginx/conf.d/以下に作る。名前は任意で最後が.confで終わるように。
# e.g:/etc/nginx/conf.d/hoge.conf
# Nginxの設定ファイルはデフォルトで２つあり、以下の順番で読み込まれます。
# /etc/nginx/nginx.conf、/etc/nginx/conf.d/default.conf
# nginx.confが一番初めに読み込まれる。続いて、nginx.confファイル内で、nginx/conf.d以下を読み込む(include)。

# ================================================================================================
# 1
# . **upstreamの解説**
# - `upstream` ディレクティブは、Nginxがリバースプロキシとして動作する際に、バックエンドサーバーやアプリケーション
# サーバーへの接続方法を指定するために使用されます。バックエンドサーバーの一連のアドレスや設定をまとめて定義することが
# できます。例えば、負荷分散や冗長性の確保などのために複数のバックエンドサーバーを指定することができます。
# -`upstream api-app` ブロックが定義されています。これは `api-app` という名前のバックエンドグループを定義してい
# ます。`server` ディレクティブを使用してバックエンドのサーバーアドレスを指定し、そのサーバーに接続する方法を指定し
# ています。
# - ここで使用されている `unix:///api-app/tmp/sockets/puma.sock` は、Unixソケットを介してバックエンドのアプ
# リケーションサーバーに接続する方法を表しています。
# - `fail_timeout=30s` は、接続がタイムアウトした場合に30秒間隔で再試行することを意味します。
# api-appはこのサーバーに繋ぐという設定
# unixドメインソケット（サーバとクライアントの二者間通信）によるコンテナ間通信をしたいので、puma.sockを指定。
# ------------------------------------------------------------------------------------------------
# . **serverの解説**:
# - `server` ディレクティブは、NginxがHTTPリクエストを受け取った際の振る舞いを設定するために使用されます。Nginxは
# 複数の `server` ブロックを持つことができ、それぞれが異なるドメインやポートに対するリクエストを処理します。
# この`upstream` ディレクティブ内では、リクエストの処理方法やリバースプロキシの設定などが指定されます。
# ------------------------------------------------------------------------------------------------
# このupstreamに付けたapi-appという名前はproxy_passディレクティブで再度使用します。
#  設定ファイルの例では、`server` ブロックが定義されているかどうかは示されていませんが、一般的には `server` ディレ
# クティブの中でドメインやポートの指定、リクエストの処理方法、リバースプロキシの設定、SSL設定などが行われます。
# 提供された設定ファイルの一部を見る限り、`upstream` ディレクティブはアプリケーションサーバーへの接続方法を定義して
# おり、`server` ディレクティブはリクエストの受け取りと処理に関する設定を行う場所であると考えられます。
# ------------------------------------------------------------------------------------------------
# Unixドメインソケットの設定
# upstreamコンテキストは、バックエンドのアプリサーバーを示すもので、サーバーのipアドレスとポート番号を
# 並べたserverディレクティブを並べて記載し、まとめたものに名前を付ける。
# ------------------------------------------------------------------------------------------------
# upstream:アプリケーションサーバーの指定(バックエンドのアプリケーションサーバPumaとUnixドメインソケット
# 通信で接続する場合は、puma.sock を指定すればOK)。
# puma.rbのソケット設定(puma.sock)の絶対パスを記載。
# ------------------------------------------------------------------------------------------------
# *ソケット＝ざっくりネットワークとの接続の出入り口。機器間の通信やプロセス(プログラムの処理)間の通信に使用
# されるインターフェイス。
# *ソケット通信＝ソケットを利用した、外部のネットワークに繋がるインタフェースに接続する、サーバとクライアント
# の二者間通信。
# *Unixドメインソケット＝カーネル内部で完結する高速なネットワークインタフェースを作成し、ウェブサーバやアプリ
# サーバーとNGINXなどのリバースプロキシとの間、あるいはウェブサーバとデータベースとの間の接続を高速にできる。
# ------------------------------------------------------------------------------------------------
# サーバ（要求を待ち続けるコンピュータ）の中の実行中のプログラムは、通常サーバーソケットと
# データ送受信用のソケットの二つにバインドされる。
# 別のパソコンからサーバーへ通信を開始したい時には、まずアクセスする際は、サーバソケットに対して、通信を投げる。
# サーバソケットから別のパソコンへの返信には、データ送受信用ソケットに関する情報が含まれているのが普通。
# それを受けた別のパソコンは、サーバとデータの送受信が出来るようになる。
# ここでソケットと実行中のプログラムを結びつける事をバインドと言う
# サーバーのIPアドレス（あるいはサイト名）とサーバーソケットのポート番号を指定して通信を開始する
# データ送受信用ソケットは状況に応じて増えたり減ったりする
# ------------------------------------------------------------------------------------------------
# ここのapi-appはDockerfileで記述したWORKDIR /api-app
# ------------------------------------------------------------------------------------------------
# ソケット通信とは
# インターネットはTCP/IPと呼ぶ通信プロトコルを利用しますが、そのTCP/IPをプログラムから利用するには、
# プログラムの世界とTCP/IPの世界を結ぶ特別な出入り口が必要となります。
# その出入り口となるのがソケット(Socket)であり、TCP/IPのプログラミング上の大きな特徴とのことで、
# 普段利用しているHTTP通信もソケット通信
# ------------------------------------------------------------------------------------------------
# Unixドメインソケット:
# 「UNIXドメインソケット」とは、LinuxなどのUNIX系OS（オペレーティングシステム）
# で実行されるプロセス間のデータ通信の終点に使われるインターフェースのことをいう。LinuxなどのUNIX系OSは、
# 各種デバイスの入出力にデバイスファイルというインターフェースを利用するため、
# 一般のファイルを読み書きするのと同じ手順で周辺機器を操作できる。ところが、プロセス同士がネットワーク経由で通信するときには、
# ファイル・インターフェースを拡張した「ソケット」というインターフェースが必要になる。
# 通常インターネットで利用しているソケット通信（INETドメインソケット通信）とは異なり、
# ネットワーク経由ではないローカルマシン上のプロセスが利用するソケットが、UNIXドメインソケットである。
# ------------------------------------------------------------------------------------------------
# Nginxのバーチャルホスト
# 同一のサーバで複数のドメインを振り分けるには、バーチャルホストという仕組みを用います。
# バーチャルホストとは、ドメイン毎にサーバーの処理を振り分けるものです。 ドメイン毎に違う処理を行うので、
# あたかも複数のサーバに見える(仮想的)、というのが名前の由縁なのだと思います。
# バーチャルホストは、一台のサーバーで仮想的に複数のドメインを運用するサーバー技術の一種で、
# 主にメールサーバーやWebサーバーなどで利用されています。
# メールサーバーやWebサーバーを運営する場合、一般的にドメインの数を上回るサーバーを用意することが多いのですが、
# バーチャルホスト機能を利用することで、1つのサーバー上で複数ドメインを同時に運用することができるようになります。
# このため、IPアドレスの節約効果やサーバー機器を減らすことで運用コストの削減などのメリットがあります。

# ================================================================================================
# 1.1
# - ここは一番外側でmainコンテキスト
# main コンテキストには、nginx 全体の動作について記述するディレクティブを書きます。インストール直後の main コンテ
# キストは以下のようになっています。
# 1: user nginx;
# 2: worker_processes 1;
# 3:
# 4: error_log /var/log/nginx/error.log warn;
# 5: pid /var/run/nginx.pid;
# ------------------------------------------------------------------------------------------------
# . `user nginx;`:
# このディレクティブは、Nginxプロセスがどのユーザーとして実行されるかを指定します。この行の設定では、Nginxプロセス
# が `nginx` ユーザーとして実行されることが指定されています。一般的に、セキュリティ上の理由から、Webサーバーなどの
# プロセスは特定のユーザーとして実行され、不要な特権を持たないようにすることが推奨されます。デフォルトでは、多くの
# Unix系システムではNginx専用のユーザー（通常は nginx ユーザー）が設定されており、この設定が省略された場合でもデフ
# ォルトのユーザーが使用されます。
# ------------------------------------------------------------------------------------------------
# . `worker_processes auto;`:
# このディレクティブは、Nginxのワーカープロセスの数を指定します。ワーカープロセスは、リクエストを並行して処理するため
# のプロセスであり、マルチプロセスおよびマルチスレッドのアーキテクチャを持つNginxの特徴です。`auto` と指定すること
# で、システムの利用可能なCPUコア数に基づいて適切なワーカープロセス数が自動的に設定されます。
# この設定が省略された場合、Nginxはデフォルトでワーカープロセスを1つ起動します。

# ================================================================================================
# 1.2
### 各レベルにおける `error_log` と `access_log` の違いと意図
#### メイン設定とHTTPサーバー設定の違い
# . **グローバルエラーログ (`nginx/nginx.conf` トップレベル)**：
# - `error_log /var/log/nginx/error.log warn;` を指定します。
# - これは全てのサーバブロック (`server {}`) を含む Nginx サーバ全体に適用されるグローバルな設定です。
# - warn` レベルは、よりクリティカルな警告とエラーのみをログに記録することを示します。
# - これはどのサーバブロックにも特有ではないグローバルレベルの問題やエラーを捕捉するのに便利です。
# ------------------------------------------------------------------------------------------------
# . **HTTPサーバーブロックのエラーログ (`http` コンテキストの `server {}` ブロック)**：
# - エラーログ /var/log/nginx/error.log;`
# - これは定義されている `server {}` ブロックに固有のものである。
# - このサーバーコンテキスト内でエラーが発生すると、ここにログが記録されます。
# - レベルが指定されていないということは、グローバルレベルが指定されている場合はそれを継承するか、デフォルトのログレ
# ベルである `error` を継承するということです。
# ------------------------------------------------------------------------------------------------
# - error_log`がグローバルコンテキストとサーバコンテキストの両方で同じである場合、冗長性が生じる可能性があります。
# グローバルコンテキストとサーバコンテキストで異なるログファイルを持ちます。グローバルコンテキストには 、
# `/var/log/nginx/global_error.log` を、サーバーコンテキストには `/var/log/nginx/server_error.log` を使
# 用します。

# ================================================================================================
# 1.3
### `pid /var/run/nginx.pid;` 設定
# - Nginx 設定の `pid` ディレクティブは、Nginx マスタープロセスのプロセス ID (PID) が保存されるファイルを指定し
# ます。
# - このディレクティブは `pid /var/run/nginx.pid;` として設定され、PID が `/var/run/nginx.pid` にあるファイル
# に書き込まれることを意味します。
# ------------------------------------------------------------------------------------------------
#### これを使う意図は？
# **プロセス管理**： PIDを知ることで、Nginxプロセスの管理が容易になります。例えば、PIDを使ってNginxを停止、再起動、
# リロードすることができます。
# **モニタリングツール システム監視ツールはしばしばPIDファイルを読み込んで実行中のサービスを追跡します。これにより
# 、より良いヘルスモニタリングと自動リカバリが可能になります。
# **デバッグ**： デバッグやトラブルシューティングの際、PIDはNginxマスタプロセスに特化したアクションを実行するのに役
# 立ちます。

# ================================================================================================
# 1.4
# http` コンテキストでの設定は、そのコンテキスト内のすべてのサーバブロックに影響する設定を一元的に行うことができる。
# http` コンテキストで `upstream` を定義できるため、異なるサーバーブロックでも再利用できる。
# http` コンテキストを持つことで、その中の設定がHTTPトラフィックに特化したものであることを理解しやすくなる。

# ================================================================================================
# 1.5
# . `upstream api-app`
# バックエンドのアプリケーションを識別するための名前を[api-app]で設定しています。この名前は、後でリバースプロキシの
# 設定で使用されます。

# ================================================================================================
# 1.6
# `unix:///api-app/tmp/sockets/puma.sock` という形式の記述において、`///` が三つも含まれているのは、Unixド
# メインソケットを指定する際の正しい記法です。これはUnixドメインソケットのアドレス表記方法に基づいています。
# `unix://` はソケットのアドレス表記のプレフィックスです。
# Unixドメインソケットは、ファイルシステム上の特定のファイルをソケットとして使用する仕組みです。このソケットにアクセ
# スするためのアドレス表記には `unix:///` が使用されます。
# 実際のソケットファイルへのパスが `/api-app/tmp/sockets/puma.sock` である場合、それを表すために 、
# `unix:///api-app/tmp/sockets/puma.sock` と記述します。

# ================================================================================================
# 2
# server というディレクティプは、http コンテキストの中に書かれていれば、バーチャルホストの設定をするコンテキストを
# 作るディレクティプですが、upstream コンテキストの中に書かれていれば、ロードバランサの振り分け先を記述するディレク
# ティプになります。
# このファイルでは、serverディレクティブはserverコンテキストにあり、バーチャルホストを設定している。
# ------------------------------------------------------------------------------------------------
# .**バーチャルホストとは何ですか？
# - バーチャルホストはNginxのような単一のウェブサーバが同じIPアドレス上で複数のウェブサイトをホストすることを可能に
# します。各ウェブサイトはドメイン名、SSL証明書などを含む独自の設定を持つことができます。
# - 理由 バーチャルホスティングは、1つのサーバで複数のサイトやアプリケーションを管理し、リソースを効率的に使用するた
# めに重要です。
# backend/web/nginx.conf` の `server` ブロックは Nginx のバーチャルホスト設定の例です。このブロックは 、
# `localhost` へのリクエストをポート 80 で待ち受けており、ロギングやルートディレクトリなど、そのバーチャルホストに
# 固有の設定を行っています。
# ------------------------------------------------------------------------------------------------
# . **server :
# - `server { ... }` ブロックは、Nginxの設定ファイル内で特定のサーバーを定義するためのものです。これは、リクエス
# トを受け取った際の振る舞いや処理方法を設定するために使用されます。特定のポートやドメイン、パスに対するリクエストを処
# 理するための設定が含まれます。
#    あなたの提供した設定ファイルの例では、`server { ... }` ブロックがNginxサーバーの設定を定義しています。具体的な設定内容は以下のようになります：

# ================================================================================================
# 2.1
# listen:バーチャルホスト(IPアドレスでHTTPリクエストした場合に応答するホスト)が接続を許可するポート番号を定義。
# 別途IPアドレス＋ポート番号の指定も可能:ex.[listen 192.0.2.1:80]
# ------------------------------------------------------------------------------------------------
# iPアドレスのデフォルト値はすべてのインターフェイスアドレスを意味する"*"であり、ポート番号のデフォルト値は"80"にな
# ります。そのため、listenディレクティブを省略すると、次の設定と同じになります。
# listen *:80;
# この設定は次のそれぞれの設定と同じ意味を持ちます。
# listen 80;
# listen *;
# ------------------------------------------------------------------------------------------------
# 一番上に設定した
# server {
#     listen 80;
#     server_name www.test.jp  w3.test.jp;
#     ...
# }
# が特に指定しない場合、デフォルトサーバーになる。

# ================================================================================================
# 3
# server_name:ホスト名の指定。アクセスを受け付けるURLかドメインもしくはIPを指定する。
# localホストはIPアドレスだと、通常は127.0.0.1
# 本番環境は、ロードバランサーのDNS or ローカルでデプロイするなら、localhost
# 例：server_name 52.69.235.20;
# ------------------------------------------------------------------------------------------------
# server_nameディレクティブにはバーチャルサーバの名前を設定します。
# 仮にバーチャルサーバの名前を[server_name example.com]として、ウェブブラウザがウェブサーバに、
# リクエスト先のサーバーのホスト名を"example.com"と指定したリクエストを送った場合、nginxはこのリク
# エストを受け取ると、このホスト名がserver_nameディレクティブに設定したサーバ名に一致するserverディレク
# ティブのバーチャルサーバを選び、そのserverディレクティブ内の設定が適応されます。このようにserver_name
# ディレクティブは名前ベースのバーチャルサーバを設定するために使われます。

# ================================================================================================
# 3.1
# /var/log/nginxは、ログファイルが書き出されるディレクトリ。
# nginxには二つのログファイルがあり、アクセスログ（ブラウザ等からのアクセスを記録する）とエラーログ（発生したエラーの
# みを記録）。
# ------------------------------------------------------------------------------------------------
# access_log:アクセスログの出力先を設定 (/var/log配下だとわかりやすい)
# /var/log/nginx/access.log;がコンテナ内に作成される。
# varディレクトリ:ログファイルやキャッシュファイルなどの一時的なデータを残しおく為のディレクトリ
# tmpディレクトリと違うのは、再起動しても残る。

# ================================================================================================
# 3.2
# nginxには二つのログファイルがあり、アクセスログ（ブラウザ等からのアクセスを記録する）とエラーログ（発生したエラーの
# みを記録）。
# ------------------------------------------------------------------------------------------------
# error_log:エラーログの出力先を設定 (/var/log配下だとわかりやすい)
# エラーが起きたとき:cat /var/log/nginx/error.logを見てデバッグしましょう

# ================================================================================================
# 3.3
# - root:アプリのルートディレクトリ(公開するディレクトリ)を定義。ドキュメントルートの指定。
# - ドキュメントルートはWebサーバーが公開するコンテンツの配置ディレクトリのことです。
# - ドキュメントルートとは、Webサーバにアクセスがあった際に参照するディレクトリのことです。Webサーバーがクライアントか
# らのHTTPリクエストに対して、どのディレクトリ内のファイルを提供するかを示すディレクトリのことです。要するに、Webサー
# バーが公開するコンテンツ（HTMLファイル、画像、CSSファイルなど）が置かれるディレクトリのパスを指します。
# - Webサーバーがリクエストを受け取ると、そのリクエストのURI（Uniform Resource Identifier）に基づいて、ドキュメ
# ントルート内の対応するファイルやディレクトリを探し、クライアントに返します。つまり、ドキュメントルートはWebサーバー
# が公開するコンテンツへのアクセスポイントとなる場所です。
# - 静的ファイル（画像など）のパスをドキュメントルートに設定
# -静的コンテンツは「(Railsアプリケーションのルート)\public\」ディレクトリに格納されています。
# ------------------------------------------------------------------------------------------------
# 「ドキュメントルート」とは、WebサーバーがクライアントからのHTTPリクエストに対して、どのディレクトリ内のファイルを
# 提供するかを示すディレクトリのことです。要するに、Webサーバーが公開するコンテンツ（HTMLファイル、画像、CSSファイル
# など）が置かれるディレクトリのパスを指します。
# ------------------------------------------------------------------------------------------------
# Webサーバーがリクエストを受け取ると、そのリクエストのURI（Uniform Resource Identifier）に基づいて、ドキュメン
# トルート内の対応するファイルやディレクトリを探し、クライアントに返します。つまり、ドキュメントルートはWebサーバーが
# 公開するコンテンツへのアクセスポイントとなる場所です。

# ================================================================================================
# 3.4
# - `proxy_connect_timeout`： プロキシサーバとの接続確立のタイムアウト時間を指定する。値の単位は秒なので、`600`
# は10分を意味する。
# - proxy_read_timeout`：プロキシサーバとの接続のタイムアウト時間を指定する： プロキシサーバからの応答を読み込む
# 際のタイムアウト時間を指定する。このタイマーはプロキシサーバーから新しいデータを受信するたびにリセットされる。
# - `proxy_send_timeout`: プロキシ送信のタイムアウト時間を指定する： プロキシサーバにリクエストを送信する際のタイ
# ムアウト時間を指定する。このタイマはプロキシされたサーバに新しいデータが送信されるたびにリセットされる。
# ------------------------------------------------------------------------------------------------
#### その使用意図とは？
# . **接続の信頼性**： 接続やデータ転送が確立または完了するまでに、サーバーが十分な時間待機することを保証し、接続が
# 早期に切断される可能性を低減します。
# . **リソース管理 タイムアウトが短すぎると操作に失敗する可能性があり、長すぎるとリソースを占有する可能性があります。
# これらの設定は、バランスをとることを目的としています。
# . **エラー処理**： エラー処理**：タイムアウトエラーが返されるまでに十分な時間を与えることで、ネットワークの問題を
# 診断するのに役立つ。

# ================================================================================================
# 4
# locationディレクティブ
# ------------------------------------------------------------------------------------------------
# 一般的に、next.jsとrails(api)に対して、両方の前段にnginxを配置します。
# 根拠: nginxはリバースプロキシとして機能し、クライアントからのリクエストを適切なバックエンド（ここではNext.jsや,
# Rails API）にルーティングする役割を持つため。
# 一般的にクライアントからのリクエストはnginx -> Next.js -> Rails(API) の順に流れます。
# ------------------------------------------------------------------------------------------------
# locationの設定について: 両方の設定（Next.jsとRails）が必要です。
# 根拠: nginxは単にリバースプロキシであり、どのリクエストがAPI（Rails）に行くべきか、どれがフロントエンド（Next.
# js）に行くべきかを判別する必要があります。
# ------------------------------------------------------------------------------------------------
# locationディレクティブは、引数に指定されたパス名に対応するコンテキストを作る。複数の書式あり。
# [location パス名]という書式は前方一致（語頭部分以下は全て任意）させる書式。
# ex.[location / ]:すべてのパスが一致
# ex.[location /files/ ]:/files/で始まるすべてのパスが一致
# ------------------------------------------------------------------------------------------------
# locationディレクティブではURIのパス毎の設定を記述できます。括弧{ }で囲まれた部分がlocationコンテキスト
# になります。リクエストURIのパスがこのlocationディレクティブのパスの条件に一致した場合にこのlocationコン
# テキストに記述した設定が適応されます。パスの条件の評価方法は前方一致と正規表現の2つです。
# ------------------------------------------------------------------------------------------------
# locationディレクティブではURIのパスの代わりに@の後に名前を付けることにより、名前付きロケーションを作ること
# ができます。この名前付きロケーションは内部リダイレクトで使用します。
# ------------------------------------------------------------------------------------------------
# 普通のリダイレクト（HTTPリクエストの達成に追加処理が必要なときに返される）はレスポンスコード（３桁の数字）に
# 301や302を、Locationヘッダフィールドにリダイレクト先のURIを指定して返し、クライアントはそのURIに対して再び
# リクエストを送ります。これとは別に内部リダイレクトというものがあります。これは、レスポンスコードに301や302を
# 指定せずに、内部的にURIのパスの書き換えを行い、その結果のページの内容を返します。クライアントから見るとリダイ
# レクトしているようには見えません。nginxではこのような内部リダイレクトがよく使われます。
# ------------------------------------------------------------------------------------------------
# indexディレクティブ、error_pageディレクティブ、tri_filesディレクティブではこの内部リダイレクトが使われます。
# 内部リダイレクトではリダイレクト先のパスに対して毎回locationディレクティブの評価が行われます。なお、この名前
# 付きロケーションはserverコンテキストにしか記述できません。
# 今回の例では、リクエストURIのパスの先頭が"@api-app"に一致した場合に適応されます。
# *パスの一致条件が少々複雑なので注意。

# ================================================================================================
# 4.1
### . `proxy_set_header`
# - `proxy_set_header`はNginxでリバースプロキシを設定する際に使用します。
# - リクエストがプロキシサーバ（Nginx）を経由してバックエンド（Rails等）に到達するとき、このディレクティブで指定さ
# れたHTTPヘッダーを追加・書き換えします。
# ------------------------------------------------------------------------------------------------
### . `proxy_set_header`の引数の解説
# - 第一引数: 追加または変更するHTTPヘッダーの名前
# - 第二引数: ヘッダーに設定する値／特定の変数（`$remote_addr`など）を使用できます。
# -----------------------------------------------------------------------------------------------
### . `X-Real-IP`の解説
# - `X-Real-IP`は元のクライアントのIPアドレスを保存するためのカスタムHTTPヘッダーです。
# - リバースプロキシを使用している場合、バックエンドが実際のクライアントのIPを知るために用います。
# ------------------------------------------------------------------------------------------------
### . `$remote_addr`の解説
# - `$remote_addr`はNginx変数で、リクエストを行ったクライアントのIPアドレスを保持します。
# - `proxy_set_header X-Real-IP $remote_addr;`とすることで、バックエンドがこのIP情報を把握できます。
# - 明示的に設定しなくても、Nginxが自動で設定します。

# ================================================================================================
# 4.2
# . X-Forwarded-For
# - HTTPヘッダーの一つ。。クライアントのIPアドレス情報をサーバーに伝える役割。リバースプロキシやロードバランサーを
# 経由する際に用いられる。
# - LB（ロードバランサー）や、リバースプロキシによる代理アクセスなど、IPヘッダのソースIPアドレスがクライアントのIPア
# ドレスからその中継機器のIPアドレスに置き換えられてしまう場合に、クライアントのIPアドレスをバックエンドサーバが取得
# できるよう、中継機器が設定するリクエストヘッダです。クライアントのIPアドレスと、中継した機器のIPアドレスを配列とし
# て格納します。
# ------------------------------------------------------------------------------------------------
# . $proxy_add_x_forwarded_for
# - Nginx変数。X-Forwarded-ForヘッダーにプロキシサーバーのIPを追加する。nginx.confによく設定されるが、基本的に
# デフォルトで設定される。
# ------------------------------------------------------------------------------------------------
# $proxy_add_x_forwarded_forの具体的な値:
# 例: クライアントIPが "192.168.0.1"、NginxのサーバーIPが "203.0.113.1" の場合
# X-Forwarded-For: 192.168.0.1, 203.0.113.1
# *複数のプロキシを経由する場合、カンマ区切りでIPが追加されます。

# ================================================================================================
# 4.3
# . Host
# - HTTPヘッダーの一つ。Hostリクエストヘッダーは、リクエスト送信先のサーバーのホスト名とポート番号を指定する。ドメ
# イン名やIPアドレス、ポートを含むことがある。
# ------------------------------------------------------------------------------------------------
# . $http_host
# - Nginx変数。HTTPのHostヘッダーの内容を保持。nginx.confで特に設定しなくても自動的に取得される。
# - ここには、クライアント(user)がリクエストを送信した際のホスト名（アプリのドメイン名）が格納される。

# ================================================================================================
# 4.4
# front:doxker-composeのサービス（コンテナ）名
# [localhost:/]に来たら、frontサービスコンテナの3000番ポートと接続
# ------------------------------------------------------------------------------------------------
# . `proxy_pass`の解説:
# - `proxy_pass`ディレクティブは、Nginxが受け取ったHTTPリクエストをリバースプロキシ先（向こうの）のサーバーに転送
# するために使用されます。具体的には、リバースプロキシが受け取ったリクエストを指定されたアップストリームやURLにリダイ
# レクトする役割を果たします。
# - `proxy_pass`は、指定されたURLへリクエストを転送します。
# - この場合、`http://front:3000/`と設定されているので、リクエストはこのURLに転送されます。
# ------------------------------------------------------------------------------------------------
# . `proxy_pass http://front:3000/`でなぜ設定できるのか、コンテナのサービス名は？
#   - この設定ができる理由はDocker Composeによって定義されたサービス名を使用しているからです。
#   - `docker-compose.prod.yml`の`services`セクションで`front`という名前のサービスが定義されています。これに
# より、`front`はDocker内部のDNSに登録され、この名前で解決できます。
#   - ポートは3000に設定されているので、`http://front:3000/`とすることでNginxからそのサービスにアクセスできます。
# ------------------------------------------------------------------------------------------------
# 具体的な変換の流れ：
#   - ユーザーがアクセスした際に、Nginx（`nginx-ctr-prod`コンテナ）がリクエストを受け取ります。
#   - `location /`の設定によって、そのリクエストは`http://front:3000/`に転送されます。
#   - `front:3000`は、`docker-compose.prod.yml`で定義された`front`サービス（`nextjs-ctr-prod`コンテナ）
# の3000番ポートを指しています。
#   - したがって、実際のリクエストは`nextjs-ctr-prod`コンテナの3000番ポートに転送されることになります。
# ------------------------------------------------------------------------------------------------
# このようにDocker Composeの設定とNginxの`proxy_pass`が連携して、リバースプロキシとして機能します。
# ------------------------------------------------------------------------------------------------
# Docker内部のDNS（Domain Name System）とは、Dockerエンジンに組み込まれている名前解決システムです。この機能によ
# って、コンテナ間の通信が容易になります。
# 具体的には：
# - Docker Composeで定義したサービス名（この場合は`front`）が自動的にDocker内部のDNSサーバに登録されます。
# - この名前（`front`）を使って他のコンテナ（この場合はNginxコンテナ）からアクセスすると、Docker内部のDNSサーバが
# 対応するコンテナのIPアドレスに解決してくれます。
# この仕組みにより、コンテナのIPアドレスを直接指定する必要がなく、サービス名で簡単に通信相手を指定できます。

# ================================================================================================
# 4.5
# . `rewrite ^/backend(/.*)$ $1 break;` の意図と解説
# - `rewrite` ディレクティブは、URLのパスを書き換えます。
# - `/backend/` で始まるURLを受け取ったとき、`/backend` 部分を削除（または置き換え）して、バックエンドアプリケ
# ーションに正確なルートを指定するために使用されます。
# - **正規表現**: `^/backend(/.*)$`
# URLが `/backend` で始まる場合にマッチします。
# `(.*)` は `/backend` の後にくる任意の文字列をキャプチャします。
# - **置換**: `$1`
# `(.*)` でキャプチャした部分（`$1`）に置き換えられます。
#### 具体例
# - 元のURL: `http://localhost:80/backend/api/v1/tests`でアクセス
# - リライト後: `/api/v1/tests`
# - 最終的なプロキシパス: `http://api-app/api/v1/tests`
# - 設定したリライトルールによって `/backend` 部分が取り除かれ、その後でバックエンド（Rails API）にプロキシされま
# す。

# ================================================================================================
# 5
# try_filesディレクティブには存在をチェックするファイルやディレクトリと存在しなかったときにリダイレクトする
# URIのパスを指定します。記述方法は次の通りです。
# [try_files ファイル ... パス;]
# [try_files ファイル ... =コード;]
# try_filesという名前の通り、指定したファイルやディレクトリの存在を順番に調べ、存在すれば、そのファイルやディ
# レクトリに対応したファイルを返します。一つも存在しなかったら、最後に記述したパスに内部リダイレクトします。
# パスの代わりに名前付きロケーション（@名前）を指定することもできます。"=コード"を指定したときには指定した
# 応答コードが返されます。このtry_filesディレクティブはバックエンドのウェブアプリケーションと連携するため
# によく使われます。
# ------------------------------------------------------------------------------------------------
# ドキュメントルート配下を以下の先頭からファイルが存在するか順番に辿る。指定したファイルパスがある場合は
# リダイレクト、ない場合はその次のファイルパスへと繰り返し、最後までない場合は最後に指定されたURI(@api-app
# :webアプリケーション)へとリダイレクト。
# $: 変数を展開している。Nginxではもともと定義されている予約語的な変数がある。今回はほとんど予約語を使っている。

# ================================================================================================
# 6
# root /usr/share/nginx/htmlの理由:
# デフォルトの場所: /usr/share/nginx/html はNginxがインストールされた際のデフォルトの公開ディレクトリです。した
# がって、特別な設定を行わない限り、このディレクトリが使われることが一般的です。
# 標準的な設定: このパスはNginxのデフォルト設定でよく用いられるため、他のシステム管理者や開発者が見たときにすぐに理
# 解できるという利点があります。
# ------------------------------------------------------------------------------------------------
#### 各行の説明
# - root /usr/share/nginx/html;`： ヘルスチェックファイルのあるルートディレクトリを指定する。healthcheck`への
# リクエストはこのディレクトリのファイルを探す。
# - empty_gif;`： このディレクティブは空の GIF 画像をレスポンスとして送ります。ヘルスチェックエンドポイントのレス
# ポンスサイズを小さくするためによく使われます。
# EC2でELB（“Elastic Load Balancing”：ロードバランサー）を利用すると、HealthCheck（ヘルスチェック）が求められ
# 何かしらのファイルが必要になります。そんな時に便利な「empty_gif」というnginxの標準モジュールが持つ便利機能があり
# ます。これはnginxの標準モジュールが持つ機能で、nginxがメモリに保持している1x1ピクセルの透過 GIF ファイルをクラ
# イアントに返すことができます。
# - break;`： このディレクティブはそれ以降の処理を停止し、現在のリクエストを終了します。このコンテキストでは、空の
# GIF を送信した後にそれ以上の処理が行われないようにします。

# ================================================================================================
# 7
# - location / { try_files $uri @myapp; }`.
# - location /`： このディレクティブはルート URL (`/`) とそのすべてのサブパスへのリクエストに応答する方法を定義し
# ます。
# - try_files $uri @myapp;`： この行は、Nginxが最初に `$uri` 変数で指定されたファイルを直接提供しようとするこ
# とを意味します。そのファイルが見つからない場合は、リクエストを `@myapp` ロケーションブロックに渡します。
# ------------------------------------------------------------------------------------------------
# try_filesディレクティブには存在をチェックするファイルやディレクトリと存在しなかったときにリダイレクトする
# URIのパスを指定します。記述方法は次の通りです。
# [try_files ファイル ... パス;]
# [try_files ファイル ... =コード;]
# try_filesという名前の通り、指定したファイルやディレクトリの存在を順番に調べ、存在すれば、そのファイルやディ
# レクトリに対応したファイルを返します。一つも存在しなかったら、最後に記述したパスに内部リダイレクトします。
# パスの代わりに名前付きロケーション（@名前）を指定することもできます。"=コード"を指定したときには指定した
# 応答コードが返されます。このtry_filesディレクティブはバックエンドのウェブアプリケーションと連携するため
# によく使われます。
# ------------------------------------------------------------------------------------------------
# ドキュメントルート配下を以下の先頭からファイルが存在するか順番に辿る。指定したファイルパスがある場合は
# リダイレクト、ない場合はその次のファイルパスへと繰り返し、最後までない場合は最後に指定されたURI(@api-app
# :webアプリケーション)へとリダイレクト。
# $: 変数を展開している。Nginxではもともと定義されている予約語的な変数がある。今回はほとんど予約語を使っている。
# ------------------------------------------------------------------------------------------------
# - 具体的な例
# - ユーザーが `http://localhost/css/style.css` をリクエストすると、Nginx は `root` ディレクティブで指定され
# たフォルダ (`/api-app/public`) にある `style.css` ファイルを探します。ファイルが存在すれば、Nginx はそれを直
# 接提供します。
# - ユーザーが `http://localhost/some-page` をリクエストし、`some-page` が `/api-app/public` にファイルと
# して存在しない場合、Nginx は `@api-app` ロケーションブロックにリクエストを転送します。
# - この設定により、Nginxは静的ファイルが存在する場合は効率的に提供し、より複雑なリクエストはアプリケーションサーバー
# に委譲することで、パフォーマンスと機能のバランスをとることができます。