# 7

# 2 alpine:Linuxのディストリビューション。軽量なAlpine上でNodeJSのv16系を動かす。
FROM node:19.4.0-alpine AS deps
# 3
RUN apk add --no-cache libc6-compat
WORKDIR /usr/src/front
# 3.1 packeg.jsonとpackage-lock.jsonのみコピーする
COPY package*.json ./
# 4 本番用のnode_modulesを作成
RUN npm ci

# Build環境
FROM node:19.4.0-alpine AS builder
WORKDIR /usr/src/front
# 4.1 depsの/usr/src/front/node_modulesを builderのnode_modulesにコピー。
COPY --from=deps /usr/src/front/node_modules ./node_modules
# 4.2 ローカルのfrontディレクトリをWORKDIRへコピー。node_modulesはコピーされない。
COPY . .
ENV NEXT_TELEMETRY_DISABLED 1
# 5 npm run build:.nextフォルダが作成。.nextフォルダに本番アプリケーションがビルドされる。
RUN npm run build

# 実行環境
# runner ステージでは最終的なイメージに含めたいものだけの抽出を行ないます。
FROM node:19.4.0-alpine AS runner
WORKDIR /usr/src/front
# node.jsの本番環境
ENV NODE_ENV production
ENV NEXT_TELEMETRY_DISABLED 1
# 5.1 publicディレクトリにはアイコン等の公開ファイルが入っています。
COPY --from=builder /usr/src/front/next.config.js ./next.config.js
COPY --from=builder /usr/src/front/.next ./.next
COPY --from=builder /usr/src/front/.env.production.local ./.env.production.local
COPY --from=builder /usr/src/front/public ./public
COPY --from=builder /usr/src/front/package.json ./package.json
COPY --from=builder /usr/src/front/package-lock.json ./package-lock.json
COPY --from=deps /usr/src/front/node_modules ./node_modules
EXPOSE 80
# 6
# COPY --from=builder --chown=nextjs:nodejs /usr/src/front/.next/standalone ./
# COPY --from=builder --chown=nextjs:nodejs /usr/src/front//.next/static ./.next/static
# 不要なものが取り除かれたnode_modulesをプロダクションにコピーする
CMD [ "npm", "start" ]

# @          @@          @@          @@          @@          @@          @@          @@          @
# 1
#  マルチステージ・ビルドを使用すると、1つの Dockerfile で複数のビルドステージを定義できます。
# アプリケーションのbuild環境と実行環境を分離して、実行環境には最終的な成果物だけを配置することによりimageサイズの
# 縮小を図ります。
# ------------------------------------------------------------------------------------------------
# 通常、Next.js の Docker Image を作成する場合は下記ファイルが必要となります
# - ビルド成果物
# /.next/
# - スタティックファイル
# /public/
# - 依存パッケージ
# /node_modules/
# - 設定ファイル
# /next.config.js
# ------------------------------------------------------------------------------------------------
# アプリケーションの依存パッケージのインストール、build環境と,実行環境を分離して、実行環境には最終的な成果物だけを配
# 置することによりimageサイズの縮小を図ります。
# ------------------------------------------------------------------------------------------------
# 「2番目のステージで、1番目のステージで生成したものの中から必要なものだけコピーして、あとは放置」
# マルチステージビルドを行うには、Dockerfile 内にFROM行を複数記述します。 各FROM命令のベースイメージは、それぞれ
# に異なるものとなり、各命令から新しいビルドステージが開始されます。 イメージ内に生成された内容を選び出して、一方から
# 他方にコピーすることができます。 そして最終イメージに含めたくない内容は、放っておくことができます。

# ================================================================================================
# 2
# Node.js v16がプリインストールされたAlpine Linuxベースのイメージを使用。軽量で高速な環境を提供する。
# ------------------------------------------------------------------------------------------------
# デフォルトではステージに名前はつきません。 そこでステージを参照するには、ステージを表わす整数値を用います。
# この整数値は、最初のFROM命令を 0 として順次割り振られるものです。 ただしFROM命令にAS <NAME>の構文を加えれば、
# ステージに名前をつけることができます。
# ------------------------------------------------------------------------------------------------
# マルチステージビルドの利用にあたって、ステージのコピーは Dockerfile 内での直前のステージだけに限定されるもの
# ではありません。 COPY --from命令では別のイメージからコピーすることができます。 その際にはローカルや Docker
# レジストリ上のイメージ名、タグ名、あるいはタグ ID を指定します。 Docker クライアントは必要なときにはイメージ
# を取得します。 そしてそこから構築内容をコピーします。
# e.g:[COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf]

# ================================================================================================
# 3
# node:alpineで不足しがちな共有ライブラリを追加
# ------------------------------------------------------------------------------------------------
# apk:Alpine Linuxで使用できる、パッケージ管理コマンド。aptみたいなもの。
# apk add:インストールする。
# --no-cache:キャッシュを削除。
# ------------------------------------------------------------------------------------------------
# Alpine LinuxベースでDockerイメージを作るとき、 apk add でパッケージインストールする前に apk update
# しないといけない。これは次のように一行で書ける。
# apk --update add
# ただ、これは /var/cache/apk/ にキャッシュを生成する(.tar.gz 形式のファイル)。
# 続いてDockerイメージは可能な限り小さくしたいので、キャッシュを削除する為、
# rm -rf /var/cache/apk/*
# するところを、--no-cache オプションを使うことで、キャッシュを削除してくれる。
# apk --no-cache add
# ------------------------------------------------------------------------------------------------
# libc6-compat:ライブラリパッケージ
# よくある問題として、process.dlopen を使用するために必要な共有ライブラリが不足していることがあります。足りな
# い共有ライブラリをイメージに追加するには、Dockerfile に libc6-compat パッケージを追加することが推奨されます。
# libc6-compatはGNU C Library（glibc）の互換ライブラリ。
# Alpineは軽量だが、glibcと完全互換ではない。glibc依存のパッケージが動作するようにlibc6-compatをインストール。
# 意図: GNU Cライブラリ（glibc）に依存するパッケージと互換性を持たせる。

# ================================================================================================
# 3.1
# : package.jsonとpackage-lock.jsonをホストからコンテナの/usr/src/frontディレクトリにコピー。
# *はワイルドカードだが、結果としてpackeg.jsonとpackage-lock.jsonのみコピーしている
# ------------------------------------------------------------------------------------------------
# - 意図: 依存関係の情報をコピーして、後のステージでnpm ciを実行する準備。依存関係のリストだけ先にコンテナに持って
# 行くことで、後のステップがキャッシュを効かせやすくなります。
# `RUN npm ci`: `npm ci` コマンドは、`package-lock.json` に記載されている正確なバージョンのパッケージをインス
# トールします。
# `package-lock.json` から生成される `node_modules` ディレクトリは確定的（deterministic）であり、本番環境で
# の動作を開発環境と同じに保証します。
# この２つのステップを合わせて使うことで、より高速かつ確定的なビルドが可能になります。
# 特に`npm ci`は`package-lock.json`を元に依存パッケージをインストールするため、開発環境と本番環境での挙動の違い
# を最小限に抑えられます。

# ================================================================================================
# 4
# npm ci は、yarn --frozen-lockfileと同じ意味
# . --frozen-lockfile 依存パッケージのバージョンが完全に固定化される
# . --production dependencies のパッケージのみインストール
# ------------------------------------------------------------------------------------------------
# npm ci は下記の動作をします
# node_modules ディレクトリ（パッケージが入っている場所）の削除
# package-lock.json と package.json の整合性のチェック
# package-lock.json から node_modules を再現
# 本番環境用の node_modules ディレクトリを作成
# *npm ciはnpm installと同様に依存パッケージをダウンロードします。npm installとの違いはpackage-lock.jsonの
# 更新をしないことで、これによって開発時とプロダクション時のコードの差がなくなります。
# *通常のnpm installは、その時点で改めてpackage.jsonの記載からインストールする。その時、アップデートが必要なも
# のがあった場合、アップデートしてしまうので、開発時とパッケージのバージョンが変わる可能性がある。それを防ぐ。
# ------------------------------------------------------------------------------------------------
# --only=production オプションでプロダクション環境では不要なdevDependenciesなパッケージを削除しimageサイズ
# を抑えることができます。

# ================================================================================================
# 4.1
# . `--from=deps` の意味は？
# この命令は、別のビルドステージからファイルをコピーする際に使用されます。ビルドステージは、Dockerfile 内で `FROM`
# 命令で指定されたコンテナイメージのコピー元を示すものです。
# `--from=deps` は、ビルドステージの名前（ここでは `deps`）を指定して、そのビルドステージからファイルをコピーする
# ことを示しています。
# 具体的には、このコマンドは `deps` ビルドステージから `/usr/src/front/node_modules` ディレクトリの内容を現在
# のビルドステージ（ここでは `builder` ビルドステージ）の `./node_modules` ディレクトリにコピーします。
# これにより、依存関係の解決済み `node_modules` ディレクトリがビルドステージに含まれ、ビルドされるアプリケーション
# に必要な依存関係が含まれることになります。
# つまり、アプリケーションのビルドステージで `deps` ビルドステージの `node_modules` を再利用し、その後のアプリケ
# ーションのビルドや実行に使用することが狙いです。これにより、ビルドプロセスの効率化とイメージサイズの削減が図られます。

# ================================================================================================
# 4.2
# - ローカルの`front`ディレクトリが`WORKDIR`へコピーされます。
# - `.dockerignore`に`node_modules`が指定されているので、ローカルの`node_modules`はコピーされません。
# - `deps`ステージで生成された`/usr/src/front/node_modules`が`COPY --from=deps`によって`builder`ステージ
# にコピーされ、そのまま使用されます。
# このような設計にすることで、依存関係のインストールを一度だけ行い（`deps`ステージ）、その結果を後続のステージの
# （`builder`、`runner`）で再利用することができます。これによりビルド速度が向上し、また依存関係が確定的に管理され
# ます。

# ================================================================================================
# 5
# 開発時は npm run dev で自動ビルドまでセットになった開発サーバーを起動しましたが、リリース用にはnpm run build
# で明示的にサーバーをビルドし、その内容を npm start の本番サーバーでホスティングします。
# ------------------------------------------------------------------------------------------------
### 挙動
# . **最適化**: コードが最適化され、不必要なデバッグ情報が削除されます。
# . **静的サイト生成（SSG）**: `getStaticProps`や`getStaticPaths`が使われているページはビルド時にHTMLが生成
# されます。
# . **サーバーサイドレンダリング（SSR）**: `getServerSideProps`を用いたページは、サーバーサイドレンダリング用の
# コードが生成されます。
# . **API Routes**: `pages/api` ディレクトリ内のAPIエンドポイントがコンパイルされます。
# ------------------------------------------------------------------------------------------------
### 作成されるファイル
# - `.next/`: ビルド成果物がこのディレクトリに格納されます。
#   - `cache/`: ビルドキャッシュが保存されます。
#   - `server/`: SSR用のファイルが格納されます。
#   - `static/`: SSGや画像、フォントなどの静的ファイルが格納されます。
#   - `routes-manifest.json`: ルーティング情報が格納されます。

# ================================================================================================
# 5.1
# なぜランナーステージでこれらのCOPYステップが必要なのでしょうか？
# next.config.js: これはNext.jsの設定ファイルです。Next.jsが本番環境でアプリケーションを実行する方法を理解するた
# めに必要です。
# .nextフォルダ： ビルドされたNext.jsアプリケーションの格納場所です。アプリケーションの実行に不可欠なすべてのHTML、
# CSS、JSファイルが含まれています。
# publicフォルダ： このディレクトリには通常、画像やアイコンなどの静的アセットが含まれます。
# package.json： このファイルには、さまざまなスクリプトや設定とともに、npmパッケージのリストが含まれています。
# Next.jsは、このファイルを使ってアプリケーションを実行する「スタート」スクリプトを特定します。
# node_modules： このフォルダには、Next.jsアプリケーションの実行に必要なすべてのnodeパッケージが含まれます。
# ------------------------------------------------------------------------------------------------
# - マルチステージビルド： マルチステージビルドを使用することで、より小さく最適化されたDockerイメージを作成することがで
# きます。ランナーステージに必要なファイルのみをコピーすることで、最終的なイメージサイズを可能な限り小さくすることがで
# きます。
# - 懸念の分離： このセットアップでは、ビルド時の要件と実行時の要件を明確に区別します。そうすることで、"使用するものだけ
# を含める "という原則を守っている。
# - プロダクション最適化： このセットアップは、本番環境用に特別に調整されており、本番環境に必要なファイルだけが含まれる
# ようになっています。
# - 再利用性と保守性: Dockerfileをこのように構造化することで、アプリケーションの他の部分に影響を与えることなく、コン
# ポーネントのデバッグ、更新、変更が容易になります。

# ================================================================================================
# 6
# standalone機能
# Next.jsは、node_modulesにあるファイルを含む、デプロイに必要なファイルのみをコピーするスタンドアロンフォルダを自
# 動的に作成することができます。
# このモードが有効になった状態でビルドすると、.nextディレクトリ下にstandaloneフォルダが作成されます。このフォルダ
# の下には、node_modulesから、使用するファイルのみがコピーされ、さらにnext startコマンドの代わりに使用できる最小
# 限のserver.jsファイルが生成されます。要するに、自動的にstandaloneフォルダが作成され、その中に動作に必要な最小限
# のファイル群がコピーされるという便利な機能です。この機能によってビルドサイズを削減できます。

# ================================================================================================
# 7
# 基本的な流れ
# package.jsonとpackage-lock.jsonを含めて全てコピー
# npm ciで、 node_modules ディレクトリの削除、package-lock.json と package.json の整合性のチェック
# package-lock.json から node_modules を再現
# npm build
# npm start
# ------------------------------------------------------------------------------------------------
# 第一段階
# FROM node:16-alpine
# WORKDIR /usr/src/front
# COPY . .
# RUN npm install
# RUN npm run build
# EXPOSE 8080
# CMD [ "npm", "start" ]
# ------------------------------------------------------------------------------------------------
# 第二段階

# # 依存パッケージのインストール
# FROM node:16-alpine deps
# WORKDIR /usr/src/front
# # packeg.jsonとpackage-lock.jsonのみコピーする
# COPY package*.json ./
# RUN npm ci --only=production

# # Build環境
# FROM node:16-alpine as builder
# WORKDIR /usr/src/front
# COPY . .
# # depsステージでインストールしたパッケージをコピーする
# RUN npm ci
# RUN npm run build

# # 実行環境
# FROM node:16-alpine
# WORKDIR /usr/src/front
# ENV NODE_ENV production
# # ファビコンが格納されたディレクトリをコピーする
# COPY --from=builder /app/public ./public
# # buildによって.next配下に生成されたhtml、JSON、JSファイルをコピーする
# COPY --from=builder /app/.next ./.next
# COPY --from=builder /app/package.json ./package.json
# EXPOSE 8080
# CMD [ "npm", "start" ]
# ------------------------------------------------------------------------------------------------
# 通常、Next.js の Docker Image を作成する場合は下記ファイルが必要となります
# ビルド成果物
# /.next/
# スタティックファイル
# /public/
# 依存パッケージ
# /node_modules/
# 設定ファイル
# /next.config.js