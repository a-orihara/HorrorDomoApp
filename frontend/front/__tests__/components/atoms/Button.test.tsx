// frontend/front/__tests__/components/atoms/Button.test.tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import Button from '../../../src/components/atoms/Button';

// 1.1
describe('Button', () => {
  test('buttonが存在すること', () => {
    render(<Button>Click me</Button>);
    const buttonElement = screen.getByRole('button');
    expect(buttonElement).toBeInTheDocument();
  });
  // 1.2
  test('指定したテキストを持つこと', () => {
    // 3
    render(<Button>Click me</Button>);
    // 4
    const buttonElement = screen.getByRole('button', { name: /click me/i });
    // 5
    expect(buttonElement).toBeInTheDocument();
  });

  test('クリックイベントに反応すること', async () => {
    // 2
    const mockClick = jest.fn();
    render(<Button onClick={mockClick}>Click me</Button>);
    const buttonElement = screen.getByRole('button', { name: 'Click me' });
    // 6
    await userEvent.click(buttonElement);
    // 7
    expect(mockClick).toHaveBeenCalled();
  });

  // 8
  test('指定したクラスを持つ', () => {
    render(<Button className='test-button'>Click me</Button>);
    const buttonElement = screen.getByRole('button', { name: /click me/i });
    expect(buttonElement).toHaveClass('test-button');
  });
});

/*
@          @@          @@          @@          @@          @@          @@          @@          @
1.1
- describe は Jest テストフレームワークの関数
- 引数を2つ取る。「テスト・スイートあるいはテスト・グループを表す文字列。」と、「コールバック関数」で、関連する複数
のテスト (test や it ブロック) を定義したりグループ化したりすることができます。
- 一般的な使い方： 関連するテストをひとまとめにするために describe を使う。テストスイートがより読みやすく構造化さ
れます。テストをグループ化することで、 describe ブロック内の beforeEach、afterEach、beforeAll および,
afterAll フックで共有する状態や振る舞いを設定することができ、 テストのセットアップと破棄のプロセスを最適化する。

================================================================================================
1.2
test
jestのtest関数。第一引数にテストの文章、第二引数にテストの内容を記述するアロー関数を渡します。
------------------------------------------------------------------------------------------------
ネイティブのHTMLの`button`要素ではなく、コンポーネントのテストなので、`Button`コンポーネントをテストします。
あなたの `Button` コンポーネントには、ネイティブの `button` 要素にはない追加機能やスタイリングが含まれています。
Button`コンポーネントをテストすることで、あなたのコンポーネントの特定の実装が期待通りに機能していることを確認するこ
とができます。
また、`Button`コンポーネントをテストすることで、（`onClick`ハンドラのような）プロップを基礎となる`button`要素に
正しく渡しているかどうかも検証できます。
この方法は、より柔軟で将来性のある方法です。もし後で `Button` コンポーネントにさらに機能やプロップを追加することに
なったとしても、すでにテスト戦略は出来上がっているはずです。

================================================================================================
2
jest.fn()はJestのモック関数を作成するための関数。関数の呼び出しや戻り値などを追跡することができます。
jest.fn()の戻り値は関数です。mockClickという名前の関数を生成。
`jest.fn()` は Jest が提供するモック関数を作成するためのユーティリティです。関数が呼び出される頻度や引数、戻り値な
どをテストしたい場合に特に便利です。
------------------------------------------------------------------------------------------------
モック関数
テスト中に実際の関数の振る舞いを模倣するために使用される、仮の関数。
異なるテストフレームワークでは「スパイ」や「スタブ」とも呼ばれ、テスト目的で実際の関数の動作をシミュレートする関数で
す。制御された環境で、関数間の相互作用をテストするために使われます。モック関数は、特定の値を返したり、エラーをスロー
したり、あるいは入力に基づいて動的に応答するようにプログラムすることができます。また、関数の呼び出しと、その呼び出し
で渡された引数を追跡し、テストでアサートすることもできます。これにより、実際の実装や副作用に必ずしも依存することなく
、関数が正しく呼び出されていることを検証することができる。

================================================================================================
3
render
React Testing Libraryのrender関数。テスト対象のコンポーネントをレンダリングします。これはきちんとレンダリング
されているか確認するテスト。
------------------------------------------------------------------------------------------------
これは、"Click me "というテキストを子として持つ`Button`コンポーネントをレンダリングするためにReactで使用されるJ
SX（JavaScript XML）式です。
JSXを使えば、JavaScript/TypeScriptファイルにHTMLのような構文を書くことができ、ReactはそれをJavaScriptに変換
してUIコンポーネントを作成する。
------------------------------------------------------------------------------------------------
@testing-library/react を使用して Button コンポーネントをテスト用の仮想 DOM にレンダリングします。そして、テ
ストではさまざまなアサーションを使用して、ボタンが期待通りに動作するか (ドキュメントに存在するか、特定のテキストを
含むか、クリックイベントに応答するか、指定したクラスを持つか) をチェックします。

================================================================================================
4
screen
- React Testing Libraryのscreenオブジェクト。テスト中にコンポーネントのレンダリング結果にアクセスする機能を提供。
screenオブジェクトは、DOM要素（実際のブラウザで動作している場合はDOMノード、Node.jsで動作している場合はjsdomノ
ード）を検索するための関数を提供します。
- この時点でButtonしかないので、screenの対象はこのButtonだけ。
- `screen.getByRole('button')`を使用すると、テスト環境にレンダリングされたHTML要素の中から`role`属性が
`button`に一致する要素を取得します。`<Button>`コンポーネントは、内部で標準のHTML`<button>`要素をレンダリング
しており、`<button>`要素はデフォルトで`role="button"`を持つため、このクエリによって直接取得することができます。
- また、`screen.getByRole`はアクセシビリティに焦点を当てたクエリであり、アクセシブルな要素を優先して取得すること
を目的としています。
- さらに、`screen.getByRole('button', { name: /click me/i })`のように`name`オプションを指定することで、
ボタンの表示テキストに基づいてより具体的な要素の検索が可能になります。この場合、テキスト内容が"Click me"に一致（ま
たは一致する正規表現パターンに基づく）するボタン要素を取得します。これにより、特定のテキストを持つボタンが正しくレン
ダリングされているかを検証するテストが行えます。
------------------------------------------------------------------------------------------------
getByRole
screenオブジェクトのgetByRole関数。第一引数に検索する要素のrole属性の値、第二引数に検索する要素のテキストを渡し
ます。
特定のDOM要素をRoleで取得する。
役割（role）が "button" である要素で、nameオプションを使用して、テキスト内容が正規表現 /click me/i と一致する
ボタン要素を検索。
------------------------------------------------------------------------------------------------
nameオプション
nameオプションで指定した文字列に一致した要素（この場合、button）を探す。

================================================================================================
5
expect
expectはJestの関数。テストの期待値を記述します。引数として変数や関数を取ることができます。
expect関数に続けてチェーンメソッド（.toBe()など）を使用して、期待される結果や条件を指定します。
------------------------------------------------------------------------------------------------
toBeInTheDocument
Jestのマッチャ関数。テスト対象の要素がDOMに存在するかどうかをチェックするために使用されます。

================================================================================================
6
userEvent
React Testing Libraryの関数で、fireEventのラッパー関数。ユーザーが行う操作をシミュレートする。
基本fireEventよりこのuserEventを使用する。
------------------------------------------------------------------------------------------------
click
要素のクリックイベントをシミュレートするための関数
------------------------------------------------------------------------------------------------
fireEvent
React Testing Libraryのオブジェクトで、テスト中にイベントを発生させるための関数を提供します。
イベント（"click"、"change"、"input"など）を発生させる関数と、発生対象の要素を引数として受け取ります。
------------------------------------------------------------------------------------------------
. **なぜ `userEvent.click(buttonElement);` と一緒に `await` が使えるのか？
- ユーザーイベント `userEvent` メソッドは、ユーザーとのインタラクションの非同期性を処理するためにプロミスを返すの
で、`await` は `userEvent.click(buttonElement)` と一緒に使うことができます。多くのユーザーアクションは、ネッ
トワークリクエストのトリガー、更新のレンダリング、アニメーションの完了待ちなど、非同期の動作を伴います。プロミスを返
すことで、 `userEvent` はこれらのインタラクションを待機させ、インタラクションが完全に解決してからテストを進めるよ
うにします。これは、UI の更新が非同期イベントに依存することが多い最近の Web アプリケーションでは特に重要です。
------------------------------------------------------------------------------------------------
. **なぜ `userEvent.click(buttonElement);` と共に `await` を使用しなければならないのか？
- userEvent`によってシミュレートされるユーザーイベントの非同期実行を適切に処理するためには、`await`を
`userEvent.click(buttonElement)` と共に使用する必要があります。ユーザーとのインタラクションは、DOM 内の瞬時
ではない変化 (状態の更新や API 呼び出し、その他の約束事を含む副作用など) を引き起こす可能性があるため、`await` を
使用することで、テストはこれらの変化が完了するのを待ってから次の行に進むようになります。await` を使用しないと、UI
が更新される前にアサーションが実行される可能性があります。
------------------------------------------------------------------------------------------------
単純なクリックイベントであっても、`userEvent.click(buttonElement)`で`await`を使う必要がある：
- 非同期動作**： テストライブラリの `userEvent` は、ユーザーとのインタラクションを、実際のブラウザでどのように起
こるか にできるだけ近い形でシミュレートします。クリックを含むこれらのインタラクションの多くは、状態の更新、APIから
のデータの取得、DOMの更新など、Reactアプリケーションの非同期動作をトリガーすることができます。クリックイベント自体
は同期的ですが、アプリケーション内でのクリックの結果は同期的ではありません。await`を使用することで、テストの次の行
に進む前に、すべての非同期更新が完了するのを確実に待つことができます。
- プロミスベースの実装 バージョン 13 の `@testing-library/user-event` から、多くのメソッドがプロミスを返すよ
うになり、 ユーザーとのインタラクションの非同期性をよりうまく扱えるようになりました。この変更は、現在のバージョンの
`user-event` がクリックイベントに対して `await` を必要としないかもしれないとしても、テストが非同期ハンドラで正
しく動作することを確認するために、将来のために `await` を使用することは良い習慣であることを意味します。

================================================================================================
7
toHaveBeenCalled
Jestのマッチャで、モック関数が呼び出されたかどうかをチェックします。モック関数が呼び出されていれば、アサーションは
成功（つまりテストが通る）となります。

================================================================================================
８
わざわざテストする理由
- コンポーネントが指定されたクラス名を正しく受け取り、適用されることを確認することで、CSSに従って意図したとおりに
スタイリングされることを保証します。
*/
