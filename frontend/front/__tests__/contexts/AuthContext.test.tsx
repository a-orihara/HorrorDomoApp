// 1
import { render, waitFor } from '@testing-library/react';
import { getAuthenticatedUser } from '../../src/api/auth';
import { AuthContext, AuthProvider, useAuthContext } from '../../src/contexts/AuthContext';
import { User } from '../../src/types/user';

// 2.1
jest.mock('../../src/api/auth');

// 3.1
const mockUser: User = {
  id: 1,
  uid: 'test_uid',
  provider: 'test_provider',
  email: 'test@example.com',
  name: 'Test User',
  allowPasswordChange: false,
  createdAt: new Date(),
  updatedAt: new Date(),
  admin: false,
  profile: null,
  avatarUrl: null,
};

// 4.1
const mockGetAuthenticatedUser = getAuthenticatedUser as jest.Mock;

// Custom component to use the context
const TestComponent = () => {
  const { currentUser } = useAuthContext();
  return <div>{currentUser?.name}</div>;
};

describe('AuthContext', () => {
  // 5.1
  beforeEach(() => {
    // 5.2
    mockGetAuthenticatedUser.mockResolvedValue({
      data: { isLogin: true, data: mockUser },
    });
  });

  // 5.3
  afterEach(() => {
    jest.clearAllMocks();
  });

  it('コンポーネントがマウントされたときに現在のユーザーを設定する', async () => {
    // let currentUser: User | undefined;
    // render(
    //   <AuthProvider>
    //     {/* 6.1 */}
    //     <AuthContext.Consumer>
    //       {(value) => {
    //         currentUser = value?.currentUser;
    //         return null;
    //       }}
    //     </AuthContext.Consumer>
    //   </AuthProvider>
    // );
    const { findByText } = render(
      <AuthProvider>
        <TestComponent />
      </AuthProvider>
    );

    // await waitFor(() => expect(mockGetAuthenticatedUser).toBeCalled());
    // expect(currentUser).toEqual(mockUser);
    await waitFor(() => expect(mockGetAuthenticatedUser).toBeCalled());
    expect(await findByText(mockUser.name)).toBeInTheDocument();
  });
});

/*
@          @@          @@          @@          @@          @@          @@          @@          @
1
- 役割
- このテストファイルの主な役割は、様々なシナリオにおける `AuthContext` の動作の検証を自動化することである。ユー
ザのサインイン状態、ロード状態、現在のユーザ情報などの認証状態をコンテキストが正しく管理していることを確認します。
- 実際の使用シナリオをシミュレートすることで、`AuthContext` と `AuthProvider` コンポーネントがアプリケーショ
ンに統合されたときに意図したとおりに動作することを検証する。
------------------------------------------------------------------------------------------------
- 内容
- **Mock Setup**： Jest のモック機能を使って、 `AuthContext` による API 呼び出し (例えば
`getAuthenticatedUser`)のような外部の依存関係をモックします。これにより、外部サービスやネットワークに依存せずに
テストを実行することができます。
------------------------------------------------------------------------------------------------
- テストケース
- テストケース**: `AuthProvider` コンポーネントのマウントをシミュレートするテストケースが含まれており、初期化時
に現在のユーザが正しく設定されているかどうかを検証する。これには、`getAuthenticatedUser`関数が呼び出され、それ
に応じてコンテキストの`currentUser`状態が更新されるかどうかをチェックすることが含まれる。
- テストでは、`render` や `waitFor` などの React のテストユーティリティを使用して、コンポーネントツリーと対話
し、期待される結果をアサートします。
- アサーション 各テストケースには、モック API 呼び出しが行われたかどうか、`currentUser` 状態に期待されるユーザ
ーオブジェクトが含まれているかどうかなど、特定の条件が満たされているかどうかをチェックするアサーションが含まれてい
ます。これらのアサーションは、様々な条件下で `AuthContext` が期待通りに動作することを保証する。

================================================================================================
2.1
. **jest.mockの動作と引数の説明**：
- jest.mock('../../src/api/auth');`はJestの関数呼び出しです。この関数は引数として与えられたパスで指定された
モジュールをモックします。
- 振る舞い**： jest.mock()` を使ってモジュールをモックすると、Jest は実際のモジュールをモックバージョンに置き換
えます。これは、このモジュールからエクスポートされた関数やメソッドが、テストファイルにインポートされたときに Jest
のモック関数 (「スパイ」とも呼ばれます) になることを意味します。これらのモック関数は戻り値を指定することができ、そ
の呼び出しを検査することができます (例えば、何回呼び出されたか、どんな引数で呼び出されたかなど)。
- 引数**： jest.mock()` の最初の引数は、テストファイルからの相対パスを表す文字列です。
- **意図**： 使用する意図は、テストするコード単位を依存関係から分離することです。外部モジュールをモックすることで、
テストの環境を制御したり、 異なるシナリオをシミュレートしたり、実際の API 呼び出しを回避したり、 外部システムの振
る舞いに依存したりすることができます。
------------------------------------------------------------------------------------------------
. **jest.mock('../../src/api/auth');`の説明とその意図**：
- テストを実行するときに `../../src/api/auth` にある `auth` モジュールの実際の実装を、モックまたは偽の実装に
置き換えるために使用します。
- ../../src/api/auth`をモックする意図は、`AuthContext` (あるいはこれらのAPIコールを使用する他のコンポーネン
ト) によるAPIコールの振る舞いをテスト環境で制御することです。これにより、テストは実際に HTTP リクエストを行うこと
なく、これらの呼び出しの返り値を指定したり制御したりできるようになる。これにより、テストは高速で信頼性が高く、ネット
ワークの問題や外部 API の変更などの外部要因に影響されない。

================================================================================================
3.1
. **const mockUser: User` の説明とその意図**：
- `User` 型の `mockUser` という定数を宣言し、モック・ユーザー・オブジェクトで初期化しています。User`型はアプリ
ケーションで定義されている型です。モックユーザーオブジェクトには、`id`、`email`、`name` など、実際のユーザーを模
倣した様々なプロパティが含まれます。
- mockUser`を作成する意図は、テストで使用する一貫性のある制御されたユーザオブジェクトを提供することです。
`mockUser` を使用することで、実際のユーザデータに依存したり、データベースや外部システムでユーザを作成したりするこ
となく、ユーザデータを含むシナリオをシミュレートすることができます。

================================================================================================
4.1
. **const mockGetAuthenticatedUser = getAuthenticatedUser as jest.Mock;` と `jest.Mock`** の説明：
- src/api/auth.tsの`getAuthenticatedUser` を `jest.Mock` 型にキャストしています。これは
`getAuthenticatedUser` が Jest によって自動的にモックされた後に行われます（`jest.mock('../../src/api/auth');` の結果として）。
- **jest.Mock` Type**：`jest.Mock` はJestがTypeScriptのために提供する型です。これはJestのモック関数の型を
表しており、モック関数の戻り値を設定するための `.mockReturnValue()` や `.mockResolvedValue()` 、モック関数
への呼び出しを検査するための `.mock.calls` など、テストに使用される追加のプロパティやメソッドが付属しています。
------------------------------------------------------------------------------------------------
- 振る舞い**： jest.Mock`へのキャストは、`mockGetAuthenticatedUser`がただの関数ではなく、Jestのモック関数で
あることをTypeScriptに伝えます。
- **意図**： getAuthenticatedUser`を`jest.Mock`型で`mockGetAuthenticatedUser`に割り当てる目的は、テスト
環境内でJestのモック機能を明示的に使用することです。このアプローチにより、テスト中に `getAuthenticatedUser` 関
数の動作をきめ細かく制御できるようになり、実際の API 呼び出しを行わずに特定のシナリオをシミュレートできるようになり
ます。

================================================================================================
5.1
beforeEach
Jestが提供する関数。スイートの各テストの前に特定の条件を設定するために使用されます。beforeEach`に渡された関数は、
スイートの各個別テストの前に実行されます。

================================================================================================
5.2
. **mockResolvedValue`関数の説明**：
- mockResolvedValue`関数はJestでモック関数のプロミスの解決が成功したことをシミュレートするために使用します。モ
ック関数が待たされたり、`.then()`が呼ばれたりすると、`mockResolvedValue`に渡された値に解決されます。
- これはプロミスを返す非同期関数をテストするときに特に便利で、実際に非同期処理を実行することなく、テスト内でこれらの
関数の振る舞いを制御することができます。
- 与えられたコンテキストでは、`mockResolvedValue({ data: { isLogin: true, data: mockUser }, });` は
`mockGetAuthenticatedUser`（これは `getAuthenticatedUser` のモック）をセットアップして、ユーザがログインし
ていることを示すオブジェクトとユーザのデータを含むプロミスが解決されるシナリオをシミュレートしています。この設定は、
`getAuthenticatedUser` の結果に依存するコンポーネントや関数の動作をテストするために重要である。

================================================================================================
5.3
**afterEach`** の説明:
- afterEach` は Jest が提供する関数で、テストスイートの各テストの後にコードを実行することができます。あるテスト
の状態が他のテストに影響しないようにするためのクリーンアップによく使われます。

================================================================================================
5.4.
**clearAllMocks`** の説明です：
- clearAllMocks`はJestの関数で、モック関数のインスタンスに保存されているすべての情報をリセットします。これには、
関数がどのように呼び出されたか、どのような値を返したか、エラーをスローしたかなどのデータが含まれます。
- clearAllMocks` の主な使い道はテストの後始末で、テスト間でモックが状態を保持しないようにすることです。
- これは `jest.mock`、`mockImplementation`、`mockReturnValue` で設定したモックの実装を削除しません。使用
データをクリアするだけです。

================================================================================================
6.1
Contextの`Provider` と `Consumer`の違い
大家族の集まりで、大きな鍋に入ったスープをみんなで分け合うとしよう。スープは、アプリケーションの多くの部分で共有し
たいデータや情報のようなものです。
- Provider**は、スープ鍋をテーブルに置くようなものです。Reactのコンテキストでは、`Provider`は、"スープ"（デー
タ）を保持し、そのデータを "食べたい"（使用したい）コンポーネントが利用できるようにするコンポーネントです。
- Consumer**は、テーブルでスープを飲もうと決める人のようなものだ。Reactでは、`Consumer`は、"そのスープをくださ
い "と言うコンポーネントである。Provider`が提供するデータにアクセスする。
- `Consumer`はuseContextの別の書き方みたいなもの。
------------------------------------------------------------------------------------------------



### コンテキストの仕組み
- 作成**： コンテキストは `React.createContext()` を使って作成する。これは `Provider` と `Consumer` を持
つコンテキストオブジェクトを返す。Provider`コンポーネントはコンポーネントツリーの上位にコンテキストの値を設定する
ために使用され、子コンポーネントがコンポーネントツリーのどの階層にいてもこの値にアクセスできるようにする。
- **コンテキストの提供**： Provider`コンポーネントは、この`Provider`の子孫である消費コンポーネントに渡す `value`
プロップを受け入れます。
- コンテキストの消費**： React 16.8 で Hooks が導入される前は、`Consumer` コンポーネントは主にコンテキストの値を消費するために使用されていました。Consumer`コンポーネントはコンテキスト値にアクセスするためにレンダリングプロップAPIを使用します。
------------------------------------------------------------------------------------------------
### `<AuthContext.Consumer>` の違い
- **<AuthContext.Consumer>`**： 特にクラスコンポーネントで使用される。これは、Reactノードを返す関数を子として
必要とします。この関数は、現在のコンテキスト値を受け取り、Reactノードを返します。
- **`useContext(AuthContext)` Hook**： React Hooks で導入された `useContext` は、機能コンポーネントが
コンテキストの変更を購読できるようにします。

------------------------------------------------------------------------------------------------
. **なぜ`AuthContext.Consumer` が使われているのか？
- AuthContext.Consumer` コンポーネントは、テスト環境内のコンテキスト値にアクセスするために使用されます。
AuthContext.tsx` の実装では、`AuthContext.Consumer` コンポーネントは明示的に使用されていませんが、いくつかの
理由により、テストフェーズで重要な役割を果たします
------------------------------------------------------------------------------------------------
- コンテキスト値への直接アクセス**： これにより、`AuthContext.Provider` が提供するコンテキスト値に直接アクセス
できるようになります。これは、`currentUser` や `isSignedIn`、その他の状態管理関数など、コンテキストが期待され
る値を正しくコンシューマに渡していることを確認するのに便利です。
------------------------------------------------------------------------------------------------
- テストで `AuthContext.Consumer` を使うと、 コンテキストやそのプロバイダ全体をモックすることなく、 テスト対象
のコンポーネントがそのコンテキストで期待通りに動作することを確認できます。これによって、コンポーネントの実装ではなく
、 コンポーネントとコンテキストのやりとりをテストすることになります。
*/
