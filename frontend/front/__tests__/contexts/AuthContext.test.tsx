// 1
import { render, waitFor } from '@testing-library/react';
import { getAuthenticatedUser } from '../../src/api/auth';
import { AuthContext, AuthProvider, useAuthContext } from '../../src/contexts/AuthContext';
import { User } from '../../src/types/user';

// 2.1
jest.mock('../../src/api/auth');

// 3.1
const mockUser: User = {
  id: 1,
  uid: 'test_uid',
  provider: 'test_provider',
  email: 'test@example.com',
  name: 'Test User',
  allowPasswordChange: false,
  createdAt: new Date(),
  updatedAt: new Date(),
  admin: false,
  profile: null,
  avatarUrl: null,
};

// 4.1
const mockGetAuthenticatedUser = getAuthenticatedUser as jest.Mock;

// 6.1 コンテキストを使用するテスト用のコンポーネントを作成
const TestComponent = () => {
  // 6.2
  const { currentUser } = useAuthContext();
  // console.log('カレント User:', currentUser);
  return <div>{currentUser?.name}</div>;
};

describe('AuthContext', () => {
  // 5.1
  beforeEach(() => {
    // 5.2
    mockGetAuthenticatedUser.mockResolvedValue({
      data: { isLogin: true, data: mockUser },
    });
  });

  // 5.3
  afterEach(() => {
    jest.clearAllMocks();
  });

  it('コンポーネントがマウントされたときに子コンポーネントに現在のユーザーを設定する', async () => {
    // 7.1 renderで生成されたオブジェクトからfindByTextを取り出す
    const { findByText } = render(
      <AuthProvider>
        <TestComponent />
      </AuthProvider>
    );

    // 8
    await waitFor(() => expect(mockGetAuthenticatedUser).toBeCalled());
    expect(await findByText(mockUser.name)).toBeInTheDocument();
  });
});

/*
@          @@          @@          @@          @@          @@          @@          @@          @
1
- 役割
- このテストファイルの主な役割は、様々なシナリオにおける `AuthContext` の動作の検証を自動化することである。ユー
ザのサインイン状態、ロード状態、現在のユーザ情報などの認証状態をコンテキストが正しく管理していることを確認します。
- 実際の使用シナリオをシミュレートすることで、`AuthContext` と `AuthProvider` コンポーネントがアプリケーショ
ンに統合されたときに意図したとおりに動作することを検証する。
------------------------------------------------------------------------------------------------
- 内容
- **Mock Setup**： Jest のモック機能を使って、 `AuthContext` による API 呼び出し (例えば
`getAuthenticatedUser`)のような外部の依存関係をモックします。これにより、外部サービスやネットワークに依存せずに
テストを実行することができます。
------------------------------------------------------------------------------------------------
- テストケース
- テストケース**: `AuthProvider` コンポーネントのマウントをシミュレートするテストケースが含まれており、初期化時
に現在のユーザが正しく設定されているかどうかを検証する。これには、`getAuthenticatedUser`関数が呼び出され、それ
に応じてコンテキストの`currentUser`状態が更新されるかどうかをチェックすることが含まれる。
- テストでは、`render` や `waitFor` などの React のテストユーティリティを使用して、コンポーネントツリーと対話
し、期待される結果をアサートします。
- アサーション 各テストケースには、モック API 呼び出しが行われたかどうか、`currentUser` 状態に期待されるユーザ
ーオブジェクトが含まれているかどうかなど、特定の条件が満たされているかどうかをチェックするアサーションが含まれてい
ます。これらのアサーションは、様々な条件下で `AuthContext` が期待通りに動作することを保証する。

================================================================================================
2.1
. **jest.mockの動作と引数の説明**：
- jest.mock('../../src/api/auth');`はJestの関数呼び出しです。この関数は引数として与えられたパスで指定された
モジュールをモックします。
- 振る舞い**： jest.mock()` を使ってモジュールをモックすると、Jest は実際のモジュールをモックバージョンに置き換
えます。これは、このモジュールからエクスポートされた関数やメソッドが、テストファイルにインポートされたときに Jest
のモック関数 (「スパイ」とも呼ばれます) になることを意味します。これらのモック関数は戻り値を指定することができ、そ
の呼び出しを検査することができます (例えば、何回呼び出されたか、どんな引数で呼び出されたかなど)。
- 引数**： jest.mock()` の最初の引数は、テストファイルからの相対パスを表す文字列です。
- **意図**： 使用する意図は、テストするコード単位を依存関係から分離することです。外部モジュールをモックすることで、
テストの環境を制御したり、 異なるシナリオをシミュレートしたり、実際の API 呼び出しを回避したり、 外部システムの振
る舞いに依存したりすることができます。
------------------------------------------------------------------------------------------------
. **jest.mock('../../src/api/auth');`の説明とその意図**：
- テストを実行するときに `../../src/api/auth` にある `auth` モジュールの実際の実装を、モックまたは偽の実装に
置き換えるために使用します。実装が与えられなければ、モック関数は実行時にデフォルトundefinedを返します。
- ../../src/api/auth`をモックする意図は、`AuthContext` (あるいはこれらのAPIコールを使用する他のコンポーネン
ト) によるAPIコールの振る舞いをテスト環境で制御することです。これにより、テストは実際に HTTP リクエストを行うこと
なく、これらの呼び出しの返り値を指定したり制御したりできるようになる。これにより、テストは高速で信頼性が高く、ネット
ワークの問題や外部 API の変更などの外部要因に影響されない。

================================================================================================
3.1
. **const mockUser: User` の説明とその意図**：
- `User` 型の `mockUser` という定数を宣言し、モック・ユーザー・オブジェクトで初期化しています。User`型はアプリ
ケーションで定義されている型です。モックユーザーオブジェクトには、`id`、`email`、`name` など、実際のユーザーを模
倣した様々なプロパティが含まれます。
- mockUser`を作成する意図は、テストで使用する一貫性のある制御されたユーザオブジェクトを提供することです。
`mockUser` を使用することで、実際のユーザデータに依存したり、データベースや外部システムでユーザを作成したりするこ
となく、ユーザデータを含むシナリオをシミュレートすることができます。

================================================================================================
4.1
. **const mockGetAuthenticatedUser = getAuthenticatedUser as jest.Mock;` と `jest.Mock`** の説明：
- src/api/auth.tsの`getAuthenticatedUser` を `jest.Mock` 型にキャストしています。これは
`getAuthenticatedUser` が Jest によって自動的にモックされた後に行われます（`jest.mock('../../src/api/auth');` の結果として）。
- **jest.Mock` Type**：`jest.Mock` はJestがTypeScriptのために提供する型です。これはJestのモック関数の型を
表しており、モック関数の戻り値を設定するための `.mockReturnValue()` や `.mockResolvedValue()` 、モック関数
への呼び出しを検査するための `.mock.calls` など、テストに使用される追加のプロパティやメソッドが付属しています。
------------------------------------------------------------------------------------------------
- 振る舞い**： jest.Mock`へのキャストは、`mockGetAuthenticatedUser`がただの関数ではなく、Jestのモック関数で
あることをTypeScriptに伝えます。
- **意図**： getAuthenticatedUser`を`jest.Mock`型で`mockGetAuthenticatedUser`に割り当てる目的は、テスト
環境内でJestのモック機能を明示的に使用することです。このアプローチにより、テスト中に `getAuthenticatedUser` 関
数の動作をきめ細かく制御できるようになり、実際の API 呼び出しを行わずに特定のシナリオをシミュレートできるようになり
ます。

================================================================================================
5.1
beforeEach
Jestが提供する関数。スイートの各テストの前に特定の条件を設定するために使用されます。beforeEach`に渡された関数は、
スイートの各個別テストの前に実行されます。

================================================================================================
5.2
. **mockResolvedValue`関数の説明**：
- mockResolvedValue`関数はJestでモック関数のプロミスの解決が成功したことをシミュレートするために使用します。モ
ック関数が待たされたり、`.then()`が呼ばれたりすると、`mockResolvedValue`に渡された値に解決されます。
- これはプロミスを返す非同期関数をテストするときに特に便利で、実際に非同期処理を実行することなく、テスト内でこれらの
関数の振る舞いを制御することができます。
- 与えられたコンテキストでは、`mockResolvedValue({ data: { isLogin: true, data: mockUser }, });` は
`mockGetAuthenticatedUser`（これは `getAuthenticatedUser` のモック）をセットアップして、ユーザがログインし
ていることを示すオブジェクトとユーザのデータを含むプロミスが解決されるシナリオをシミュレートしています。この設定は、
`getAuthenticatedUser` の結果に依存するコンポーネントや関数の動作をテストするために重要である。

================================================================================================
5.3
**afterEach`** の説明:
- afterEach` は Jest が提供する関数で、テストスイートの各テストの後にコードを実行することができます。あるテスト
の状態が他のテストに影響しないようにするためのクリーンアップによく使われます。

================================================================================================
5.4.
**clearAllMocks`** の説明です：
- clearAllMocks`はJestの関数で、モック関数のインスタンスに保存されているすべての情報をリセットします。これには、
関数がどのように呼び出されたか、どのような値を返したか、エラーをスローしたかなどのデータが含まれます。
- clearAllMocks` の主な使い道はテストの後始末で、テスト間でモックが状態を保持しないようにすることです。
- これは `jest.mock`、`mockImplementation`、`mockReturnValue` で設定したモックの実装を削除しません。使用
データをクリアするだけです。

================================================================================================
6.1
- TestComponent` はこのテストのために特別に作成されたカスタムコンポーネントである。このコンポーネントは
`AuthProvider` が提供するコンテキストを利用するために `useAuthContext` を使用する。
- `AuthProvider` が期待されるコンテキストを子コンポーネントに正しく提供することを検証する。TestComponent`が現
在のユーザ名にアクセスして表示できるかどうかを確認することで、コンテキストが意図したとおりに動作していることを確認する。
- 実際のコンポーネントでコンテキストをどのように利用するかの例となり、実際のユースケースをより代表するテストとなりま
す。
- TestComponent`は、現在のユーザーについて知る必要があるアプリのコンポーネントと同じように動作します。
`TestComponent`が現在のユーザーの名前を正しく表示できるかどうかをチェックする。

================================================================================================
6.2
**テストで実際のコンテキストを使う**： このシナリオでは、`AuthProvider` とそのコンシューマとの統合をテストするこ
とを目的としているので、テストは実際の `useAuthContext` フックを使ってコンテキスト値にアクセスします。個々の関数
やコンポーネントを単体でテストするときにはモック値を使うかもしれませんが、 このような統合テストでは、実際の実装を使
ってすべての部分がシームレスに動作することを確認するのが効果的です。
------------------------------------------------------------------------------------------------
- 次に `render` はいくつかのクエリ関数を含むオブジェクトを返すが、そのうちの一つが `findByText` である。この関
数を使うと、仮想 DOM から特定のテキストを含む要素を検索することができる。
- testing-library/react`の `render` 関数を使用すると、コンポーネントをテスト用の仮想 DOM にレンダリングしま
す。コンポーネントをレンダリングすると同時に、 `render` は仮想 DOM にクエリを発行するためのユーティリティ関数も提
供します。これらのユーティリティや "クエリ関数" は、レンダリングされたコンポーネント内の要素を見つけるために使用することができます。例えば、`findByText` はクエリ関数で、見つかった場合に指定したテキストを含む要素に解決するプロミスを返します。
- テスト用にレンダリングされた仮想 DOM 内の要素を見つけるために提供されるメソッド。
------------------------------------------------------------------------------------------------
Contextの`Provider` と `Consumer`の違い
大家族の集まりで、大きな鍋に入ったスープをみんなで分け合うとしよう。スープは、アプリケーションの多くの部分で共有し
たいデータや情報のようなものです。
- Provider**は、スープ鍋をテーブルに置くようなものです。Reactのコンテキストでは、`Provider`は、"スープ"（デー
タ）を保持し、そのデータを "食べたい"（使用したい）コンポーネントが利用できるようにするコンポーネントです。
- Consumer**は、テーブルでスープを飲もうと決める人のようなものだ。Reactでは、`Consumer`は、"そのスープをくださ
い "と言うコンポーネントである。Provider`が提供するデータにアクセスする。
- `Consumer`はuseContextの別の書き方みたいなもの。
------------------------------------------------------------------------------------------------
. currentUser
- この中身はmockUser。
- `getAuthenticatedUser` のレスポンスを`mockUser` を返すように明示的にモックしているからです。テスト中に
`AuthProvider` コンポーネント内の `handleGetCurrentUser` 関数が呼ばれると、`currentUser` の状態をこのモッ
クされたユーザデータに設定します。
- getAuthenticatedUser` 関数が定義済みのオブジェクト（`mockUser`）を返すようにモックすることで、実際の APIレ
スポンスのような外部要因に依存せず、予測可能な動作をするようにテスト環境を制御することができます。このアプローチはユ
ニットテストや統合テストでは一般的で、コンポーネントの振る舞いを分離し、テストが決定論的であることを保証します。実際
の API 呼び出しを行わなくても、アプリケーションのさまざまな状態をシミュレートできます。

================================================================================================
7.1
*ここで `render` は何をしているのか？
- render` 関数は testing ライブラリから来ており、テスト環境でコンポーネントのレンダリングをシミュレートする。コ
ンポーネントを画面上に描画するふりをするようなものですが、ブラウザの代わりにテストの中でそれを行うので、コンポーネン
トの振る舞いをチェックすることができます。
- render(<AuthProvider><TestComponent /></AuthProvider>);` と書くと、`AuthProvider` の中にある
`TestComponent` を、あたかも実際のアプリの中で動いているかのように、画面に表示するふりをする。
------------------------------------------------------------------------------------------------
*render`はどのようなオブジェクトを生成するのか？
- render`関数は、"描画 "されたオブジェクトがどのように動作するかを調べるために使用できる、たくさんのツールや情報
を生成します。
------------------------------------------------------------------------------------------------
*生成されたオブジェクトのプロパティを返すか？
- そうです、`render` はオブジェクトを返します。オブジェクトには `findByText`、`getByText`、`queryByText`
などのメソッド（ツール）がたくさんあります。
- const { findByText } と書くと、次のようになる。= render(...);`と書くと、マジックキットの中から`findByText`
ツールを選び出し、レンダリングしたコンポーネントの中のテキストを探すのに使っている。
------------------------------------------------------------------------------------------------
分割代入せずに書くことができますか？
- はい。まず `render` が返すオブジェクト全体を受け取り、そのオブジェクトに対して `findByText` メソッドを使用し
ます。これがその方法だ：
const view = render(<AuthProvider><TestComponent /></AuthProvider>)；
const findByText = view.findByText；
------------------------------------------------------------------------------------------------
*findByText`とは？
- findByText`は、`render`で作成されたコンポーネントに対し、特定のテキストを含む要素を見つけようとする。
------------------------------------------------------------------------------------------------
TestComponentでuseAuthContext();が使えるのは、
<AuthProvider>で挟んでいるから、それをテストしている

================================================================================================
8
. waitFor
waitFor`はtestinglibraryの関数で、テストの非同期処理を管理するのに役立ちます。React コンポーネントのテストを書
いているとき、特にこれらのコンポーネントがデータの取得のような非同期アクションに依存している場合、データがロードされ
る前やコンポーネントの状態が更新される前にアサーション (チェック) が実行される可能性があります。このようなときに
`waitFor` が役に立ちます。
------------------------------------------------------------------------------------------------
- 目的:テストを進める前に、特定の条件が満たされるのを待ちます。
- 動作：コールバック関数がエラーを投げるのを止めるまで、コールバック関数を繰り返し実行します。これは、条件が満たされ
たかどうかをチェックし続けることを意味する。
- 引数：この関数が受け取る第一引数はコールバック関数である。この関数には、非同期処理が完了したら最終的に渡されるコー
ドやアサーションが含まれます。
------------------------------------------------------------------------------------------------
ステップ・バイ・ステップで起こっていることを簡略化して説明しよう：
. **非同期アクション:** おそらく、APIからデータを取得するような非同期アクションを実行するコンポーネントや関数をテ
ストしていることでしょう。この場合、`mockGetAuthenticatedUser`はこの非同期操作の一部として呼び出されることが期
待されます。
------------------------------------------------------------------------------------------------
.**waitFor`の使用:** `waitFor` の中に `expect(mockGetAuthenticatedUser).toBeCalled()` をラップするこ
とで、"`mockGetAuthenticatedUser` が呼ばれた瞬間を待つ" と言っていることになります。これは、
`mockGetAuthenticatedUser`がコンポーネント内の非同期操作の結果として呼び出される場合に特に便利です（コンポーネ
ントがマウントされた後にユーザデータを取得するなど）。
------------------------------------------------------------------------------------------------
. **The Test Waits:** `waitFor` はコールバックのアサーション (`expect(mockGetAuthenticatedUser).toBeCalled()`)
が真になるまで (`mockGetAuthenticatedUser` がコールされたことを示す)、あるいはタイムアウトに達するまで再試行を
続けます。これにより、非同期処理が完了するのに十分な時間がある場合にのみテストを進めることができます。
. **タイムアウト (デフォルトは 1000 ミリ秒ですが、設定可能です) 内で条件が満たされた場合、テストは先に進み、さら
にアサーションやコードが実行される可能性があります。タイムアウト時間内に条件が満たされなかった場合、テストは失敗し、
期待したアクションが時間内に起こらなかったことを示します。
------------------------------------------------------------------------------------------------
.テスト結果
PASS  __tests__/contexts/AuthContext.test.tsx (9.856 s)
  AuthContext
    ✓ コンポーネントがマウントされたときに子コンポーネントに現在のユーザーを設定する (172 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
------------------------------------------------------------------------------------------------
あなたのテストシナリオでは、2つの `expect` ステートメントがあっても、それらは1つのテストケースに貢献しています。
Jest や同様のテストフレームワークを React Testing Library と一緒に使うと、フレームワークはテストを全体として実
行し、そのテスト内のすべてのアサーション (`expect` 文) を評価します。結果は、アサーションごとにではなく、テストケ
ース全体として報告されます。
------------------------------------------------------------------------------------------------
1つのテストケース内でコンポーネントの振る舞いのさまざまな側面を検証するために複数のexpect文がありますが、Jestは個
々のアサーションではなく、テストケース全体として結果を報告します。
*/
