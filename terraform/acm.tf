# ================================================================================================
# ACM "aws_acm_certificate"
# ================================================================================================
# 1 acmの証明書のリソース。新しいSSL/TLS証明書をリクエストするために使用されます。
resource "aws_acm_certificate" "acm_cert" {
  domain_name = var.domain
  # 1.1
  # domain_validation_options = [
  #   {
  #     domain_name           = "*.horror-domo-app.com"
  #     resource_record_name  = "_862fb5009c2cacd5b7b1c60c0820e39e.horror-domo-app.com."
  #     resource_record_type  = "CNAME"
  #     resource_record_value = "_7db5af47b5645710dac77820f7101798.knjdltryfm.acm-validations.aws."
  #   },
  #   {
  #     domain_name           = "horror-domo-app.com"
  #     resource_record_name  = "_862fb5009c2cacd5b7b1c60c0820e39e.horror-domo-app.com."
  #     resource_record_type  = "CNAME"
  #     resource_record_value = "_7db5af47b5645710dac77820f7101798.knjdltryfm.acm-validations.aws."
  #   },
  # ]
  # 1.2
  subject_alternative_names = [
    "*.horror-domo-app.com",
  ]
  tags     = {}
  tags_all = {}
  # 検証はDNS検証を行う
  validation_method = "DNS"
  # 証明書のトランスペアレンシー（Transparency）ログへの記録設定を指定（デフォルトの設定）
  options {
    certificate_transparency_logging_preference = "ENABLED"
  }
  # 1 ELBでACMを利用している場合、この設定が推奨されている
  lifecycle {
    create_before_destroy = true
  }
  # 1.3 acmはroute53のレコードと依存関係にある
  depends_on = [
    aws_route53_zone.route53_zone
  ]
}

# ================================================================================================
# ACM "aws_route53_record"
# ================================================================================================
# 2 AWSのRoute53サービスでDNSレコードを作成・管理するためのリソース
# resource "aws_route53_record" "portfolio_acm_dns_resolve_record_tf" {
resource "aws_route53_record" "acm_dns_resolve_record" {
  # fqdn    = "_862fb5009c2cacd5b7b1c60c0820e39e.horror-domo-app.com"
  # 2.1 メタ引数。形式[for_each = map型]。forで作成されたmap（dvo.domain_nameをキー、その値がオブジェクト）を指定。
  for_each = {
    # 2.2 domain_validation_optionsの各要素dvoに対し、key:dvo.domain_name（文字列）、値（object）のmapを作成
    for dvo in aws_acm_certificate.acm_cert.domain_validation_options : dvo.domain_name => {
      name   = dvo.resource_record_name
      record = dvo.resource_record_value
      type   = dvo.resource_record_type
    }
  }
  # 2.3 recordの名前
  allow_overwrite = true
  name            = each.value.name
  records         = [each.value.record]
  ttl             = 300
  type            = each.value.type
  zone_id         = aws_route53_zone.route53_zone.id
}

# ================================================================================================
# ACM "acm_certificate_validation"
# ================================================================================================
# 3 ACM証明書が正常に検証された（つまり使用可能な状態になった）ことを確認するリソース
resource "aws_acm_certificate_validation" "portfolio_cert_valid_tf" {
  certificate_arn         = aws_acm_certificate.acm_cert.arn
  validation_record_fqdns = [for record in aws_route53_record.acm_dns_resolve_record : record.fqdn]
}

/*
@          @@          @@          @@          @@          @@          @@          @@          @
================================================================================================
1
acmのarnでimportする
------------------------------------------------------------------------------------------------
- **`aws_acm_certificate`**
- `aws_acm_certificate`はAWS Certificate Manager(ACM)でSSL/TLS証明書を作成するためのリソースです。
- このリソースが作成された後、関連する`aws_acm_certificate_validation`リソースで証明書の検証が行われます。
- **`aws_route53_record`**
- `aws_route53_record`はAWSのRoute53サービスでDNSレコードを作成・管理するためのリソースです。
- ACM証明書の`DNS`検証を行う場合、このリソースが必要です。
- `aws_acm_certificate`から返される`domain_validation_options`を用いて、Route53のCNAMEレコードを作成し、
証明書を検証します。
- **`aws_acm_certificate_validation`**
- `aws_acm_certificate_validation`はACM証明書が正常に検証された（つまり使用可能な状態になった）ことを確認す
るためのリソースです。
- このリソースは`aws_acm_certificate`の`arn`を参照し、その証明書が検証されるまで次のリソースの作成を一時停止し
ます。
これらのリソースは一連のワークフローで連携します。まず`aws_acm_certificate`で証明書を作成し、次に
`aws_route53_record`でDNSレコードを設定して証明書を検証し、最後に`aws_acm_certificate_validation`で証明
書が正常に検証されたことを確認する流れが一般的です。
------------------------------------------------------------------------------------------------
. `lifecycle { create_before_destroy = true }`の意味
- この設定は、リソースが削除される前に新しいリソースが作成されるようにTerraformに指示します。既存のリソースを削除
する前に、新しいリソースが確実に作成されることを保証するための設定です。
------------------------------------------------------------------------------------------------
- ダウンタイムを最小限に抑える必要がある場合は推奨されます。
- 例：ELB（Elastic Load Balancer）のようなロードバランサーと組み合わせて使用する場合、新しい証明書が適用される
前に古い証明書を削除しないようにするためにこの設定が有用です。
------------------------------------------------------------------------------------------------
#### なぜこの設定は`terraform import`でインポートされる項目にないのか？
- `terraform import`は既存のクラウドリソースをTerraformで管理するためにその状態をインポートする機能ですが、こ
の`lifecycle`ブロックはTerraform自体の挙動を制御する設定です。
- この設定は、Terraformがリソースを管理する際の挙動を制御するものであり、AWSや他のクラウドプロバイダが持っている
メタデータではないからです。

================================================================================================
1.1
`aws_acm_certificate`の`domain_validation_options`を`aws_route53_record`に設定する理由は、ACM証明書の
承認のために必要なDNS検証レコードを自動的に作成するためです。
------------------------------------------------------------------------------------------------
. **ACM証明書のリクエスト**:
- `aws_acm_certificate`リソースを使用してACM証明書のリクエストを作成します。
- この時点で、`domain_validation_options`はまだ空です。これは、Terraformが実際にリソースをAWSに適用するとき
に自動的に埋められます。
------------------------------------------------------------------------------------------------
. **DNS検証レコードの取得**:
- ACMは、証明書のリクエストを承認するために必要なDNSレコードを提供します。これらのレコードは
`domain_validation_options`属性にリストとして格納されます。
------------------------------------------------------------------------------------------------
. **DNS検証レコードの作成**:
- `aws_route53_record`リソースを使用して、`domain_validation_options`から取得したDNS検証レコードをRoute5
3に作成します。
- これにより、ACMはドメインの所有者が証明書のリクエストを作成したことを確認できます。
------------------------------------------------------------------------------------------------
. **ACM証明書の検証**:
- DNSレコードが正しく設定されていると、ACMは証明書を承認します。
- `aws_acm_certificate_validation`リソースを使用して、証明書が承認されるまでTerraformの実行を待機させること
ができます。
------------------------------------------------------------------------------------------------
このプロセスを自動化することで、手動でDNS検証レコードを作成する手間を省き、エラーのリスクを低減することができます。
Terraformはこのプロセスをスムーズに進めるためのツールとして非常に役立ちます。
------------------------------------------------------------------------------------------------
`domain_validation_options`はset型(以前はlist型だった)。set内の各要素はobject型です。

================================================================================================
1.2
`subject_alternative_names`
SSL/TLS証明書（HTTPS証明書）に含まれる代替のドメイン名（Subject Alternative Names、SAN）を指定するための設
定です。この設定を使用することで、単一の証明書で複数のドメイン名やサブドメイン名を保護することができます。
------------------------------------------------------------------------------------------------
`subject_alternative_names`は`*.horror-domo-app.com`というワイルドカード形式のドメイン名を証明書に含める
ために使用されています。これは、`horror-domo-app.com`という特定のドメインとそのサブドメイン（すべてのサブドメイ
ン）に対して、同じSSL/TLS証明書を使用することを意味します。
具体的な例として、次のようなドメイン名がこの設定に適用される可能性があります：
- `horror-domo-app.com`
- `www.horror-domo-app.com`
- `api.horror-domo-app.com`

================================================================================================
1.3
. **`depends_on` の文法上の解説**:
- `depends_on` は、Terraformリソースが依存する他のリソースを指定するための属性です。
- 通常、Terraformはリソースの依存関係を自動的に検出しますが、明示的な依存関係が必要な場合や、Terraformが自動的
に検出できない依存関係を指定する場合に使用します。
- `depends_on` の値は、依存するリソースのリストとして指定します。
------------------------------------------------------------------------------------------------
. **`depends_on = [ aws_route53_zone.route53_zone ]` を設定する意図**:
- ACM証明書の検証方法が "DNS" に設定されている場合、ACMはRoute53を使用してドメインの所有を確認します。そのため、
ACM証明書を作成する前に、関連するRoute53ゾーンが存在している必要があります。
- この `depends_on` の設定により、`aws_route53_zone.route53_zone` リソースが正常に作成され
た後でのみ、`aws_acm_certificate` リソースの作成を開始します。これにより、Route53ゾーンの作成が完了していない
状態でACM証明書の作成が開始されることを防ぐことができます。
------------------------------------------------------------------------------------------------
Terraformの `depends_on` は、リソースの作成順序を制御し、予期しないエラーや問題を回避します。

================================================================================================
2
terraform import aws_route53_record.<NAME> <ホストゾーンID>_<レコード名>_<レコードタイプ>
実際の例：
terraform import aws_route53_record.acm_dns_resolve_record Z05743042OK49Y65Q6CSP__862fb5009c2cacd5b7b1c60c0820e39e.horror-domo-app.com_CNAME
------------------------------------------------------------------------------------------------
. **route53.tfではなく、acm.tfに"aws_route53_record"を書く理由**:
- `acm.tf` を削除する際に、それに関連するリソースが全て削除されるようにするためです。具体的には、ACM証明書とその
証明書の検証のためのRoute53のレコードは密接に関連しているので、一緒に管理することが理にかなっています。
- このような設計方法は、特定の機能や目的に関連するリソースを1つのファイル内にまとめることで、管理や変更が容易になり
ます。
- さらに、Terraformのコードをモジュール化する場合、関連するリソースを1つのファイルにまとめておくことで、再利用や移
植が容易になります。
- このアプローチはコードの可読性やメンテナンス性を向上させるための一つの方法です。
------------------------------------------------------------------------------------------------
`resource "aws_route53_record"`は、AWSのRoute 53サービスに関連するTerraformリソースです。具体的には、
Route 53を使用してDNSレコードを管理するためのリソースです。
ACM（AWS Certificate Manager）とRoute 53は、通常一緒に使用され、ウェブサイトやアプリケーションのセキュアな通
信のためにSSL/TLS証明書（HTTPS）を使用する場合に相互に関連します。以下はその関係を説明します：
------------------------------------------------------------------------------------------------
. **ACM (AWS Certificate Manager)**:
- ACMは、SSL/TLS証明書（HTTPS）を提供し、これらの証明書を管理するためのAWSサービスです。
- ウェブサイトやアプリケーションをセキュアに公開するために、ACMを使用してSSL/TLS証明書を発行および管理できます。
. **Route 53**:
- Route 53は、DNS（Domain Name System）とトラフィックルーティングのためのAWSのマネージドDNSサービスです。
- Route 53を使用すると、ドメイン名をIPアドレスにマッピングし、リクエストを適切なAWSリソースにルーティングするこ
とができます。
------------------------------------------------------------------------------------------------
ACMとRoute 53を組み合わせる一般的なシナリオは次の通りです：
. **SSL/TLS証明書の発行と管理**:
- ACMを使用してSSL/TLS証明書を発行し、ウェブサイトやアプリケーションに適用します。
. **ドメイン名のDNS設定**:
- Route 53を使用して、ウェブサイトのドメイン名（例: example.com）をIPアドレスにマッピングするDNSレコード（例:
AレコードまたはCNAMEレコード）を設定します。
. **SSL/TLS証明書とドメイン名の関連付け**:
- SSL/TLS証明書の設定で、ACMから発行した証明書をウェブサイトのドメイン名に関連付けます。これにより、セキュアな通
信が確立されます。
. **Route 53 Recordの管理**:
- `resource "aws_route53_record"`を使用して、Route 53内でDNSレコードを定義および管理します。これにより、ト
ラフィックが正しいAWSリソースにルーティングされます。
要するに、ACMはSSL/TLS証明書の発行と管理に関連し、Route 53はドメイン名のDNS設定とトラフィックルーティングに関連
します。これらのサービスを組み合わせて、セキュアなウェブサイトやアプリケーションを運用することができます。

================================================================================================
2.1
- object型：キー、バリュー形式で定義される型。予め決められた構造と型を持った複数の属性をグループ化するためのデータ
型。使用シーン: 複数の異なるデータ型の属性を持つコンフィグ要素を定義する場面。
- tupple型：配列の指定した番号に指定した型を当てはめる。
- map型：キーが文字列で、同じデータ型のキーと値のペアを持つ配列。使用シーン: 同じデータ型の値を持つキーと値のペア
を保存する場面。たとえば、環境ごとの設定値を保持する場面など。固定の構造と複数のデータ型を持つ場合はオブジェクト型、
キーと値のペアで同じデータ型を持つ場合はmap型を使用します。
- list型：全て同じ型で指定される配列。
- set型：値の重複が排除された配列
------------------------------------------------------------------------------------------------
`domain_validation_options`はset型(以前はlist型だった)。set内の各要素はobject型です。
------------------------------------------------------------------------------------------------
挙動
- **Step 1**: `aws_acm_certificate.cert.domain_validation_options`の参照
domain_validation_optionsはset型の配列で、中の値はオブジェクト。
------------------------------------------------------------------------------------------------
- **Step 2**: `for` 内包表記の実行
- この`for`ループは、`domain_validation_options`の各エントリー(`dvo`、つまり`domain_validation_options`
のset型配列内のオブジェクト)に対して実行されます。
- dvoは、各要素を参照するための一時的な変数（イテレータ）で、短縮系の略語です。よく見られます。
- 各`dvo`エントリーから、`dvo.domain_name`をキーとして、値は対応する`resource_record_name`,
`resource_record_value`, `resource_record_type`を使ったobject型の、mapを生成します。
-戻り値は下記です。
{
  "*.horror-domo-app.com" = {
    name   = "_8.h.com."
    record = "_7.knjdltryfm.acm-validations.aws."
    type   = "CNAME"
  },
  "horror-domo-app.com" = {
    name   = "_8"
    record = "_7"
    type   = "CNAME"
  }
}
------------------------------------------------------------------------------------------------
- **Step 3**: mapの作成
- `for`の結果、新しいmapが作成されます。このmapは、ドメイン名をキー(string)とし、それに対応するDNSレコードの詳
細（名前、レコード値、タイプ）を値(object)として持ちます。
------------------------------------------------------------------------------------------------
- **Step 4**: `for_each` の実行
- `for_each`は、Step 3で作成されたマップを使用して、`aws_route53_record`リソースの複数のインスタンスを作成し
ます。
- マップの各エントリーに対して、1つの`aws_route53_record`インスタンスが作成されます。
------------------------------------------------------------------------------------------------
- **Step 5**: `each.value`の利用
- Terraformは、`for_each`で作成された各リソースインスタンスに対して、`each.value`を使用して、マップのエントリ
ー（DNSレコードの詳細）にアクセスします。
- この情報を使用して、各`aws_route53_record`インスタンスの`name`, `type`, `records`の属性が設定されます。
------------------------------------------------------------------------------------------------
- **Step 6**: `zone_id` と `ttl` の設定
- 最後に、`zone_id`は`data.aws_route53_zone.host_zone.zone_id`から取得され、`ttl`は60として設定されます。これにより、各レコードは特定のRoute 53ホストゾーン内に作成され、TTLは60秒に設定されます。

これにより、ACM証明書のドメイン検証のために必要なRoute 53 DNSレコードが、指定されたホストゾーン内に正確に作成されます。
================================================================================================
`for_each` は、Terraformでリソースを反復処理するための機能であり、特にリソースを動的に生成する際に役立ちます。
Terraformコード内で指定したリソースの集合をループし、各要素に対して個別のリソースインスタンスを、要素の数分生成し
ます。
------------------------------------------------------------------------------------------------
`for_each` の構文は以下の通りです：
resource "リソースタイプ" "リソース名" {
  for_each = { キー1 = 値1, キー2 = 値2, ... }
  # リソースの設定
}
`for_each` ブロック内には、キーと値のペアで構成されたmapを指定します。各キーは個別のリソースインスタンスを表し、
値はそのリソースインスタンスの設定を指定します。
------------------------------------------------------------------------------------------------
. `for_each` ブロック内では、`aws_acm_certificate.cert.domain_validation_options` から取得したドメイン
検証オプションを反復処理します。
. 各ドメイン検証オプションは、ドメイン名をキーとし、そのオプションに関連する情報（`name`、`record`、`type`）を
値（object型）として持つmapとして定義されています。
. `name`、`type`、`records`、`zone_id`、`ttl` などのリソースの設定は、各ドメイン検証オプションに関連付けられ
た情報に基づいて設定されます。この例では、`for_each` を使用して、動的なDNSレコードの生成と管理を実現しています。
各ドメイン検証オプションに対して、異なるDNSレコードが生成され、それによりAWS ACMのDNS検証をサポートしています。
================================================================================================
aws provider 3.0.0 以降は domain_validation_options がSet型で返ってくる
------------------------------------------------------------------------------------------------
**terraformのList型の解説と具体例**:
- Listは、順序を持つ要素の集合です。Listには同じタイプの値のみが含まれます。
- Listの各要素は、0から始まるインデックスでアクセスできます。
------------------------------------------------------------------------------------------------
- **具体例**:
variable "sample_list" {
  description = "サンプルのList"
  type        = list(string)
  default     = ["apple", "banana", "cherry"]
}
output "first_fruit" {
  value = var.sample_list[0]
}
------------------------------------------------------------------------------------------------
**terraformのSet型の解説と具体例**:
- **解説**:
- Setは、順序を持たないユニークな要素の集合です。インデックスの指定不可。[0]みたいな形で取り出せない
- Listと異なり、Setには重複する要素が存在しないため、特定の順序で要素を取得することはできません。
------------------------------------------------------------------------------------------------
- **具体例**:
variable "sample_set" {
  description = "サンプルのSet"
  type        = set(string)
  default     = ["apple", "banana", "apple"]
}
output "set_length" {
  value = length(var.sample_set)
}

================================================================================================
2.2
map（dvo.domain_nameをキー、その値がobject、このobjectは、name,record,typeを持つ
dvo.domain_name:{
                  name: dvo.resource_record_name
                  record: dvo.resource_record_value
                  type: vo.resource_record_type
                }
------------------------------------------------------------------------------------------------
- **`for` (内包表記)**:
- Terraformの`for`は、リスト、セット、マップを指定した条件等に変換するための構文です。この`for`は、特定の条件に
基づいてコレクションのエントリーをフィルタリング、変更、またはマッピングするのに役立ちます。
- `for s in var.list : s`の書式と、`for s in var.list : s => s`の書式の二つあり。
詳細はこちら
Terraformでのloop処理の書き方（for, for_each, count）
https://zenn.dev/wim/articles/terraform_loop#for_each
------------------------------------------------------------------------------------------------
**具体例**:
locals {
  mylist = ["a", "b", "c", "d"]
  mymap = { for v in local.mylist : v => upper(v) }
}
上記の例では、リスト`mylist`の各要素をキーとして、その要素の大文字バージョンを値とする新しいmap型の`mymap`が作
成されます。
------------------------------------------------------------------------------------------------
dvoは、domain_validation_optionsの短縮形として使用されている。よく使われる名前。

================================================================================================
2.3
`allow_overwrite = true`
- `allow_overwrite = true` は、既存の Route53 レコードが存在する場合にそれを上書きすることを許可します。
- **注意点**: このオプションを使用する場合、意図しない上書きが発生する可能性があります。
------------------------------------------------------------------------------------------------
. `aws_route53_record`で `allow_overwrite = true` を設定する意図
- **ACM証明書の自動更新**: ACM証明書は頻繁に更新される可能性があり、その都度DNSレコードの検証が必要です。
`allow_overwrite = true` が設定されていれば、新しい証明書のDNS検証レコードを自動的に上書きできます。
- **コードの再利用**: 同じTerraformコードを複数の環境やプロジェクトで使用する場合、既存のレコードを手動で削除す
る手間を省くことができます。
- **運用の簡素化**: 手動でDNSレコードを管理する場合、誤ってレコードを削除したり、不整合が生じた場合には、
`allow_overwrite = true` によって自動的に正しい状態に戻すことができます。
- **依存関係の管理**: この例では、`aws_acm_certificate` と `aws_route53_record` が依存関係にあります。証
明書が再発行されると、新しい `domain_validation_options` が生成され、それに伴い DNS レコードも更新される必要
があります。`allow_overwrite = true` を設定していると、この依存関係の管理が簡単になります。
------------------------------------------------------------------------------------------------
`allow_overwrite = true` の設定は、TerraformがAWS Route 53のレコードを作成または更新する際に、すでに存在す
るレコードを上書きできるようにするために使用されます。このオプションを以下のような理由や意図で設定します：
- **ドメイン検証のために特定のDNSレコードが必要**:
AWS ACMのドメイン検証プロセスでは、所有していることを証明するために特定のDNSレコードが必要です。Terraformは、こ
のドメイン検証レコードを自動的に作成します。
- **既存のレコードとの競合を避ける**:
既にRoute 53に検証レコードが存在する場合、`allow_overwrite` を `true` にすることで、Terraformはそれを新しい
レコードで上書きできます。これにより、ドメイン検証プロセス中のエラーを避けることができます。
- **Terraformの状態と実際のリソース状態の同期**:
インフラストラクチャの変更がTerraformの管理外で行われた場合（例えば、手動でDNSレコードが変更された場合など）、
`allow_overwrite = true` があれば、Terraformは次回の `apply` 時に、定義された状態に基づいてレコードを再作成
または更新します。
- **CI/CDパイプラインでの利便性**:
継続的なデプロイメントやインフラストラクチャの更新が行われる環境では、ACM証明書を頻繁に更新することがあります。
`allow_overwrite` が `true` であれば、証明書の更新に伴う新しいドメイン検証レコードがスムーズに作成されます。

================================================================================================
３
`aws_acm_certificate_validation` リソースは、AWS Certificate Manager (ACM) によって発行された SSL/TLS
証明書が正しく検証され、使用可能な状態になるまで Terraform の処理を待機させる特別なリソースです。
------------------------------------------------------------------------------------------------
- **リソースが実際には何も「作成」しないこと**:
このリソースは、AWSのインフラ上に新しい物理的なリソースを作成するのではなく、証明書が有効かどうかを監視するためのも
のです。
------------------------------------------------------------------------------------------------
- **証明書の検証プロセスの管理**:
`aws_acm_certificate` リソースによってリクエストされた証明書に対して、DNSなどの手法でドメインの所有権を検証する
必要があります。これは、証明書が実際にそのドメインの所有者によってリクエストされたものであることを確認するためです。
------------------------------------------------------------------------------------------------
- **apply時の振る舞い**:
Terraform `apply` コマンドを実行すると、`aws_acm_certificate_validation` リソースは ACM による証明書のド
メイン検証が完了するまで待機します。この検証が完了すると、Terraformは処理を続行します。
------------------------------------------------------------------------------------------------
- **検証の成功を保証するために使用される**:
Terraformが次のリソースの作成や更新に進む前に、SSL/TLS証明書が正しく検証され使用可能であることを保証するために使
用されます。これにより、検証が完了する前にリソースが使用されることを防ぐことができます。
------------------------------------------------------------------------------------------------
上記のコードは、ACMがリクエストされた証明書の検証プロセスを監視し、ドメイン検証が成功するとその情報を持つ Route 53 レコードの FQDN（完全修飾ドメイン名）のリストを受け取ります。検証プロセスが完了すると、Terraformは証明書が有効であると認識し、証明書をリソースに関連付けることができます。これにより、SSL/TLS証明書がフルマネージドな状態で適切にデプロイされることが保証されます。
*/
